<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <title>Track Review - Windsurfer Tracker</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; }

        #map {
            position: absolute;
            top: 60px;
            left: 0;
            right: 300px;
            bottom: 80px;
        }

        #controls {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 60px;
            background: #2c3e50;
            color: white;
            display: flex;
            align-items: center;
            padding: 0 20px;
            gap: 20px;
            z-index: 1000;
        }

        #controls label {
            font-size: 14px;
        }

        #controls select, #controls input {
            padding: 8px 12px;
            border: none;
            border-radius: 4px;
            font-size: 14px;
        }

        #controls button {
            padding: 8px 16px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }

        #controls button:hover {
            background: #2980b9;
        }

        .graphs-dropdown {
            position: relative;
            display: inline-block;
        }

        .graphs-dropdown-content {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            background: #2c3e50;
            border: 1px solid #3498db;
            border-radius: 4px;
            padding: 8px 12px;
            z-index: 1001;
            white-space: nowrap;
            margin-top: 4px;
        }

        .graphs-dropdown-content.show {
            display: block;
        }

        .graphs-dropdown-content label {
            display: block;
            padding: 4px 0;
            cursor: pointer;
        }

        .graphs-dropdown-content label:hover {
            color: #3498db;
        }

        .about-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 2000;
            justify-content: center;
            align-items: center;
        }

        .about-modal.show {
            display: flex;
        }

        .about-content {
            background: white;
            padding: 30px;
            border-radius: 8px;
            max-width: 400px;
            text-align: center;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }

        .about-content h2 {
            margin: 0 0 20px 0;
            color: #2c3e50;
        }

        .about-content p {
            margin: 15px 0;
            color: #555;
        }

        .about-content a {
            color: #3498db;
            text-decoration: none;
        }

        .about-content a:hover {
            text-decoration: underline;
        }

        .about-content button {
            margin-top: 20px;
            padding: 10px 30px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }

        .about-content button:hover {
            background: #2980b9;
        }

        #sidebar {
            position: absolute;
            top: 60px;
            right: 0;
            width: 300px;
            bottom: 80px;
            background: #f5f5f5;
            overflow-y: auto;
            padding: 15px;
            border-left: 1px solid #ddd;
        }

        #sidebar h3 {
            margin-bottom: 10px;
            color: #2c3e50;
        }

        .user-item {
            display: flex;
            align-items: center;
            padding: 10px;
            margin-bottom: 8px;
            background: white;
            border-radius: 6px;
            cursor: pointer;
            border: 2px solid transparent;
        }

        .user-item:hover {
            border-color: #3498db;
        }

        .user-item.selected {
            border-color: #2ecc71;
            background: #e8f8f0;
        }

        .user-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            margin-right: 10px;
        }

        .user-info {
            flex: 1;
        }

        .user-name {
            font-weight: bold;
            color: #2c3e50;
        }

        .user-stats {
            font-size: 12px;
            color: #666;
        }

        #timeline {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 80px;
            background: #2c3e50;
            padding: 10px 20px;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        #time-display {
            color: white;
            text-align: center;
            margin-bottom: 10px;
            font-size: 16px;
        }

        .time-slider-container {
            position: relative;
            width: 100%;
            height: 30px;
        }

        .time-slider {
            position: absolute;
            width: 100%;
            pointer-events: none;
            -webkit-appearance: none;
            appearance: none;
            height: 8px;
            background: transparent;
            top: 10px;
        }

        .time-slider::-webkit-slider-thumb {
            pointer-events: auto;
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #3498db;
            cursor: pointer;
            border-radius: 50%;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .time-slider::-moz-range-thumb {
            pointer-events: auto;
            width: 20px;
            height: 20px;
            background: #3498db;
            cursor: pointer;
            border-radius: 50%;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        #start-slider::-webkit-slider-thumb {
            background: #2ecc71;
        }

        #start-slider::-moz-range-thumb {
            background: #2ecc71;
        }

        #end-slider::-webkit-slider-thumb {
            background: #e74c3c;
        }

        #end-slider::-moz-range-thumb {
            background: #e74c3c;
        }

        .slider-track {
            position: absolute;
            width: 100%;
            height: 8px;
            background: #555;
            border-radius: 4px;
            top: 10px;
        }

        .slider-range {
            position: absolute;
            height: 8px;
            background: #3498db;
            border-radius: 4px;
            top: 10px;
        }

        .time-labels {
            display: flex;
            justify-content: space-between;
            color: #bdc3c7;
            font-size: 11px;
            margin-top: 5px;
        }

        #playback-controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 10px;
        }

        #playback-controls button {
            padding: 5px 15px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        .speed-legend {
            position: absolute;
            bottom: 100px;
            left: 20px;
            background: white;
            padding: 10px;
            border-radius: 6px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            z-index: 1000;
        }

        .speed-legend h4 {
            margin-bottom: 8px;
            font-size: 12px;
        }

        .speed-gradient {
            width: 150px;
            height: 15px;
            background: linear-gradient(to right, #3498db, #2ecc71, #f1c40f, #e74c3c);
            border-radius: 3px;
        }

        .speed-labels {
            display: flex;
            justify-content: space-between;
            font-size: 10px;
            margin-top: 3px;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 20px 40px;
            border-radius: 8px;
            z-index: 2000;
            display: none;
        }

        #status {
            color: #bdc3c7;
            font-size: 12px;
        }

        #map-type-select {
            padding: 6px 10px;
            border: none;
            border-radius: 4px;
            font-size: 13px;
            background: #3498db;
            color: white;
            cursor: pointer;
        }

        #map-type-select option {
            background: white;
            color: #333;
        }

        /* Battery graph panel */
        #speed-graph-panel {
            position: absolute;
            bottom: 80px;
            left: 0;
            right: 300px;
            height: 150px;
            background: #1a252f;
            border-top: 1px solid #34495e;
            display: none;
        }

        #speed-graph-resize {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 8px;
            cursor: ns-resize;
            background: linear-gradient(to bottom, #34495e, transparent);
            z-index: 10;
        }

        #speed-graph-resize:hover,
        #speed-graph-resize.dragging {
            background: linear-gradient(to bottom, #3498db, transparent);
        }

        #speed-graph-resize::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 50%;
            transform: translateX(-50%);
            width: 40px;
            height: 4px;
            background: #5a6a7a;
            border-radius: 2px;
        }

        #speed-graph-resize:hover::after,
        #speed-graph-resize.dragging::after {
            background: #7a8a9a;
        }

        #speed-graph-panel.visible {
            display: block;
        }

        #speed-graph-container {
            position: relative;
            width: 100%;
            height: 100%;
            padding: 10px 50px 25px 50px;
        }

        #speed-graph {
            width: 100%;
            height: 100%;
            background: #2c3e50;
            border-radius: 4px;
        }

        .speed-graph-title {
            position: absolute;
            top: 5px;
            left: 60px;
            color: #3498db;
            font-size: 12px;
            font-weight: bold;
        }

        .speed-y-axis {
            position: absolute;
            left: 10px;
            top: 10px;
            bottom: 25px;
            width: 35px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            color: #7f8c8d;
            font-size: 11px;
            text-align: right;
            padding-right: 5px;
        }

        .speed-time-axis {
            position: absolute;
            bottom: 5px;
            left: 50px;
            right: 50px;
            display: flex;
            justify-content: space-between;
            color: #7f8c8d;
            font-size: 11px;
        }

        #battery-graph-panel {
            position: absolute;
            bottom: 80px;
            left: 0;
            right: 300px;
            height: 150px;
            background: #1a252f;
            border-top: 1px solid #34495e;
            display: none;
        }

        #battery-graph-resize {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 8px;
            cursor: ns-resize;
            background: linear-gradient(to bottom, #34495e, transparent);
            z-index: 10;
        }

        #battery-graph-resize:hover,
        #battery-graph-resize.dragging {
            background: linear-gradient(to bottom, #3498db, transparent);
        }

        #battery-graph-resize::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 50%;
            transform: translateX(-50%);
            width: 40px;
            height: 4px;
            background: #5a6a7a;
            border-radius: 2px;
        }

        #battery-graph-resize:hover::after,
        #battery-graph-resize.dragging::after {
            background: #7a8a9a;
        }

        #battery-graph-panel.visible {
            display: block;
        }

        #battery-graph-container {
            position: relative;
            width: 100%;
            height: 100%;
            padding: 10px 50px 25px 50px;
        }

        #battery-graph {
            width: 100%;
            height: 100%;
            background: #2c3e50;
            border-radius: 4px;
        }

        .battery-graph-title {
            position: absolute;
            top: 5px;
            left: 50%;
            transform: translateX(-50%);
            color: #bdc3c7;
            font-size: 12px;
            font-weight: bold;
        }

        .battery-y-axis {
            position: absolute;
            left: 10px;
            top: 10px;
            bottom: 25px;
            width: 35px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: flex-end;
            color: #95a5a6;
            font-size: 10px;
        }

        .battery-x-axis {
            position: absolute;
            bottom: 5px;
            left: 50px;
            right: 50px;
            display: flex;
            justify-content: space-between;
            color: #95a5a6;
            font-size: 10px;
        }

        /* Battery graph panel visibility is controlled by JavaScript for dynamic height */

        /* Signal graph panel */
        #signal-graph-panel {
            position: absolute;
            bottom: 80px;
            left: 0;
            right: 300px;
            height: 150px;
            background: #1a252f;
            border-top: 1px solid #34495e;
            display: none;
        }

        #signal-graph-resize {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 8px;
            cursor: ns-resize;
            background: linear-gradient(to bottom, #34495e, transparent);
            z-index: 10;
        }

        #signal-graph-resize:hover,
        #signal-graph-resize.dragging {
            background: linear-gradient(to bottom, #27ae60, transparent);
        }

        #signal-graph-resize::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 50%;
            transform: translateX(-50%);
            width: 40px;
            height: 4px;
            background: #5a6a7a;
            border-radius: 2px;
        }

        #signal-graph-resize:hover::after,
        #signal-graph-resize.dragging::after {
            background: #7a8a9a;
        }

        #signal-graph-container {
            position: relative;
            width: 100%;
            height: 100%;
            padding: 10px 50px 25px 50px;
        }

        #signal-graph {
            width: 100%;
            height: 100%;
            background: #2c3e50;
            border-radius: 4px;
        }

        .signal-graph-title {
            position: absolute;
            top: 5px;
            left: 50%;
            transform: translateX(-50%);
            color: #bdc3c7;
            font-size: 12px;
            font-weight: bold;
        }

        .signal-y-axis {
            position: absolute;
            left: 10px;
            top: 10px;
            bottom: 25px;
            width: 35px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: flex-end;
            color: #95a5a6;
            font-size: 10px;
        }

        .signal-x-axis {
            position: absolute;
            bottom: 5px;
            left: 50px;
            right: 50px;
            display: flex;
            justify-content: space-between;
            color: #95a5a6;
            font-size: 10px;
        }

        /* Latency graph panel */
        #latency-graph-panel {
            position: absolute;
            bottom: 80px;
            left: 0;
            right: 300px;
            height: 150px;
            background: #1a252f;
            border-top: 1px solid #34495e;
            display: none;
        }

        #latency-graph-resize {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 8px;
            cursor: ns-resize;
            background: linear-gradient(to bottom, #34495e, transparent);
            z-index: 10;
        }

        #latency-graph-resize:hover,
        #latency-graph-resize.dragging {
            background: linear-gradient(to bottom, #e67e22, transparent);
        }

        #latency-graph-resize::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 50%;
            transform: translateX(-50%);
            width: 40px;
            height: 4px;
            background: #5a6a7a;
            border-radius: 2px;
        }

        #latency-graph-resize:hover::after,
        #latency-graph-resize.dragging::after {
            background: #7a8a9a;
        }

        #latency-graph-container {
            position: relative;
            width: 100%;
            height: 100%;
            padding: 10px 50px 25px 50px;
        }

        #latency-graph {
            width: 100%;
            height: 100%;
            background: #2c3e50;
            border-radius: 4px;
        }

        .latency-graph-title {
            position: absolute;
            top: 5px;
            left: 50%;
            transform: translateX(-50%);
            color: #bdc3c7;
            font-size: 12px;
            font-weight: bold;
        }

        .latency-y-axis {
            position: absolute;
            left: 10px;
            top: 10px;
            bottom: 25px;
            width: 35px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: flex-end;
            color: #95a5a6;
            font-size: 10px;
        }

        .latency-x-axis {
            position: absolute;
            bottom: 5px;
            left: 50px;
            right: 50px;
            display: flex;
            justify-content: space-between;
            color: #95a5a6;
            font-size: 10px;
        }

        /* Heart rate graph panel */
        #heartrate-graph-panel {
            position: absolute;
            bottom: 80px;
            left: 0;
            right: 300px;
            height: 150px;
            background: #1a252f;
            border-top: 1px solid #34495e;
            display: none;
        }

        #heartrate-graph-resize {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 8px;
            cursor: ns-resize;
            background: linear-gradient(to bottom, #34495e, transparent);
            z-index: 10;
        }

        #heartrate-graph-resize:hover,
        #heartrate-graph-resize.dragging {
            background: linear-gradient(to bottom, #e91e63, transparent);
        }

        #heartrate-graph-resize::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 50%;
            transform: translateX(-50%);
            width: 40px;
            height: 4px;
            background: #5a6a7a;
            border-radius: 2px;
        }

        #heartrate-graph-resize:hover::after,
        #heartrate-graph-resize.dragging::after {
            background: #7a8a9a;
        }

        #heartrate-graph-container {
            position: relative;
            width: 100%;
            height: 100%;
            padding: 10px 50px 25px 50px;
        }

        #heartrate-graph {
            width: 100%;
            height: 100%;
            background: #2c3e50;
            border-radius: 4px;
        }

        .heartrate-graph-title {
            position: absolute;
            top: 5px;
            left: 50%;
            transform: translateX(-50%);
            color: #e91e63;
            font-size: 12px;
            font-weight: bold;
        }

        .heartrate-y-axis {
            position: absolute;
            left: 10px;
            top: 10px;
            bottom: 25px;
            width: 35px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: flex-end;
            color: #95a5a6;
            font-size: 10px;
        }

        .heartrate-x-axis {
            position: absolute;
            bottom: 5px;
            left: 50px;
            right: 50px;
            display: flex;
            justify-content: space-between;
            color: #95a5a6;
            font-size: 10px;
        }

        /* Accuracy graph panel */
        #accuracy-graph-panel {
            position: absolute;
            bottom: 80px;
            left: 0;
            right: 300px;
            height: 150px;
            background: #1a252f;
            border-top: 1px solid #34495e;
            display: none;
        }

        #accuracy-graph-resize {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 8px;
            cursor: ns-resize;
            background: linear-gradient(to bottom, #34495e, transparent);
            z-index: 10;
        }

        #accuracy-graph-resize:hover,
        #accuracy-graph-resize.dragging {
            background: linear-gradient(to bottom, #9b59b6, transparent);
        }

        #accuracy-graph-resize::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 50%;
            transform: translateX(-50%);
            width: 40px;
            height: 4px;
            background: #5a6a7a;
            border-radius: 2px;
        }

        #accuracy-graph-resize:hover::after,
        #accuracy-graph-resize.dragging::after {
            background: #7a8a9a;
        }

        #accuracy-graph-container {
            position: relative;
            width: 100%;
            height: 100%;
            padding: 10px 50px 25px 50px;
        }

        #accuracy-graph {
            width: 100%;
            height: 100%;
            background: #2c3e50;
            border-radius: 4px;
        }

        .accuracy-graph-title {
            position: absolute;
            top: 5px;
            left: 50%;
            transform: translateX(-50%);
            color: #9b59b6;
            font-size: 12px;
            font-weight: bold;
        }

        .accuracy-y-axis {
            position: absolute;
            left: 10px;
            top: 10px;
            bottom: 25px;
            width: 35px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: flex-end;
            color: #95a5a6;
            font-size: 10px;
        }

        .accuracy-x-axis {
            position: absolute;
            bottom: 5px;
            left: 50px;
            right: 50px;
            display: flex;
            justify-content: space-between;
            color: #95a5a6;
            font-size: 10px;
        }

        /* Distance graph panel */
        #distance-graph-panel {
            position: absolute;
            bottom: 80px;
            left: 0;
            right: 300px;
            height: 150px;
            background: #1a252f;
            border-top: 1px solid #34495e;
            display: none;
        }

        #distance-graph-resize {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 8px;
            cursor: ns-resize;
            background: linear-gradient(to bottom, #34495e, transparent);
            z-index: 10;
        }

        #distance-graph-resize:hover,
        #distance-graph-resize.dragging {
            background: linear-gradient(to bottom, #27ae60, transparent);
        }

        #distance-graph-resize::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 50%;
            transform: translateX(-50%);
            width: 40px;
            height: 4px;
            background: #5a6a7a;
            border-radius: 2px;
        }

        #distance-graph-resize:hover::after,
        #distance-graph-resize.dragging::after {
            background: #7a8a9a;
        }

        #distance-graph-container {
            position: relative;
            width: 100%;
            height: 100%;
            padding: 10px 50px 25px 50px;
        }

        #distance-graph {
            width: 100%;
            height: 100%;
            background: #2c3e50;
            border-radius: 4px;
        }

        .distance-graph-title {
            position: absolute;
            top: 5px;
            left: 50%;
            transform: translateX(-50%);
            color: #27ae60;
            font-size: 12px;
            font-weight: bold;
        }

        .distance-y-axis {
            position: absolute;
            left: 10px;
            top: 10px;
            bottom: 25px;
            width: 35px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: flex-end;
            color: #95a5a6;
            font-size: 10px;
        }

        .distance-x-axis {
            position: absolute;
            bottom: 5px;
            left: 50px;
            right: 50px;
            display: flex;
            justify-content: space-between;
            color: #95a5a6;
            font-size: 10px;
        }

        /* Hamburger menu button (hidden on desktop) */
        #sidebar-toggle {
            display: none;
            position: fixed;
            top: 70px;
            right: 15px;
            z-index: 1001;
            width: 44px;
            height: 44px;
            background: #2c3e50;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 5px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }

        #sidebar-toggle span {
            display: block;
            width: 24px;
            height: 3px;
            background: white;
            border-radius: 2px;
            transition: transform 0.3s, opacity 0.3s;
        }

        #sidebar-toggle.open span:nth-child(1) {
            transform: rotate(45deg) translate(5px, 5px);
        }
        #sidebar-toggle.open span:nth-child(2) {
            opacity: 0;
        }
        #sidebar-toggle.open span:nth-child(3) {
            transform: rotate(-45deg) translate(5px, -5px);
        }

        /* Overlay when drawer is open */
        #sidebar-overlay {
            display: none;
            position: fixed;
            top: 60px;
            left: 0;
            right: 0;
            bottom: 80px;
            background: black;
            opacity: 0;
            pointer-events: none;
            z-index: 1000;
            transition: opacity 0.3s;
        }

        #sidebar-overlay.visible {
            opacity: 0.5;
            pointer-events: auto;
        }

        /* Race selector styles */
        .race-item {
            display: flex;
            flex-direction: column;
            padding: 12px;
            margin-bottom: 8px;
            background: white;
            border-radius: 6px;
            cursor: pointer;
            border: 2px solid transparent;
        }

        .race-item:hover {
            border-color: #3498db;
        }

        .race-item.selected {
            border-color: #2ecc71;
            background: #e8f8f0;
        }

        .race-time {
            font-weight: bold;
            color: #2c3e50;
        }

        .race-stats {
            font-size: 12px;
            color: #666;
            margin-top: 4px;
        }

        #race-selector {
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px solid #ddd;
        }

        /* Mobile responsive layout */
        @media (max-width: 768px) {
            #sidebar-toggle {
                display: flex;
            }

            #sidebar-overlay {
                display: block;
            }

            #sidebar {
                position: fixed;
                right: -320px;
                transition: right 0.3s ease-in-out;
                z-index: 1002;
                box-shadow: -2px 0 10px rgba(0,0,0,0.3);
            }

            #sidebar.open {
                right: 0;
            }

            #map {
                right: 0;
                top: 110px;
                bottom: 140px;
            }

            #controls {
                position: fixed;
                flex-wrap: wrap;
                height: auto;
                min-height: 60px;
                padding: 10px;
                gap: 8px;
            }

            #controls label {
                font-size: 11px;
            }

            #controls > a {
                font-size: 11px;
                padding: 5px 8px !important;
            }

            #controls button {
                font-size: 12px;
                padding: 6px 10px;
            }

            #timeline {
                position: fixed;
                height: auto;
                min-height: 130px;
                padding: 8px 10px;
            }

            #time-display {
                font-size: 12px;
                margin-bottom: 5px;
            }

            .time-slider-container {
                height: 40px;
            }

            .time-slider::-webkit-slider-thumb {
                width: 28px;
                height: 28px;
            }

            .time-slider::-moz-range-thumb {
                width: 28px;
                height: 28px;
            }

            #playback-controls {
                flex-wrap: wrap;
                margin-top: 5px;
            }

            #playback-controls button {
                padding: 8px 10px;
                font-size: 12px;
            }

            .speed-legend {
                display: none;
            }

            #speed-graph-panel,
            #distance-graph-panel,
            #battery-graph-panel,
            #signal-graph-panel,
            #latency-graph-panel,
            #heartrate-graph-panel,
            #accuracy-graph-panel {
                right: 0;
            }

            .speed-graph-title,
            .distance-graph-title,
            .battery-graph-title,
            .signal-graph-title,
            .latency-graph-title,
            .heartrate-graph-title,
            .accuracy-graph-title {
                font-size: 10px;
            }

            .speed-y-axis,
            .distance-y-axis,
            .battery-y-axis,
            .signal-y-axis,
            .latency-y-axis,
            .accuracy-y-axis {
                font-size: 8px;
                width: 25px;
                left: 5px;
            }

            #speed-graph-container,
            #distance-graph-container,
            #battery-graph-container,
            #signal-graph-container,
            #latency-graph-container,
            #heartrate-graph-container,
            #accuracy-graph-container {
                padding: 8px 35px 20px 35px;
            }
        }

        /* Scale control styling */
        .custom-scale {
            position: fixed;
            bottom: 175px;
            left: 20px;
            z-index: 1001;
            background: white;
            padding: 6px 12px;
            border-radius: 6px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            font-size: 14px;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 10px;
            max-width: calc(100vw - 20px);
        }

        .scale-bar {
            height: 10px;
            background: repeating-linear-gradient(
                90deg,
                #333 0px,
                #333 25%,
                #fff 25%,
                #fff 50%
            );
            border: 2px solid #333;
            min-width: 80px;
            max-width: 200px;
        }

        .scale-text {
            white-space: nowrap;
        }

        /* Event name in header */
        .event-header-name {
            color: #f0f0f0;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            padding: 6px 12px;
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
            max-width: 300px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            display: none;
        }

        .event-header-name:hover {
            background: rgba(255,255,255,0.2);
        }

        /* Event description modal */
        .event-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 10002;
            display: none;
            align-items: center;
            justify-content: center;
        }

        .event-modal-overlay.visible {
            display: flex;
        }

        .event-modal {
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 30px rgba(0,0,0,0.3);
            max-width: 600px;
            max-height: 80vh;
            width: 90%;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .event-modal-header {
            padding: 16px 20px;
            background: #2c3e50;
            color: white;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .event-modal-header h2 {
            margin: 0;
            font-size: 20px;
            font-weight: 600;
        }

        .event-modal-close {
            background: none;
            border: none;
            color: white;
            font-size: 28px;
            cursor: pointer;
            padding: 0;
            line-height: 1;
            opacity: 0.8;
        }

        .event-modal-close:hover {
            opacity: 1;
        }

        .event-modal-body {
            padding: 20px;
            overflow-y: auto;
            flex-grow: 1;
        }

        .event-modal-body p {
            margin: 0;
            line-height: 1.6;
            color: #333;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .event-modal-body a {
            color: #1976D2;
            text-decoration: none;
        }

        .event-modal-body a:hover {
            text-decoration: underline;
        }

        .event-modal-footer {
            padding: 12px 20px;
            background: #f5f5f5;
            border-top: 1px solid #e0e0e0;
            text-align: center;
        }

        .event-modal-footer a {
            color: #666;
            text-decoration: none;
            font-size: 14px;
        }

        .event-modal-footer a:hover {
            color: #333;
        }

        /* Marker labels */
        .marker-label {
            position: absolute;
            left: 50%;
            top: 100%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.75);
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 11px;
            white-space: nowrap;
            pointer-events: none;
            margin-top: 2px;
        }
    </style>
</head>
<body>
    <!-- Event description modal -->
    <div class="event-modal-overlay" id="eventModalOverlay" onclick="hideEventModal(event)">
        <div class="event-modal" onclick="event.stopPropagation()">
            <div class="event-modal-header">
                <h2 id="eventModalTitle"></h2>
                <button class="event-modal-close" onclick="hideEventModal()">&times;</button>
            </div>
            <div class="event-modal-body">
                <p id="eventModalDescription"></p>
            </div>
            <div class="event-modal-footer">
                <a href="index.html">‚Üê Back to Events List</a>
            </div>
        </div>
    </div>

    <div id="controls">
        <a id="live-link" href="event.html" style="color:white;text-decoration:none;padding:8px 12px;background:#27ae60;border-radius:4px;margin-right:10px;">‚Üê Live Tracking</a>
        <span class="event-header-name" id="eventHeaderName" onclick="showEventModal()" title="Click for event details"></span>
        <a href="index.html" style="color:#aaa;text-decoration:none;padding:8px 12px;margin-right:10px;font-size:12px;">üìã All Events</a>
        <label>Date: <input type="date" id="date-picker"></label>
        <button id="load-btn">Load Tracks</button>
        <div class="graphs-dropdown">
            <button id="options-btn">Options ‚ñº</button>
            <div id="options-dropdown-content" class="graphs-dropdown-content">
                <label><input type="checkbox" id="speed-color" checked> Color by speed</label>
                <label><input type="checkbox" id="show-markers" checked> Show markers</label>
                <label><input type="checkbox" id="filter-outliers" checked> Filter outliers</label>
                <label><input type="checkbox" id="show-outliers"> Show outliers (red)</label>
                <label><input type="checkbox" id="show-course" checked> Show course</label>
            </div>
        </div>
        <div class="graphs-dropdown">
            <button id="graphs-btn">Graphs ‚ñº</button>
            <div id="graphs-dropdown-content" class="graphs-dropdown-content">
                <label><input type="checkbox" id="show-speed-graph"> Speed</label>
                <label><input type="checkbox" id="show-distance-graph"> Distance</label>
                <label><input type="checkbox" id="show-battery-graph"> Battery</label>
                <label><input type="checkbox" id="show-signal-graph"> Signal</label>
                <label><input type="checkbox" id="show-latency-graph"> Latency</label>
                <label><input type="checkbox" id="show-heartrate-graph"> Heart Rate</label>
                <label><input type="checkbox" id="show-accuracy-graph"> Accuracy</label>
            </div>
        </div>
        <select id="map-type-select" onchange="setMapType(this.value)" style="display:none">
            <option value="osm">OpenStreetMap</option>
            <option value="roads">Google Roads</option>
            <option value="satellite">Google Satellite</option>
            <option value="hybrid">Google Hybrid</option>
        </select>
        <button id="about-btn">About</button>
        <span id="status"></span>
    </div>

    <!-- About modal -->
    <div id="about-modal" class="about-modal">
        <div class="about-content">
            <h2>Windsurfer Tracker</h2>
            <p>GPS tracking system for windsurfing races</p>
            <p><a href="https://wstracker.org/install" target="_blank">Install App (Android/iPhone)</a></p>
            <p><a href="https://github.com/tridge/windsurfer-tracker" target="_blank">Source Code on GitHub</a></p>
            <button id="about-close-btn">Close</button>
        </div>
    </div>

    <div id="map"></div>

    <div class="custom-scale" id="customScale">
        <div class="scale-bar" id="scaleBar"></div>
        <span class="scale-text" id="scaleText">100m</span>
    </div>

    <!-- Speed graph panel -->
    <div id="speed-graph-panel">
        <div id="speed-graph-resize"></div>
        <div id="speed-graph-container">
            <div class="speed-graph-title">Speed (knots)</div>
            <div class="speed-y-axis" id="speed-y-labels">
                <span>40</span>
                <span>30</span>
                <span>20</span>
                <span>10</span>
                <span>0</span>
            </div>
            <canvas id="speed-graph"></canvas>
            <div class="speed-time-axis">
                <span id="speed-time-start">--:--</span>
                <span id="speed-time-end">--:--</span>
            </div>
        </div>
    </div>

    <!-- Battery graph panel -->
    <div id="battery-graph-panel">
        <div id="battery-graph-resize"></div>
        <div id="battery-graph-container">
            <div class="battery-graph-title">Battery Level (%)</div>
            <div class="battery-y-axis" id="battery-y-labels">
                <span>100</span>
                <span>75</span>
                <span>50</span>
                <span>25</span>
                <span>0</span>
            </div>
            <canvas id="battery-graph"></canvas>
            <div class="battery-x-axis">
                <span id="battery-time-start">--:--</span>
                <span id="battery-time-end">--:--</span>
            </div>
        </div>
    </div>

    <!-- Signal graph panel -->
    <div id="signal-graph-panel">
        <div id="signal-graph-resize"></div>
        <div id="signal-graph-container">
            <div class="signal-graph-title">Signal Strength</div>
            <div class="signal-y-axis">
                <span>4</span>
                <span>3</span>
                <span>2</span>
                <span>1</span>
                <span>0</span>
            </div>
            <canvas id="signal-graph"></canvas>
            <div class="signal-x-axis">
                <span id="signal-time-start">--:--</span>
                <span id="signal-time-end">--:--</span>
            </div>
        </div>
    </div>

    <!-- Latency graph panel -->
    <div id="latency-graph-panel">
        <div id="latency-graph-resize"></div>
        <div id="latency-graph-container">
            <div class="latency-graph-title">Network Latency (seconds)</div>
            <div class="latency-y-axis" id="latency-y-labels">
                <span>10</span>
                <span>7.5</span>
                <span>5</span>
                <span>2.5</span>
                <span>0</span>
            </div>
            <canvas id="latency-graph"></canvas>
            <div class="latency-x-axis">
                <span id="latency-time-start">--:--</span>
                <span id="latency-time-end">--:--</span>
            </div>
        </div>
    </div>

    <!-- Heart rate graph panel -->
    <div id="heartrate-graph-panel">
        <div id="heartrate-graph-resize"></div>
        <div id="heartrate-graph-container">
            <div class="heartrate-graph-title">Heart Rate (bpm)</div>
            <div class="heartrate-y-axis" id="heartrate-y-labels">
                <span>200</span>
                <span>150</span>
                <span>100</span>
                <span>50</span>
                <span>0</span>
            </div>
            <canvas id="heartrate-graph"></canvas>
            <div class="heartrate-x-axis">
                <span id="heartrate-time-start">--:--</span>
                <span id="heartrate-time-end">--:--</span>
            </div>
        </div>
    </div>

    <!-- Accuracy graph panel -->
    <div id="accuracy-graph-panel">
        <div id="accuracy-graph-resize"></div>
        <div id="accuracy-graph-container">
            <div class="accuracy-graph-title">GPS Accuracy (meters)</div>
            <div class="accuracy-y-axis" id="accuracy-y-labels">
                <span>100</span>
                <span>75</span>
                <span>50</span>
                <span>25</span>
                <span>0</span>
            </div>
            <canvas id="accuracy-graph"></canvas>
            <div class="accuracy-x-axis">
                <span id="accuracy-time-start">--:--</span>
                <span id="accuracy-time-end">--:--</span>
            </div>
        </div>
    </div>

    <!-- Distance graph panel -->
    <div id="distance-graph-panel">
        <div id="distance-graph-resize"></div>
        <div id="distance-graph-container">
            <div class="distance-graph-title">Distance (meters)</div>
            <div class="distance-y-axis" id="distance-y-labels">
                <span>10000</span>
                <span>7500</span>
                <span>5000</span>
                <span>2500</span>
                <span>0</span>
            </div>
            <canvas id="distance-graph"></canvas>
            <div class="distance-x-axis">
                <span id="distance-time-start">--:--</span>
                <span id="distance-time-end">--:--</span>
            </div>
        </div>
    </div>

    <!-- Hamburger menu button (mobile only) -->
    <button id="sidebar-toggle" aria-label="Toggle sidebar">
        <span></span>
        <span></span>
        <span></span>
    </button>

    <!-- Overlay when drawer is open (mobile only) -->
    <div id="sidebar-overlay"></div>

    <div id="sidebar">
        <div id="timezone-display" style="display:none;background:#e8f4fd;border-radius:4px;padding:8px 12px;margin-bottom:12px;font-size:13px;color:#1e40af;">
            <strong>Timezone:</strong> <span id="event-timezone">-</span>
        </div>
        <div id="race-selector">
            <h3>Select Log</h3>
            <div id="race-list">
                <p style="color:#666">Select a date to see logs</p>
            </div>
        </div>
        <h3>Users</h3>
        <div style="margin-bottom:10px;">
            <button id="show-all-btn" style="padding:5px 10px;margin-right:5px;">Show All</button>
            <button id="hide-all-btn" style="padding:5px 10px;">Hide All</button>
        </div>
        <div id="user-list">
            <p style="color:#666">Select a log to see users</p>
        </div>
    </div>

    <div id="timeline">
        <div id="time-display">
            <span style="color:#2ecc71">Start: --:--:--</span> &nbsp;|&nbsp;
            <span style="color:#e74c3c">End: --:--:--</span> &nbsp;|&nbsp;
            Duration: --:--
        </div>
        <div class="time-slider-container">
            <div class="slider-track"></div>
            <div class="slider-range" id="slider-range"></div>
            <input type="range" class="time-slider" id="start-slider" min="0" max="100" value="0">
            <input type="range" class="time-slider" id="end-slider" min="0" max="100" value="100">
        </div>
        <div class="time-labels">
            <span id="label-start">--:--:--</span>
            <span id="label-end">--:--:--</span>
        </div>
        <div id="playback-controls">
            <button id="play-btn">‚ñ∂ Play</button>
            <button id="speed-1x" class="speed-btn">1x</button>
            <button id="speed-5x" class="speed-btn">5x</button>
            <button id="speed-20x" class="speed-btn">20x</button>
            <button id="reset-range-btn" style="background:#95a5a6">Reset Range</button>
        </div>
    </div>

    <div class="speed-legend">
        <h4>Speed (knots)</h4>
        <div class="speed-gradient"></div>
        <div class="speed-labels">
            <span>0</span>
            <span>5</span>
            <span>10</span>
            <span>15+</span>
        </div>
    </div>

    <div id="loading">Loading tracks...</div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet.gridlayer.googlemutant@0.14.1/dist/Leaflet.GoogleMutant.js"></script>
    <!-- Google Maps API key (optional - create config.js from config.js.example) -->
    <script>
        var GMAPS_API_KEY = null;
    </script>
    <script src="config.js" onerror=""></script>
    <script>
        // Load Google Maps API dynamically if API key is configured
        if (GMAPS_API_KEY && GMAPS_API_KEY !== 'YOUR_API_KEY_HERE') {
            var script = document.createElement('script');
            script.src = 'https://maps.googleapis.com/maps/api/js?key=' + GMAPS_API_KEY;
            script.async = true;
            document.head.appendChild(script);
        }
    </script>
    <script>
        // Event ID from URL parameter (default to 1 for backwards compatibility)
        const urlParams = new URLSearchParams(window.location.search);
        const EVENT_ID = parseInt(urlParams.get('eid')) || 1;
        const DATA_BASE = `${EVENT_ID}/`;

        // Store event info for modal
        let currentEventInfo = null;

        // Convert URLs in text to clickable links
        function linkifyText(text) {
            if (!text) return '';
            const urlPattern = /(https?:\/\/[^\s<]+)/g;
            return text.replace(urlPattern, '<a href="$1" target="_blank" rel="noopener noreferrer">$1</a>');
        }

        // Show event description modal
        function showEventModal() {
            if (!currentEventInfo) return;
            document.getElementById('eventModalTitle').textContent = currentEventInfo.name;
            const description = currentEventInfo.description || 'No description available.';
            document.getElementById('eventModalDescription').innerHTML = linkifyText(description);
            document.getElementById('eventModalOverlay').classList.add('visible');
        }

        // Hide event description modal
        function hideEventModal(e) {
            if (e && e.target !== e.currentTarget) return;
            document.getElementById('eventModalOverlay').classList.remove('visible');
        }

        // Event timezone (defaults to local, updated when event info is fetched)
        let eventTimezone = Intl.DateTimeFormat().resolvedOptions().timeZone;

        // Get today's date in event timezone (for date picker)
        function getTodayInEventTz() {
            // Get current date parts in event timezone
            const parts = new Date().toLocaleDateString('en-CA', { timeZone: eventTimezone });
            return parts; // Format: YYYY-MM-DD (en-CA gives ISO format)
        }

        // Format time in event timezone
        function formatTimeInTz(ts) {
            return new Date(ts * 1000).toLocaleTimeString([], {
                timeZone: eventTimezone,
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit'
            });
        }

        function formatTimeShortInTz(ts) {
            return new Date(ts * 1000).toLocaleTimeString([], {
                timeZone: eventTimezone,
                hour: '2-digit',
                minute: '2-digit'
            });
        }

        // Fetch event name and update page title + header
        (async function() {
            try {
                const response = await fetch('/api/events');
                if (response.ok) {
                    const data = await response.json();
                    const event = data.events.find(e => e.eid === EVENT_ID);
                    if (event && event.name) {
                        currentEventInfo = event;
                        document.title = `${event.name} - Track Review`;
                        const headerEl = document.getElementById('eventHeaderName');
                        headerEl.textContent = event.name;
                        headerEl.style.display = 'inline-block';

                        // Display and use event timezone
                        if (event.timezone) {
                            eventTimezone = event.timezone;
                            document.getElementById('event-timezone').textContent = event.timezone;
                            document.getElementById('timezone-display').style.display = 'block';
                            // Update date picker to use event timezone
                            document.getElementById('date-picker').value = getTodayInEventTz();
                        }

                        // Center map on event home location if available
                        if (event.home_lat && event.home_lon) {
                            map.setView([event.home_lat, event.home_lon], 13);
                        }
                    }
                }
            } catch (e) {
                console.error('Failed to fetch event name:', e);
            }
        })();

        // Initialize map
        const map = L.map('map').setView([-36.85, 174.88], 13);

        // Map layers
        const osmLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; OpenStreetMap contributors',
            maxZoom: 19
        });
        let googleLayers = {};
        let currentMapType = localStorage.getItem('mapType') || 'osm';
        let currentLayer = null;

        // Initialize map layers after Google Maps API loads
        function initMapLayers() {
            if (GMAPS_API_KEY && GMAPS_API_KEY !== 'YOUR_API_KEY_HERE' && typeof google !== 'undefined') {
                // Show map type selector
                document.getElementById('map-type-select').style.display = '';

                // Create Google layers for each type
                googleLayers.roads = L.gridLayer.googleMutant({ type: 'roadmap', maxZoom: 21 });
                googleLayers.satellite = L.gridLayer.googleMutant({ type: 'satellite', maxZoom: 21 });
                googleLayers.hybrid = L.gridLayer.googleMutant({ type: 'hybrid', maxZoom: 21 });

                // Apply saved map type
                setMapType(currentMapType);
            } else {
                // No Google Maps available, use OSM only
                osmLayer.addTo(map);
                currentLayer = osmLayer;
                currentMapType = 'osm';
            }
        }

        function setMapType(mapType) {
            // Remove current layer
            if (currentLayer) {
                map.removeLayer(currentLayer);
            }

            // Add new layer
            if (mapType === 'osm') {
                currentLayer = osmLayer;
            } else if (googleLayers[mapType]) {
                currentLayer = googleLayers[mapType];
            } else {
                // Fallback to OSM
                currentLayer = osmLayer;
                mapType = 'osm';
            }
            currentLayer.addTo(map);
            currentMapType = mapType;
            localStorage.setItem('mapType', mapType);

            // Update select dropdown
            document.getElementById('map-type-select').value = mapType;
        }

        // Initialize layers - wait for Google Maps to load if configured
        if (GMAPS_API_KEY && GMAPS_API_KEY !== 'YOUR_API_KEY_HERE') {
            // Wait for Google Maps to load
            const checkGoogle = setInterval(() => {
                if (typeof google !== 'undefined') {
                    clearInterval(checkGoogle);
                    initMapLayers();
                }
            }, 100);
            // Timeout fallback - use OSM if Google doesn't load
            setTimeout(() => {
                clearInterval(checkGoogle);
                if (!currentLayer) {
                    osmLayer.addTo(map);
                    currentLayer = osmLayer;
                }
            }, 5000);
        } else {
            osmLayer.addTo(map);
            currentLayer = osmLayer;
        }

        // Custom scale control
        function updateScale() {
            const center = map.getCenter();
            const zoom = map.getZoom();

            // Calculate meters per pixel at current zoom and latitude
            // At zoom 0, the world is 256 pixels wide = 40075km at equator
            const metersPerPixel = 40075016.686 * Math.cos(center.lat * Math.PI / 180) / Math.pow(2, zoom + 8);

            // Find a nice round distance that fits in ~80-200 pixels
            const distances = [10, 20, 50, 100, 200, 500, 1000, 2000, 5000, 10000, 20000, 50000];
            let bestDist = distances[0];
            let bestWidth = bestDist / metersPerPixel;

            for (const dist of distances) {
                const width = dist / metersPerPixel;
                if (width >= 80 && width <= 200) {
                    bestDist = dist;
                    bestWidth = width;
                    break;
                }
                if (width < 200) {
                    bestDist = dist;
                    bestWidth = width;
                }
            }

            // Update the scale bar
            document.getElementById('scaleBar').style.width = bestWidth + 'px';

            // Format the distance text
            let text;
            if (bestDist >= 1000) {
                text = (bestDist / 1000) + ' km';
            } else {
                text = bestDist + ' m';
            }
            document.getElementById('scaleText').textContent = text;
        }

        // Update scale on zoom/move
        map.on('zoomend', updateScale);
        map.on('moveend', updateScale);
        updateScale();  // Initial update

        // State
        let allData = [];
        let userData = {};
        let userOverrides = {};  // Name mappings from users.json
        let trackLayers = {};
        let markerLayers = {};
        let pointLayers = {};
        let outlierLayers = {};  // Outlier markers per user
        let selectedUsers = new Set();
        let playbackInterval = null;
        let playbackSpeed = 1;
        let minTime = 0;
        let maxTime = 0;
        let rangeStartTime = 0;  // User-selected start time
        let rangeEndTime = 0;    // User-selected end time
        let currentSummary = null;  // Summary data for selected date
        let currentLogFile = null;  // Currently loaded log file
        let sliderDebounceTimer = null;  // Debounce timer for slider redraw
        let courseMarkers = [];  // Course marker layers
        let courseLines = [];    // Course line layers
        let showCourse = true;   // Whether to display course
        let currentCourseFile = null;  // Currently loaded course filename

        // Expand log entry - handles both old format (lat/lon direct) and new format (pos array)
        function expandEntry(entry) {
            if (entry.pos && Array.isArray(entry.pos)) {
                // New compact format: pos array [[ts, lat, lon], ...]
                // Expand into individual entries, each inheriting all metadata
                return entry.pos.map(([ts, lat, lon]) => ({
                    id: entry.id,
                    ts: ts,
                    lat: lat,
                    lon: lon,
                    spd: entry.spd,
                    hdg: entry.hdg,
                    bat: entry.bat,
                    sig: entry.sig,
                    hr: entry.hr,
                    hac: entry.hac,
                    role: entry.role,
                    ver: entry.ver,
                    flg: entry.flg,
                    ast: entry.ast,
                    bdr: entry.bdr,
                    os: entry.os,
                    recv_ts: entry.recv_ts
                }));
            }
            // Old format: single position with lat/lon directly
            return [entry];
        }

        // Course display functions
        function clearCourseDisplay() {
            courseMarkers.forEach(m => map.removeLayer(m));
            courseMarkers = [];
            courseLines.forEach(l => map.removeLayer(l));
            courseLines = [];
        }

        function displayCourse(course) {
            clearCourseDisplay();
            if (!showCourse) return;

            const points = [];

            // Start marker
            if (course.start) {
                const marker = L.marker([course.start.lat, course.start.lon], {
                    icon: createStartIcon()
                }).addTo(map);
                marker.bindPopup('<strong>Start</strong>');
                courseMarkers.push(marker);
                points.push([course.start.lat, course.start.lon]);
            }

            // Mark markers
            if (course.marks) {
                course.marks.forEach((mark, idx) => {
                    const color = mark.color || '#f97316';
                    const label = mark.comment || null;
                    const marker = L.marker([mark.lat, mark.lon], {
                        icon: createMarkIcon(idx + 1, color, label)
                    }).addTo(map);

                    // Build popup with mark info
                    let popupContent = `<strong>Mark ${idx + 1}</strong>`;
                    if (mark.comment) {
                        popupContent += `<br><em>${mark.comment}</em>`;
                    }
                    marker.bindPopup(popupContent);

                    courseMarkers.push(marker);
                    points.push([mark.lat, mark.lon]);
                });
            }

            // Finish marker
            if (course.finish) {
                const marker = L.marker([course.finish.lat, course.finish.lon], {
                    icon: createFinishIcon()
                }).addTo(map);
                marker.bindPopup('<strong>Finish</strong>');
                courseMarkers.push(marker);
                points.push([course.finish.lat, course.finish.lon]);
            }

            // Course line
            if (points.length >= 2) {
                const line = L.polyline(points, {
                    color: '#ff6600',
                    weight: 3,
                    opacity: 0.7,
                    dashArray: '10, 5'
                }).addTo(map);
                courseLines.push(line);
            }
        }

        // Course marker icons
        function createStartIcon() {
            const svg = `
                <svg width="32" height="32" viewBox="-16 -16 32 32" xmlns="http://www.w3.org/2000/svg">
                    <circle cx="0" cy="0" r="12" fill="#22c55e" stroke="#166534" stroke-width="2"/>
                    <text x="0" y="5" text-anchor="middle" fill="white" font-size="12" font-weight="bold">S</text>
                </svg>
            `;
            return L.divIcon({
                html: svg,
                className: 'course-marker',
                iconSize: [32, 32],
                iconAnchor: [16, 16]
            });
        }

        // Darken a hex color by reducing RGB values ~30%
        function darkenColor(hex) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            const darken = (v) => Math.max(0, Math.floor(v * 0.7)).toString(16).padStart(2, '0');
            return `#${darken(r)}${darken(g)}${darken(b)}`;
        }

        function createMarkIcon(number, color = '#f97316', label = null) {
            const strokeColor = darkenColor(color);
            const svg = `
                <svg width="32" height="32" viewBox="-16 -16 32 32" xmlns="http://www.w3.org/2000/svg">
                    <circle cx="0" cy="0" r="12" fill="${color}" stroke="${strokeColor}" stroke-width="2"/>
                    <text x="0" y="5" text-anchor="middle" fill="white" font-size="11" font-weight="bold">${number}</text>
                </svg>
            `;
            const labelHtml = label ? `<div class="marker-label">${label}</div>` : '';
            return L.divIcon({
                html: `<div style="position:relative">${svg}${labelHtml}</div>`,
                className: 'course-marker',
                iconSize: [32, 32 + (label ? 20 : 0)],
                iconAnchor: [16, 16]
            });
        }

        function createFinishIcon() {
            const svg = `
                <svg width="32" height="32" viewBox="-16 -16 32 32" xmlns="http://www.w3.org/2000/svg">
                    <!-- Checkered flag pattern -->
                    <rect x="-12" y="-12" width="24" height="24" fill="white" stroke="#333" stroke-width="2" rx="3"/>
                    <rect x="-12" y="-12" width="6" height="6" fill="#333"/>
                    <rect x="0" y="-12" width="6" height="6" fill="#333"/>
                    <rect x="-6" y="-6" width="6" height="6" fill="#333"/>
                    <rect x="6" y="-6" width="6" height="6" fill="#333"/>
                    <rect x="-12" y="0" width="6" height="6" fill="#333"/>
                    <rect x="0" y="0" width="6" height="6" fill="#333"/>
                    <rect x="-6" y="6" width="6" height="6" fill="#333"/>
                    <rect x="6" y="6" width="6" height="6" fill="#333"/>
                </svg>
            `;
            return L.divIcon({
                html: svg,
                className: 'course-marker',
                iconSize: [32, 32],
                iconAnchor: [16, 16]
            });
        }

        async function loadCourse(courseFilename) {
            if (!courseFilename || courseFilename === currentCourseFile) {
                return;
            }
            try {
                const courseUrl = `${DATA_BASE}${courseFilename}`;
                const response = await fetch(courseUrl);
                if (response.ok) {
                    const courseData = await response.json();
                    currentCourseFile = courseFilename;
                    displayCourse(courseData);
                } else {
                    clearCourseDisplay();
                    currentCourseFile = null;
                }
            } catch (e) {
                console.log('Error loading course:', e);
                clearCourseDisplay();
                currentCourseFile = null;
            }
        }

        // Mobile drawer toggle
        const sidebarToggle = document.getElementById('sidebar-toggle');
        const sidebar = document.getElementById('sidebar');
        const sidebarOverlay = document.getElementById('sidebar-overlay');

        function toggleSidebar() {
            sidebar.classList.toggle('open');
            sidebarToggle.classList.toggle('open');
            sidebarOverlay.classList.toggle('visible');
        }

        function closeSidebarIfMobile() {
            if (window.innerWidth <= 768) {
                sidebar.classList.remove('open');
                sidebarToggle.classList.remove('open');
                sidebarOverlay.classList.remove('visible');
            }
        }

        sidebarToggle.addEventListener('click', toggleSidebar);
        sidebarOverlay.addEventListener('click', toggleSidebar);

        // Calculate distance between two points using Haversine formula (returns km)
        function haversineDistance(lat1, lon1, lat2, lon2) {
            const R = 6371; // Earth's radius in km
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                      Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                      Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }

        // Filter outliers from track positions using physics-based detection
        function filterOutliers(positions) {
            const SPEED_MARGIN_KNOTS = 20;
            const filtered = [];
            const outliers = [];

            for (let i = 0; i < positions.length; i++) {
                const pos = positions[i];

                if (i === 0) {
                    filtered.push(pos);
                    continue;
                }

                const prev = positions[i - 1];
                const timeDelta = pos.ts - prev.ts;

                if (timeDelta > 0) {
                    const distanceKm = haversineDistance(prev.lat, prev.lon, pos.lat, pos.lon);
                    const distanceM = distanceKm * 1000;
                    const impliedSpeedMs = distanceM / timeDelta;
                    const impliedSpeedKnots = impliedSpeedMs * 1.94384;
                    const prevSpeedKnots = (prev.spd || 0);  // spd is already in knots
                    const currSpeedKnots = (pos.spd || 0);   // spd is already in knots
                    const maxAllowed = Math.max(prevSpeedKnots, currSpeedKnots) + SPEED_MARGIN_KNOTS;

                    if (impliedSpeedKnots > maxAllowed) {
                        outliers.push(pos);
                        continue;
                    }
                }

                filtered.push(pos);
            }

            return { filtered, outliers };
        }

        // Load user overrides (name mappings)
        async function loadUserOverrides() {
            try {
                const response = await fetch(`${DATA_BASE}users.json?` + Date.now());
                if (response.ok) {
                    const data = await response.json();
                    userOverrides = data.users || {};
                }
            } catch (e) {
                console.log('No users.json found');
            }
        }

        // Get display name for a user ID
        function getDisplayName(userId) {
            if (userOverrides[userId] && userOverrides[userId].name) {
                return userOverrides[userId].name;
            }
            return userId;
        }

        // Load user overrides on startup
        loadUserOverrides();

        // User colors
        const userColors = [
            '#e74c3c', '#3498db', '#2ecc71', '#9b59b6', '#f39c12',
            '#1abc9c', '#e91e63', '#00bcd4', '#ff5722', '#795548'
        ];

        // Speed to color (0-15+ knots)
        function speedToColor(speedKnots) {
            const knots = speedKnots;  // spd is already in knots
            const ratio = Math.min(knots / 15, 1);

            if (ratio < 0.33) {
                // Blue to green
                const t = ratio / 0.33;
                return interpolateColor('#3498db', '#2ecc71', t);
            } else if (ratio < 0.66) {
                // Green to yellow
                const t = (ratio - 0.33) / 0.33;
                return interpolateColor('#2ecc71', '#f1c40f', t);
            } else {
                // Yellow to red
                const t = (ratio - 0.66) / 0.34;
                return interpolateColor('#f1c40f', '#e74c3c', t);
            }
        }

        function interpolateColor(c1, c2, t) {
            const r1 = parseInt(c1.slice(1,3), 16);
            const g1 = parseInt(c1.slice(3,5), 16);
            const b1 = parseInt(c1.slice(5,7), 16);
            const r2 = parseInt(c2.slice(1,3), 16);
            const g2 = parseInt(c2.slice(3,5), 16);
            const b2 = parseInt(c2.slice(5,7), 16);

            const r = Math.round(r1 + (r2 - r1) * t);
            const g = Math.round(g1 + (g2 - g1) * t);
            const b = Math.round(b1 + (b2 - b1) * t);

            return `rgb(${r},${g},${b})`;
        }

        // Set default date to today in event timezone
        document.getElementById('date-picker').value = getTodayInEventTz();

        // Load summary for a date (phase 1)
        async function loadSummary() {
            const dateStr = document.getElementById('date-picker').value;
            if (!dateStr) return;

            document.getElementById('loading').style.display = 'block';
            document.getElementById('status').textContent = 'Loading summary...';

            const dateParts = dateStr.split('-');
            const logDate = `${dateParts[0]}_${dateParts[1]}_${dateParts[2]}`;

            // Clear previous state
            currentSummary = null;
            currentLogFile = null;
            allData = [];
            userData = {};
            selectedUsers = new Set();
            document.getElementById('user-list').innerHTML = '<p style="color:#666">Select a log to see users</p>';

            try {
                // Try to fetch summary file
                const summaryUrl = `${DATA_BASE}logs/${logDate}_summary.json?${Date.now()}`;
                const response = await fetch(summaryUrl);

                if (response.ok) {
                    currentSummary = await response.json();
                    updateRaceList();
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('status').textContent = `Found ${currentSummary.logs.length} log(s) for this date`;
                } else {
                    // No summary file - fall back to direct loading
                    document.getElementById('race-list').innerHTML = '<p style="color:#666">No summary available - loading all data...</p>';
                    await loadTracksLegacy(logDate);
                }
            } catch (e) {
                console.error('Error loading summary:', e);
                document.getElementById('loading').style.display = 'none';
                document.getElementById('status').textContent = 'Error loading data';
                document.getElementById('race-list').innerHTML = '<p style="color:#666">Error loading logs</p>';
            }
        }

        // Update race list UI
        function updateRaceList() {
            const container = document.getElementById('race-list');
            container.innerHTML = '';

            if (!currentSummary || !currentSummary.logs || currentSummary.logs.length === 0) {
                container.innerHTML = '<p style="color:#666">No logs found</p>';
                return;
            }

            // Logs are already sorted by start_ts descending in the summary
            currentSummary.logs.forEach((log, index) => {
                const div = document.createElement('div');
                div.className = 'race-item';
                div.dataset.index = index;

                const startTime = formatTimeInTz(log.start_ts);
                const endTime = formatTimeInTz(log.end_ts);
                const duration = Math.round((log.end_ts - log.start_ts) / 60);
                const sailorCount = Object.keys(log.sailors).length;

                div.innerHTML = `
                    <div class="race-time">Log ${currentSummary.logs.length - index}: ${startTime} - ${endTime}</div>
                    <div class="race-stats">
                        Duration: ${duration} min | ${sailorCount} sailors | ${log.point_count.toLocaleString()} points
                    </div>
                `;

                div.addEventListener('click', () => {
                    // Clear previous selection
                    container.querySelectorAll('.race-item').forEach(el => el.classList.remove('selected'));
                    div.classList.add('selected');
                    loadRace(log);
                    closeSidebarIfMobile();
                });

                container.appendChild(div);
            });
        }

        // Helper to fetch and decompress a file (tries .gz first, falls back to uncompressed)
        async function fetchLogFile(url) {
            const canDecompress = typeof DecompressionStream !== 'undefined';

            // Try compressed version first
            if (canDecompress) {
                try {
                    const gzUrl = url + '.gz';
                    const response = await fetch(gzUrl);
                    if (response.ok) {
                        const ds = new DecompressionStream('gzip');
                        const decompressed = response.body.pipeThrough(ds);
                        return await new Response(decompressed).text();
                    }
                } catch (e) {
                    // Fall through to uncompressed
                }
            }

            // Try uncompressed
            const response = await fetch(url);
            if (response.ok) {
                return await response.text();
            }
            return null;
        }

        // Load a specific race/log file (phase 2)
        async function loadRace(logEntry) {
            document.getElementById('loading').style.display = 'block';
            document.getElementById('status').textContent = `Loading ${logEntry.file}...`;

            currentLogFile = logEntry.file;
            allData = [];
            userData = {};
            selectedUsers = new Set();

            try {
                const text = await fetchLogFile(`${DATA_BASE}logs/${logEntry.file}`);
                if (!text) throw new Error('Failed to load');

                const lines = text.trim().split('\n');

                for (const line of lines) {
                    try {
                        const entry = JSON.parse(line);
                        // Expand pos array entries (new format) or use directly (old format)
                        const expanded = expandEntry(entry);
                        for (const e of expanded) {
                            if (e.lat && e.lon && e.ts) {
                                allData.push(e);
                            }
                        }
                    } catch (e) {}
                }

                if (allData.length === 0) {
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('status').textContent = 'No data found in this log';
                    return;
                }

                // Sort by timestamp
                allData.sort((a, b) => a.ts - b.ts);

                // Group by user
                for (const entry of allData) {
                    const id = entry.id;
                    if (!userData[id]) {
                        userData[id] = [];
                    }
                    userData[id].push(entry);
                }

                // Calculate time range
                minTime = allData[0].ts;
                maxTime = allData[allData.length - 1].ts;
                rangeStartTime = minTime;
                rangeEndTime = maxTime;

                document.getElementById('start-slider').value = 0;
                document.getElementById('end-slider').value = 100;
                updateSliderRange();
                updateTimeDisplay();

                // Update user list
                updateUserList();

                // Draw tracks
                drawTracks();

                // Fit map to data
                fitMapToData();

                // Load course if available in log entry
                if (logEntry.course) {
                    await loadCourse(logEntry.course);
                } else {
                    clearCourseDisplay();
                    currentCourseFile = null;
                }

                document.getElementById('loading').style.display = 'none';
                document.getElementById('status').textContent = `Loaded ${allData.length} points from ${Object.keys(userData).length} users`;

            } catch (e) {
                console.error('Error loading log:', e);
                document.getElementById('loading').style.display = 'none';
                document.getElementById('status').textContent = 'Failed to load log';
            }
        }

        // Legacy function for when no summary exists
        async function loadTracksLegacy(logDate) {
            allData = [];
            userData = {};

            // Try to load main file and rotated files
            const baseUrl = `${DATA_BASE}logs/${logDate}.jsonl`;
            const filesToTry = [baseUrl];

            // Try numbered rotations
            for (let i = 1; i <= 10; i++) {
                filesToTry.push(`${baseUrl}.${i}`);
            }

            for (const file of filesToTry) {
                try {
                    const text = await fetchLogFile(file);
                    if (!text) continue;

                    const lines = text.trim().split('\n');

                    for (const line of lines) {
                        try {
                            const entry = JSON.parse(line);
                            // Expand pos array entries (new format) or use directly (old format)
                            const expanded = expandEntry(entry);
                            for (const e of expanded) {
                                if (e.lat && e.lon && e.ts) {
                                    allData.push(e);
                                }
                            }
                        } catch (e) {}
                    }

                    document.getElementById('status').textContent = `Loaded ${file}...`;
                } catch (e) {}
            }

            if (allData.length === 0) {
                document.getElementById('loading').style.display = 'none';
                document.getElementById('status').textContent = 'No data found for this date';
                document.getElementById('race-list').innerHTML = '<p style="color:#666">No logs found</p>';
                return;
            }

            // Sort by timestamp
            allData.sort((a, b) => a.ts - b.ts);

            // Group by user
            for (const entry of allData) {
                const id = entry.id;
                if (!userData[id]) {
                    userData[id] = [];
                }
                userData[id].push(entry);
            }

            // Calculate time range
            minTime = allData[0].ts;
            maxTime = allData[allData.length - 1].ts;
            rangeStartTime = minTime;
            rangeEndTime = maxTime;

            document.getElementById('start-slider').value = 0;
            document.getElementById('end-slider').value = 100;
            updateSliderRange();
            updateTimeDisplay();

            // Update user list
            updateUserList();

            // Show a single "all data" entry in log list
            document.getElementById('race-list').innerHTML = `
                <div class="race-item selected">
                    <div class="race-time">All Data (Legacy Mode)</div>
                    <div class="race-stats">
                        ${Object.keys(userData).length} sailors | ${allData.length.toLocaleString()} points
                    </div>
                </div>
            `;

            // Start with no users selected by default
            selectedUsers = new Set();

            // Draw tracks
            drawTracks();

            // Fit map to data
            fitMapToData();

            // Try to load current course (legacy mode has no course info in summary)
            await loadCourse('course.json');

            document.getElementById('loading').style.display = 'none';
            document.getElementById('status').textContent = `Loaded ${allData.length} points from ${Object.keys(userData).length} users`;
        }

        function updateUserList() {
            const container = document.getElementById('user-list');
            container.innerHTML = '';

            let colorIdx = 0;
            for (const [userId, entries] of Object.entries(userData)) {
                const speeds = entries.map(e => e.spd || 0);
                const maxSpeed = Math.max(...speeds);
                const avgSpeed = speeds.reduce((a,b) => a+b, 0) / speeds.length;
                const points = entries.length;

                const div = document.createElement('div');
                div.className = 'user-item';
                div.dataset.userId = userId;

                const color = userColors[colorIdx % userColors.length];
                colorIdx++;

                div.innerHTML = `
                    <div class="user-color" style="background:${color}"></div>
                    <div class="user-info">
                        <div class="user-name">${getDisplayName(userId)}</div>
                        <div class="user-stats">
                            ${points} pts | Max: ${maxSpeed.toFixed(1)} kts | Avg: ${avgSpeed.toFixed(1)} kts
                        </div>
                    </div>
                `;

                div.addEventListener('click', () => toggleUser(userId, div));
                div.addEventListener('dblclick', (e) => {
                    e.stopPropagation();
                    zoomToUser(userId);
                });
                container.appendChild(div);
            }
        }

        function toggleUser(userId, element) {
            if (selectedUsers.has(userId)) {
                selectedUsers.delete(userId);
                element.classList.remove('selected');
            } else {
                selectedUsers.add(userId);
                element.classList.add('selected');
            }
            resetPlaybackToSelection();

            // Auto-fit map to show all selected tracks
            if (selectedUsers.size > 0) {
                fitMapToData();
            }
        }

        function resetPlaybackToSelection() {
            // Stop any active playback
            if (playbackInterval) {
                clearInterval(playbackInterval);
                playbackInterval = null;
                document.getElementById('play-btn').textContent = '‚ñ∂ Play';
            }

            updateTimeDisplay();
            drawTracks();
            drawSpeedGraph();
            drawSpeedGraph();
            drawBatteryGraph();
            drawSignalGraph();
            drawLatencyGraph();
            drawHeartRateGraph();
            drawAccuracyGraph();
            drawDistanceGraph();
        }

        function updateSliderRange() {
            const startSlider = document.getElementById('start-slider');
            const endSlider = document.getElementById('end-slider');
            const sliderRange = document.getElementById('slider-range');

            const startVal = parseFloat(startSlider.value);
            const endVal = parseFloat(endSlider.value);

            // Update the visual range indicator
            sliderRange.style.left = startVal + '%';
            sliderRange.style.width = (endVal - startVal) + '%';

            // Update times from slider values
            rangeStartTime = minTime + (maxTime - minTime) * (startVal / 100);
            rangeEndTime = minTime + (maxTime - minTime) * (endVal / 100);

            // Update the labels
            document.getElementById('label-start').textContent = formatTimeInTz(minTime);
            document.getElementById('label-end').textContent = formatTimeInTz(maxTime);
        }

        function updateTimeDisplay() {
            const durationSec = rangeEndTime - rangeStartTime;
            const durationMin = Math.floor(durationSec / 60);
            const durationRemSec = Math.floor(durationSec % 60);
            const durationStr = `${durationMin}:${String(durationRemSec).padStart(2, '0')}`;

            document.getElementById('time-display').innerHTML =
                `<span style="color:#2ecc71">Start: ${formatTimeInTz(rangeStartTime)}</span> &nbsp;|&nbsp;` +
                `<span style="color:#e74c3c">End: ${formatTimeInTz(rangeEndTime)}</span> &nbsp;|&nbsp;` +
                `Duration: ${durationStr}`;
        }

        // Redraw all tracks and graphs (expensive operation)
        function redrawAll() {
            drawTracks();
            drawSpeedGraph();
            drawBatteryGraph();
            drawSignalGraph();
            drawLatencyGraph();
            drawHeartRateGraph();
            drawAccuracyGraph();
            drawDistanceGraph();
        }

        // Debounced version - waits for slider to stop moving before redrawing
        function debouncedRedrawAll(delay = 500) {
            if (sliderDebounceTimer) {
                clearTimeout(sliderDebounceTimer);
            }
            sliderDebounceTimer = setTimeout(() => {
                redrawAll();
                sliderDebounceTimer = null;
            }, delay);
        }

        function drawTracks() {
            // Clear existing layers
            for (const layer of Object.values(trackLayers)) {
                map.removeLayer(layer);
            }
            for (const layer of Object.values(markerLayers)) {
                map.removeLayer(layer);
            }
            for (const layer of Object.values(pointLayers)) {
                map.removeLayer(layer);
            }
            for (const layer of Object.values(outlierLayers)) {
                map.removeLayer(layer);
            }
            trackLayers = {};
            markerLayers = {};
            pointLayers = {};
            outlierLayers = {};

            const useSpeedColor = document.getElementById('speed-color').checked;
            const showMarkers = document.getElementById('show-markers').checked;
            const doFilterOutliers = document.getElementById('filter-outliers').checked;
            const showOutliersMarkers = document.getElementById('show-outliers').checked;

            let colorIdx = 0;
            for (const [userId, entries] of Object.entries(userData)) {
                if (!selectedUsers.has(userId)) {
                    colorIdx++;
                    continue;
                }

                const userColor = userColors[colorIdx % userColors.length];
                colorIdx++;

                // Filter entries within the selected time range
                let timeFiltered = entries.filter(e => e.ts >= rangeStartTime && e.ts <= rangeEndTime);
                if (timeFiltered.length < 2) continue;

                // Apply outlier filtering if enabled
                let filtered = timeFiltered;
                let outliers = [];
                if (doFilterOutliers) {
                    const result = filterOutliers(timeFiltered);
                    filtered = result.filtered;
                    outliers = result.outliers;
                }

                if (filtered.length < 2) continue;

                // Draw outlier markers if enabled
                if (showOutliersMarkers && outliers.length > 0) {
                    const outlierGroup = L.layerGroup();
                    for (const point of outliers) {
                        const time = formatTimeInTz(point.ts);
                        const speedKnots = (point.spd || 0).toFixed(1);

                        const marker = L.circleMarker([point.lat, point.lon], {
                            radius: 6,
                            fillColor: '#ff0000',
                            color: '#ff0000',
                            fillOpacity: 0.7,
                            weight: 2
                        });

                        let tooltipText = `Outlier: ${time}<br>Speed: ${speedKnots} kn`;
                        if (point.ast) {
                            tooltipText += '<br><span style="color:#ff0000">üÜò ASSIST REQUESTED</span>';
                            // Add larger assist circle
                            const assistMarker = L.circleMarker([point.lat, point.lon], {
                                radius: 12,
                                fillColor: 'transparent',
                                color: '#ff0000',
                                weight: 3,
                                fillOpacity: 0,
                                opacity: 0.9
                            });
                            outlierGroup.addLayer(assistMarker);
                        }
                        marker.bindTooltip(tooltipText, { permanent: false });

                        outlierGroup.addLayer(marker);
                    }
                    outlierGroup.addTo(map);
                    outlierLayers[userId] = outlierGroup;
                }

                if (useSpeedColor) {
                    // Draw segments colored by speed
                    const layerGroup = L.layerGroup();

                    for (let i = 1; i < filtered.length; i++) {
                        const prev = filtered[i-1];
                        const curr = filtered[i];
                        const color = speedToColor(curr.spd || 0);

                        const line = L.polyline(
                            [[prev.lat, prev.lon], [curr.lat, curr.lon]],
                            { color: color, weight: 3, opacity: 0.8 }
                        );
                        layerGroup.addLayer(line);
                    }

                    layerGroup.addTo(map);
                    trackLayers[userId] = layerGroup;
                } else {
                    // Draw single color track
                    const coords = filtered.map(e => [e.lat, e.lon]);
                    const polyline = L.polyline(coords, {
                        color: userColor,
                        weight: 3,
                        opacity: 0.8
                    }).addTo(map);
                    trackLayers[userId] = polyline;
                }

                // Add interactive point markers for each track point
                const pointGroup = L.layerGroup();
                for (const point of filtered) {
                    const speedKnots = (point.spd || 0).toFixed(1);
                    const time = formatTimeInTz(point.ts);
                    const color = useSpeedColor ? speedToColor(point.spd || 0) : userColor;

                    const pointMarker = L.circleMarker([point.lat, point.lon], {
                        radius: 4,
                        fillColor: color,
                        color: color,
                        weight: 1,
                        fillOpacity: 0.6,
                        opacity: 0.6
                    });

                    // Add red circle around points where assist was requested
                    if (point.ast) {
                        const assistMarker = L.circleMarker([point.lat, point.lon], {
                            radius: 10,
                            fillColor: 'transparent',
                            color: '#ff0000',
                            weight: 2,
                            fillOpacity: 0,
                            opacity: 0.9
                        });
                        pointGroup.addLayer(assistMarker);
                    }

                    // Build warnings for battery issues and assist
                    let warnings = '';
                    if (point.ast) {
                        warnings += '<br><span style="color:#ff0000">üÜò ASSIST REQUESTED</span>';
                    }
                    if (point.flg) {
                        if (point.flg.ps) {
                            warnings += '<br><span style="color:#e74c3c">‚ö†Ô∏è Battery Saver ON</span>';
                        }
                        if (point.flg.bo === false) {
                            warnings += '<br><span style="color:#f39c12">‚ö†Ô∏è Battery Optimization ON</span>';
                        }
                    }

                    let hrText = '';
                    if (point.hr !== undefined && point.hr > 0) {
                        hrText = `<br>Heart Rate: <span style="color:#e91e63">${point.hr} bpm</span>`;
                    }

                    let hacText = '';
                    if (point.hac !== undefined) {
                        hacText = `<br>Accuracy: ${point.hac.toFixed(1)}m`;
                    }

                    pointMarker.bindTooltip(`
                        <b>${getDisplayName(userId)}</b><br>
                        Time: ${time}<br>
                        Speed: ${speedKnots} kts<br>
                        Heading: ${point.hdg || 0}¬∞<br>
                        Signal: ${point.sig || '?'}<br>
                        Battery: ${point.bat || '?'}%${hacText}${hrText}${warnings}
                    `, { sticky: true });

                    pointGroup.addLayer(pointMarker);
                }
                pointGroup.addTo(map);
                pointLayers[userId] = pointGroup;

                // Add current position marker
                if (showMarkers && filtered.length > 0) {
                    const last = filtered[filtered.length - 1];
                    const speedKnots = (last.spd || 0).toFixed(1);

                    // Build warnings for battery issues
                    let markerWarnings = '';
                    if (last.flg) {
                        if (last.flg.ps) {
                            markerWarnings += '<br><span style="color:#e74c3c">‚ö†Ô∏è Battery Saver ON</span>';
                        }
                        if (last.flg.bo === false) {
                            markerWarnings += '<br><span style="color:#f39c12">‚ö†Ô∏è Battery Optimization ON</span>';
                        }
                    }

                    let markerHrText = '';
                    if (last.hr !== undefined && last.hr > 0) {
                        markerHrText = `<br>Heart Rate: <span style="color:#e91e63">${last.hr} bpm</span>`;
                    }

                    let markerHacText = '';
                    if (last.hac !== undefined) {
                        markerHacText = `<br>Accuracy: ${last.hac.toFixed(1)}m`;
                    }

                    const marker = L.circleMarker([last.lat, last.lon], {
                        radius: 8,
                        fillColor: userColor,
                        color: '#fff',
                        weight: 2,
                        fillOpacity: 1
                    }).bindPopup(`
                        <b>${getDisplayName(userId)}</b><br>
                        Speed: ${speedKnots} kts<br>
                        Heading: ${last.hdg || 0}¬∞<br>
                        Battery: ${last.bat || '?'}%${markerHacText}${markerHrText}${markerWarnings}
                    `).addTo(map);
                    markerLayers[userId] = marker;
                }
            }
        }

        function fitMapToData() {
            const allCoords = [];
            for (const userId of selectedUsers) {
                if (userData[userId]) {
                    for (const entry of userData[userId]) {
                        allCoords.push([entry.lat, entry.lon]);
                    }
                }
            }
            if (allCoords.length > 0) {
                map.fitBounds(allCoords, { padding: [50, 50] });
            }
        }

        function drawSpeedGraph() {
            // Only draw if speed graph is visible
            if (!document.getElementById('show-speed-graph').checked) return;

            const canvas = document.getElementById('speed-graph');
            const ctx = canvas.getContext('2d');

            // Set canvas size to match display size (for sharp rendering)
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * window.devicePixelRatio;
            canvas.height = rect.height * window.devicePixelRatio;
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);

            const width = rect.width;
            const height = rect.height;

            // Clear canvas
            ctx.clearRect(0, 0, width, height);

            // Update time axis labels
            document.getElementById('speed-time-start').textContent = formatTimeShortInTz(rangeStartTime);
            document.getElementById('speed-time-end').textContent = formatTimeShortInTz(rangeEndTime);

            // Calculate speed range for Y axis scaling (only from visible time range)
            let maxSpeed = 0;
            let minSpeed = Infinity;
            let hasSpeedData = false;
            for (const [userId, entries] of Object.entries(userData)) {
                if (!selectedUsers.has(userId)) continue;
                for (const entry of entries) {
                    if (entry.ts < rangeStartTime || entry.ts > rangeEndTime) continue;
                    if (entry.spd !== undefined && entry.spd !== null && entry.spd >= 0) {
                        maxSpeed = Math.max(maxSpeed, entry.spd);
                        minSpeed = Math.min(minSpeed, entry.spd);
                        hasSpeedData = true;
                    }
                }
            }

            // Set sensible defaults and add padding
            if (!hasSpeedData || maxSpeed === 0) {
                maxSpeed = 20;
                minSpeed = 0;
            } else {
                // Add 10% padding above max
                maxSpeed = Math.ceil((maxSpeed * 1.1) / 2) * 2;  // Round to nearest 2 knots
                // Round min down, but keep at 0 for speed (negative speed doesn't make sense)
                minSpeed = 0;
                // Ensure at least 5 knot range for readability
                if (maxSpeed - minSpeed < 5) {
                    maxSpeed = minSpeed + 5;
                }
            }
            const speedRange = maxSpeed - minSpeed;

            // Update Y axis labels
            const yLabels = document.getElementById('speed-y-labels');
            yLabels.innerHTML = `
                <span>${maxSpeed}</span>
                <span>${(minSpeed + speedRange * 0.75).toFixed(0)}</span>
                <span>${(minSpeed + speedRange * 0.5).toFixed(0)}</span>
                <span>${(minSpeed + speedRange * 0.25).toFixed(0)}</span>
                <span>${minSpeed}</span>
            `;

            // Draw grid lines
            ctx.strokeStyle = '#34495e';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 4; i++) {
                const y = (i / 4) * height;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }

            // No users selected
            if (selectedUsers.size === 0) {
                ctx.fillStyle = '#7f8c8d';
                ctx.font = '14px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Select a user to see speed graph', width / 2, height / 2);
                return;
            }

            // Draw speed line for each selected user
            let colorIdx = 0;
            for (const [userId, entries] of Object.entries(userData)) {
                const userColor = userColors[colorIdx % userColors.length];
                colorIdx++;

                if (!selectedUsers.has(userId)) continue;

                // Filter entries by time range
                const filtered = entries.filter(e => e.ts >= rangeStartTime && e.ts <= rangeEndTime);
                if (filtered.length < 2) continue;

                // Draw the speed line
                ctx.strokeStyle = userColor;
                ctx.lineWidth = 2;
                ctx.beginPath();

                let started = false;
                for (const entry of filtered) {
                    if (entry.spd === undefined || entry.spd === null) continue;

                    const x = ((entry.ts - rangeStartTime) / (rangeEndTime - rangeStartTime)) * width;
                    const y = height - ((entry.spd - minSpeed) / speedRange) * height;

                    if (!started) {
                        ctx.moveTo(x, y);
                        started = true;
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();

                // Draw user label at the end of the line
                if (filtered.length > 0) {
                    const last = filtered[filtered.length - 1];
                    if (last.spd !== undefined && last.spd !== null) {
                        const x = ((last.ts - rangeStartTime) / (rangeEndTime - rangeStartTime)) * width;
                        const y = height - ((last.spd - minSpeed) / speedRange) * height;
                        ctx.fillStyle = userColor;
                        ctx.font = 'bold 10px sans-serif';
                        ctx.textAlign = 'right';
                        ctx.fillText(`${getDisplayName(userId)}: ${last.spd.toFixed(1)} kts`, Math.min(x, width - 5), y - 5);
                    }
                }
            }
        }

        function drawBatteryGraph() {
            // Only draw if battery graph is visible
            if (!document.getElementById('show-battery-graph').checked) return;

            const canvas = document.getElementById('battery-graph');
            const ctx = canvas.getContext('2d');

            // Set canvas size to match display size (for sharp rendering)
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * window.devicePixelRatio;
            canvas.height = rect.height * window.devicePixelRatio;
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);

            const width = rect.width;
            const height = rect.height;

            // Clear canvas
            ctx.clearRect(0, 0, width, height);

            // Update time axis labels
            document.getElementById('battery-time-start').textContent = formatTimeShortInTz(rangeStartTime);
            document.getElementById('battery-time-end').textContent = formatTimeShortInTz(rangeEndTime);

            // Calculate battery range for Y axis scaling (only from visible time range)
            let maxBat = 0;
            let minBat = 100;
            let hasBatData = false;
            for (const [userId, entries] of Object.entries(userData)) {
                if (!selectedUsers.has(userId)) continue;
                for (const entry of entries) {
                    if (entry.ts < rangeStartTime || entry.ts > rangeEndTime) continue;
                    if (entry.bat !== undefined && entry.bat !== null && entry.bat >= 0) {
                        maxBat = Math.max(maxBat, entry.bat);
                        minBat = Math.min(minBat, entry.bat);
                        hasBatData = true;
                    }
                }
            }

            // Set sensible defaults and add padding
            if (!hasBatData) {
                maxBat = 100;
                minBat = 0;
            } else {
                // Keep max at 100 if close, otherwise add padding
                maxBat = maxBat > 95 ? 100 : Math.ceil((maxBat + 5) / 5) * 5;
                // Round min down to nearest 5%
                minBat = Math.floor(minBat / 5) * 5;
                // Ensure at least 10% range for readability
                if (maxBat - minBat < 10) {
                    if (maxBat < 100) maxBat = Math.min(100, minBat + 10);
                    else minBat = Math.max(0, maxBat - 10);
                }
            }
            // Ensure batRange is never 0 (prevents division by zero)
            const batRange = Math.max(10, maxBat - minBat);

            // Update Y axis labels
            const yLabels = document.getElementById('battery-y-labels');
            yLabels.innerHTML = `
                <span>${maxBat}</span>
                <span>${Math.round(minBat + batRange * 0.75)}</span>
                <span>${Math.round(minBat + batRange * 0.5)}</span>
                <span>${Math.round(minBat + batRange * 0.25)}</span>
                <span>${minBat}</span>
            `;

            // Draw grid lines
            ctx.strokeStyle = '#34495e';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 4; i++) {
                const y = (i / 4) * height;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }

            // No users selected
            if (selectedUsers.size === 0) {
                ctx.fillStyle = '#7f8c8d';
                ctx.font = '14px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Select a user to see battery graph', width / 2, height / 2);
                return;
            }

            // No battery data available
            if (!hasBatData) {
                ctx.fillStyle = '#7f8c8d';
                ctx.font = '14px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('No battery data available', width / 2, height / 2);
                return;
            }

            // Draw battery line for each selected user
            let colorIdx = 0;
            for (const [userId, entries] of Object.entries(userData)) {
                const userColor = userColors[colorIdx % userColors.length];
                colorIdx++;

                if (!selectedUsers.has(userId)) continue;

                // Filter entries by time range
                const filtered = entries.filter(e => e.ts >= rangeStartTime && e.ts <= rangeEndTime);
                if (filtered.length < 2) continue;

                // Draw the battery line
                ctx.strokeStyle = userColor;
                ctx.lineWidth = 2;
                ctx.beginPath();

                let started = false;
                for (const entry of filtered) {
                    if (entry.bat === undefined || entry.bat === null || entry.bat < 0) continue;

                    const x = ((entry.ts - rangeStartTime) / (rangeEndTime - rangeStartTime)) * width;
                    const y = height - ((entry.bat - minBat) / batRange) * height;

                    if (!started) {
                        ctx.moveTo(x, y);
                        started = true;
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();

                // Draw user label at the end of the line
                if (filtered.length > 0) {
                    const last = filtered[filtered.length - 1];
                    if (last.bat !== undefined && last.bat !== null && last.bat >= 0) {
                        const x = ((last.ts - rangeStartTime) / (rangeEndTime - rangeStartTime)) * width;
                        const y = height - ((last.bat - minBat) / batRange) * height;
                        ctx.fillStyle = userColor;
                        ctx.font = 'bold 10px sans-serif';
                        ctx.textAlign = 'right';
                        ctx.fillText(`${getDisplayName(userId)}: ${last.bat}%`, Math.min(x, width - 5), y - 5);
                    }
                }
            }
        }

        function drawSignalGraph() {
            // Only draw if signal graph is visible
            if (!document.getElementById('show-signal-graph').checked) return;

            const canvas = document.getElementById('signal-graph');
            const ctx = canvas.getContext('2d');

            // Set canvas size to match display size (for sharp rendering)
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * window.devicePixelRatio;
            canvas.height = rect.height * window.devicePixelRatio;
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);

            const width = rect.width;
            const height = rect.height;

            // Clear canvas
            ctx.clearRect(0, 0, width, height);

            // Update time axis labels
            document.getElementById('signal-time-start').textContent = formatTimeShortInTz(rangeStartTime);
            document.getElementById('signal-time-end').textContent = formatTimeShortInTz(rangeEndTime);

            // Draw grid lines
            ctx.strokeStyle = '#34495e';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 4; i++) {
                const y = (i / 4) * height;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }

            // No users selected
            if (selectedUsers.size === 0) {
                ctx.fillStyle = '#7f8c8d';
                ctx.font = '14px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Select a user to see signal graph', width / 2, height / 2);
                return;
            }

            // Draw signal line for each selected user
            let colorIdx = 0;
            for (const [userId, entries] of Object.entries(userData)) {
                const userColor = userColors[colorIdx % userColors.length];
                colorIdx++;

                if (!selectedUsers.has(userId)) continue;

                // Filter entries by time range
                const filtered = entries.filter(e => e.ts >= rangeStartTime && e.ts <= rangeEndTime);
                if (filtered.length < 2) continue;

                // Draw the signal line
                ctx.strokeStyle = userColor;
                ctx.lineWidth = 2;
                ctx.beginPath();

                let started = false;
                for (const entry of filtered) {
                    if (entry.sig === undefined || entry.sig === null) continue;

                    const x = ((entry.ts - rangeStartTime) / (rangeEndTime - rangeStartTime)) * width;
                    const y = height - (entry.sig / 4) * height;

                    if (!started) {
                        ctx.moveTo(x, y);
                        started = true;
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();

                // Draw user label at the end of the line
                if (filtered.length > 0) {
                    const last = filtered[filtered.length - 1];
                    if (last.sig !== undefined && last.sig !== null) {
                        const x = ((last.ts - rangeStartTime) / (rangeEndTime - rangeStartTime)) * width;
                        const y = height - (last.sig / 4) * height;
                        const sigBars = '‚ñÇ‚ñÑ‚ñÜ‚ñà'.slice(0, Math.max(1, Math.min(4, last.sig)));
                        ctx.fillStyle = userColor;
                        ctx.font = 'bold 10px sans-serif';
                        ctx.textAlign = 'right';
                        ctx.fillText(`${getDisplayName(userId)}: ${sigBars}`, Math.min(x, width - 5), y - 5);
                    }
                }
            }
        }

        // Calculate network latency for an entry
        // For 1Hz batched positions, use batch_ts (when batch was sent) instead of ts
        function getNetworkLatency(entry) {
            if (entry.recv_ts === undefined) return null;
            // Use batch_ts if available (for batched 1Hz positions), otherwise use ts
            const sendTime = entry.batch_ts !== undefined ? entry.batch_ts : entry.ts;
            return entry.recv_ts - sendTime;
        }

        function drawLatencyGraph() {
            // Only draw if latency graph is visible
            if (!document.getElementById('show-latency-graph').checked) return;

            const canvas = document.getElementById('latency-graph');
            const ctx = canvas.getContext('2d');

            // Set canvas size to match display size (for sharp rendering)
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * window.devicePixelRatio;
            canvas.height = rect.height * window.devicePixelRatio;
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);

            const width = rect.width;
            const height = rect.height;

            // Clear canvas
            ctx.clearRect(0, 0, width, height);

            // Update time axis labels
            document.getElementById('latency-time-start').textContent = formatTimeShortInTz(rangeStartTime);
            document.getElementById('latency-time-end').textContent = formatTimeShortInTz(rangeEndTime);

            // Calculate max latency for Y axis scaling (only from visible time range)
            let maxLatency = 0;
            let hasLatencyValues = false;
            for (const [userId, entries] of Object.entries(userData)) {
                if (!selectedUsers.has(userId)) continue;
                for (const entry of entries) {
                    if (entry.ts < rangeStartTime || entry.ts > rangeEndTime) continue;
                    const latency = getNetworkLatency(entry);
                    if (latency !== null && Math.abs(latency) < 300) {
                        maxLatency = Math.max(maxLatency, Math.abs(latency));
                        hasLatencyValues = true;
                    }
                }
            }

            // Set sensible defaults and add padding
            if (!hasLatencyValues || maxLatency === 0) {
                maxLatency = 10;
            } else {
                // Add 10% padding above max
                maxLatency = maxLatency * 1.1;
                // Round to nice number based on magnitude
                if (maxLatency < 2) {
                    maxLatency = Math.ceil(maxLatency * 4) / 4;  // Round to 0.25s
                    if (maxLatency < 0.5) maxLatency = 0.5;
                } else if (maxLatency < 5) {
                    maxLatency = Math.ceil(maxLatency);  // Round to 1s
                } else {
                    maxLatency = Math.ceil(maxLatency / 2) * 2;  // Round to 2s
                }
            }

            // Update Y axis labels
            const yLabels = document.getElementById('latency-y-labels');
            yLabels.innerHTML = `
                <span>${maxLatency.toFixed(maxLatency < 2 ? 2 : 0)}</span>
                <span>${(maxLatency * 0.75).toFixed(maxLatency < 2 ? 2 : 1)}</span>
                <span>${(maxLatency * 0.5).toFixed(maxLatency < 2 ? 2 : 1)}</span>
                <span>${(maxLatency * 0.25).toFixed(maxLatency < 2 ? 2 : 1)}</span>
                <span>0</span>
            `;

            // Draw grid lines
            ctx.strokeStyle = '#34495e';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 4; i++) {
                const y = (i / 4) * height;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }

            // No users selected
            if (selectedUsers.size === 0) {
                ctx.fillStyle = '#7f8c8d';
                ctx.font = '14px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Select a user to see latency graph', width / 2, height / 2);
                return;
            }

            // Check if any data has recv_ts
            let hasLatencyData = false;
            for (const [userId, entries] of Object.entries(userData)) {
                if (!selectedUsers.has(userId)) continue;
                if (entries.some(e => e.recv_ts !== undefined)) {
                    hasLatencyData = true;
                    break;
                }
            }

            if (!hasLatencyData) {
                ctx.fillStyle = '#7f8c8d';
                ctx.font = '14px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('No latency data (requires server update)', width / 2, height / 2);
                return;
            }

            // Draw latency line for each selected user
            let colorIdx = 0;
            for (const [userId, entries] of Object.entries(userData)) {
                const userColor = userColors[colorIdx % userColors.length];
                colorIdx++;

                if (!selectedUsers.has(userId)) continue;

                // Filter entries by time range
                const filtered = entries.filter(e => e.ts >= rangeStartTime && e.ts <= rangeEndTime);
                if (filtered.length < 2) continue;

                // Draw the latency line (use absolute value, dashed for negative)
                ctx.strokeStyle = userColor;
                ctx.lineWidth = 2;

                let started = false;
                let lastWasNegative = false;
                for (const entry of filtered) {
                    const rawLatency = getNetworkLatency(entry);
                    if (rawLatency === null) continue;
                    const latency = Math.abs(rawLatency);
                    if (latency > 300) continue; // Skip extreme values

                    const isNegative = rawLatency < 0;
                    const x = ((entry.ts - rangeStartTime) / (rangeEndTime - rangeStartTime)) * width;
                    const y = height - (latency / maxLatency) * height;

                    // Switch line style when sign changes
                    if (started && isNegative !== lastWasNegative) {
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(x, y);
                    }

                    // Use dashed line for negative latencies (clock ahead)
                    ctx.setLineDash(isNegative ? [4, 2] : []);

                    if (!started) {
                        ctx.beginPath();
                        ctx.moveTo(x, y);
                        started = true;
                    } else {
                        ctx.lineTo(x, y);
                    }
                    lastWasNegative = isNegative;
                }
                ctx.stroke();
                ctx.setLineDash([]);

                // Draw user label at the end of the line
                if (filtered.length > 0) {
                    const last = filtered[filtered.length - 1];
                    const rawLatency = getNetworkLatency(last);
                    if (rawLatency !== null) {
                        const latency = Math.abs(rawLatency);
                        if (latency <= 300) {
                            const x = ((last.ts - rangeStartTime) / (rangeEndTime - rangeStartTime)) * width;
                            const y = height - (latency / maxLatency) * height;
                            ctx.fillStyle = userColor;
                            ctx.font = 'bold 10px sans-serif';
                            ctx.textAlign = 'right';
                            const sign = rawLatency < 0 ? '-' : '';
                            ctx.fillText(`${getDisplayName(userId)}: ${sign}${latency.toFixed(1)}s`, Math.min(x, width - 5), y - 5);
                        }
                    }
                }
            }
        }

        function drawHeartRateGraph() {
            // Only draw if heart rate graph is visible
            if (!document.getElementById('show-heartrate-graph').checked) return;

            const canvas = document.getElementById('heartrate-graph');
            const ctx = canvas.getContext('2d');

            // Set canvas size to match display size (for sharp rendering)
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * window.devicePixelRatio;
            canvas.height = rect.height * window.devicePixelRatio;
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);

            const width = rect.width;
            const height = rect.height;

            // Clear canvas
            ctx.clearRect(0, 0, width, height);

            // Update time axis labels
            document.getElementById('heartrate-time-start').textContent = formatTimeShortInTz(rangeStartTime);
            document.getElementById('heartrate-time-end').textContent = formatTimeShortInTz(rangeEndTime);

            // Calculate heart rate range for Y axis scaling (only from visible time range)
            let maxHR = 0;
            let minHR = Infinity;
            let hasHRData = false;
            for (const [userId, entries] of Object.entries(userData)) {
                if (!selectedUsers.has(userId)) continue;
                for (const entry of entries) {
                    if (entry.ts < rangeStartTime || entry.ts > rangeEndTime) continue;
                    if (entry.hr !== undefined && entry.hr > 0) {
                        maxHR = Math.max(maxHR, entry.hr);
                        minHR = Math.min(minHR, entry.hr);
                        hasHRData = true;
                    }
                }
            }

            // Set sensible defaults and add padding
            if (!hasHRData || maxHR === 0) {
                maxHR = 200;
                minHR = 0;
            } else {
                // Add 10% padding above max
                maxHR = Math.ceil((maxHR * 1.1) / 10) * 10;
                // Round min down to nearest 10, with some padding below
                minHR = Math.max(0, Math.floor((minHR * 0.9) / 10) * 10);
                // Ensure at least 40 bpm range for readability
                if (maxHR - minHR < 40) {
                    const mid = (maxHR + minHR) / 2;
                    maxHR = Math.ceil((mid + 20) / 10) * 10;
                    minHR = Math.max(0, Math.floor((mid - 20) / 10) * 10);
                }
            }

            // Update Y axis labels
            const yLabels = document.getElementById('heartrate-y-labels');
            const range = maxHR - minHR;
            yLabels.innerHTML = `
                <span>${maxHR}</span>
                <span>${Math.round(minHR + range * 0.75)}</span>
                <span>${Math.round(minHR + range * 0.5)}</span>
                <span>${Math.round(minHR + range * 0.25)}</span>
                <span>${minHR}</span>
            `;

            // Draw grid lines
            ctx.strokeStyle = '#34495e';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 4; i++) {
                const y = (i / 4) * height;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }

            // No users selected
            if (selectedUsers.size === 0) {
                ctx.fillStyle = '#7f8c8d';
                ctx.font = '14px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Select a user to see heart rate graph', width / 2, height / 2);
                return;
            }

            if (!hasHRData) {
                ctx.fillStyle = '#7f8c8d';
                ctx.font = '14px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('No heart rate data available', width / 2, height / 2);
                return;
            }

            // Draw heart rate line for each selected user
            let colorIdx = 0;
            for (const [userId, entries] of Object.entries(userData)) {
                const userColor = userColors[colorIdx % userColors.length];
                colorIdx++;

                if (!selectedUsers.has(userId)) continue;

                // Filter entries by time range and having HR data
                const filtered = entries.filter(e => e.ts >= rangeStartTime && e.ts <= rangeEndTime && e.hr !== undefined && e.hr > 0);
                if (filtered.length < 2) continue;

                // Draw the heart rate line
                ctx.strokeStyle = '#e91e63'; // Pink color for heart rate
                ctx.lineWidth = 2;
                ctx.beginPath();

                let started = false;
                for (const entry of filtered) {
                    const x = ((entry.ts - rangeStartTime) / (rangeEndTime - rangeStartTime)) * width;
                    const y = height - ((entry.hr - minHR) / range) * height;

                    if (!started) {
                        ctx.moveTo(x, y);
                        started = true;
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();

                // Draw user label at the end of the line
                if (filtered.length > 0) {
                    const last = filtered[filtered.length - 1];
                    const x = ((last.ts - rangeStartTime) / (rangeEndTime - rangeStartTime)) * width;
                    const y = height - ((last.hr - minHR) / range) * height;
                    ctx.fillStyle = '#e91e63';
                    ctx.font = 'bold 10px sans-serif';
                    ctx.textAlign = 'right';
                    ctx.fillText(`${getDisplayName(userId)}: ${last.hr} bpm`, Math.min(x, width - 5), y - 5);
                }
            }
        }

        function drawAccuracyGraph() {
            // Only draw if accuracy graph is visible
            if (!document.getElementById('show-accuracy-graph').checked) return;

            const canvas = document.getElementById('accuracy-graph');
            const ctx = canvas.getContext('2d');

            // Set canvas size to match display size (for sharp rendering)
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * window.devicePixelRatio;
            canvas.height = rect.height * window.devicePixelRatio;
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);

            const width = rect.width;
            const height = rect.height;

            // Clear canvas
            ctx.clearRect(0, 0, width, height);

            // Update time axis labels
            document.getElementById('accuracy-time-start').textContent = formatTimeShortInTz(rangeStartTime);
            document.getElementById('accuracy-time-end').textContent = formatTimeShortInTz(rangeEndTime);

            // Calculate accuracy range for Y axis scaling (only from visible time range)
            let maxAcc = 0;
            let hasAccData = false;
            for (const [userId, entries] of Object.entries(userData)) {
                if (!selectedUsers.has(userId)) continue;
                for (const entry of entries) {
                    if (entry.ts < rangeStartTime || entry.ts > rangeEndTime) continue;
                    if (entry.hac !== undefined && entry.hac > 0) {
                        maxAcc = Math.max(maxAcc, entry.hac);
                        hasAccData = true;
                    }
                }
            }

            // Set sensible defaults and add padding
            if (!hasAccData || maxAcc === 0) {
                maxAcc = 100;
            } else {
                // Add 10% padding above max, round to nice number
                maxAcc = Math.ceil((maxAcc * 1.1) / 10) * 10;
                maxAcc = Math.max(maxAcc, 10); // At least 10m range
            }

            // Update Y axis labels
            const yLabels = document.getElementById('accuracy-y-labels');
            yLabels.innerHTML = `
                <span>${maxAcc}</span>
                <span>${Math.round(maxAcc * 0.75)}</span>
                <span>${Math.round(maxAcc * 0.5)}</span>
                <span>${Math.round(maxAcc * 0.25)}</span>
                <span>0</span>
            `;

            // Draw grid lines
            ctx.strokeStyle = '#34495e';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 4; i++) {
                const y = (i / 4) * height;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }

            // No users selected
            if (selectedUsers.size === 0) {
                ctx.fillStyle = '#7f8c8d';
                ctx.font = '14px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Select a user to see accuracy graph', width / 2, height / 2);
                return;
            }

            if (!hasAccData) {
                ctx.fillStyle = '#7f8c8d';
                ctx.font = '14px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('No accuracy data available', width / 2, height / 2);
                return;
            }

            // Draw accuracy line for each selected user
            let colorIdx = 0;
            for (const [userId, entries] of Object.entries(userData)) {
                const userColor = userColors[colorIdx % userColors.length];
                colorIdx++;

                if (!selectedUsers.has(userId)) continue;

                // Filter entries by time range and having accuracy data
                const filtered = entries.filter(e => e.ts >= rangeStartTime && e.ts <= rangeEndTime && e.hac !== undefined && e.hac > 0);
                if (filtered.length < 2) continue;

                // Draw the accuracy line
                ctx.strokeStyle = '#9b59b6'; // Purple color for accuracy
                ctx.lineWidth = 2;
                ctx.beginPath();

                let started = false;
                for (const entry of filtered) {
                    const x = ((entry.ts - rangeStartTime) / (rangeEndTime - rangeStartTime)) * width;
                    const y = height - (entry.hac / maxAcc) * height;

                    if (!started) {
                        ctx.moveTo(x, y);
                        started = true;
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();

                // Draw user label at the end of the line
                if (filtered.length > 0) {
                    const last = filtered[filtered.length - 1];
                    const x = ((last.ts - rangeStartTime) / (rangeEndTime - rangeStartTime)) * width;
                    const y = height - (last.hac / maxAcc) * height;
                    ctx.fillStyle = '#9b59b6';
                    ctx.font = 'bold 10px sans-serif';
                    ctx.textAlign = 'right';
                    ctx.fillText(`${getDisplayName(userId)}: ${last.hac.toFixed(1)}m`, Math.min(x, width - 5), y - 5);
                }
            }
        }

        // Haversine distance calculation between two lat/lon points (returns meters)
        function haversineDistance(lat1, lon1, lat2, lon2) {
            const R = 6371000; // Earth radius in meters
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                Math.sin(dLon / 2) * Math.sin(dLon / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            return R * c;
        }

        function drawDistanceGraph() {
            // Only draw if distance graph is visible
            if (!document.getElementById('show-distance-graph').checked) return;

            const canvas = document.getElementById('distance-graph');
            const ctx = canvas.getContext('2d');

            // Set canvas size to match display size (for sharp rendering)
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * window.devicePixelRatio;
            canvas.height = rect.height * window.devicePixelRatio;
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);

            const width = rect.width;
            const height = rect.height;

            // Clear canvas
            ctx.clearRect(0, 0, width, height);

            // Update time axis labels
            document.getElementById('distance-time-start').textContent = formatTimeShortInTz(rangeStartTime);
            document.getElementById('distance-time-end').textContent = formatTimeShortInTz(rangeEndTime);

            // Calculate cumulative distance for each user (only 10s points for CPU efficiency)
            let maxDist = 0;
            let hasDistData = false;
            const userDistances = {};

            for (const [userId, entries] of Object.entries(userData)) {
                if (!selectedUsers.has(userId)) continue;

                // Filter to only 10s points (skip 1s high-frequency points)
                // 10s points have gaps >= 5 seconds from the previous point
                const filtered = [];
                let lastTs = -Infinity;
                for (const entry of entries) {
                    if (entry.ts < rangeStartTime || entry.ts > rangeEndTime) continue;
                    // Only include points that are at least 5 seconds apart (to catch 10s points)
                    if (entry.ts - lastTs >= 5) {
                        filtered.push(entry);
                        lastTs = entry.ts;
                    }
                }

                if (filtered.length < 2) continue;

                // Calculate cumulative distance
                const distances = [{ts: filtered[0].ts, dist: 0}];
                let cumDist = 0;
                for (let i = 1; i < filtered.length; i++) {
                    const prev = filtered[i - 1];
                    const curr = filtered[i];
                    const d = haversineDistance(prev.lat, prev.lon, curr.lat, curr.lon);
                    cumDist += d;
                    distances.push({ts: curr.ts, dist: cumDist});
                }

                if (distances.length > 1) {
                    userDistances[userId] = distances;
                    maxDist = Math.max(maxDist, cumDist);
                    hasDistData = true;
                }
            }

            // Set sensible defaults and add padding
            if (!hasDistData || maxDist === 0) {
                maxDist = 10000;
            } else {
                // Add 10% padding above max, round to nice number
                maxDist = Math.ceil((maxDist * 1.1) / 1000) * 1000;
                maxDist = Math.max(maxDist, 1000); // At least 1km range
            }

            // Update Y axis labels (show in km if over 10km, otherwise meters)
            const yLabels = document.getElementById('distance-y-labels');
            if (maxDist >= 10000) {
                yLabels.innerHTML = `
                    <span>${(maxDist / 1000).toFixed(1)}km</span>
                    <span>${(maxDist * 0.75 / 1000).toFixed(1)}km</span>
                    <span>${(maxDist * 0.5 / 1000).toFixed(1)}km</span>
                    <span>${(maxDist * 0.25 / 1000).toFixed(1)}km</span>
                    <span>0</span>
                `;
            } else {
                yLabels.innerHTML = `
                    <span>${Math.round(maxDist)}m</span>
                    <span>${Math.round(maxDist * 0.75)}m</span>
                    <span>${Math.round(maxDist * 0.5)}m</span>
                    <span>${Math.round(maxDist * 0.25)}m</span>
                    <span>0</span>
                `;
            }

            // Draw grid lines
            ctx.strokeStyle = '#34495e';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 4; i++) {
                const y = (i / 4) * height;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }

            // No users selected
            if (selectedUsers.size === 0) {
                ctx.fillStyle = '#7f8c8d';
                ctx.font = '14px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Select a user to see distance graph', width / 2, height / 2);
                return;
            }

            if (!hasDistData) {
                ctx.fillStyle = '#7f8c8d';
                ctx.font = '14px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Not enough data for distance calculation', width / 2, height / 2);
                return;
            }

            // Draw distance line for each selected user
            let colorIdx = 0;
            for (const [userId, distances] of Object.entries(userDistances)) {
                const userColor = userColors[colorIdx % userColors.length];
                colorIdx++;

                if (distances.length < 2) continue;

                // Draw the distance line
                ctx.strokeStyle = '#27ae60'; // Green color for distance
                ctx.lineWidth = 2;
                ctx.beginPath();

                let started = false;
                for (const point of distances) {
                    const x = ((point.ts - rangeStartTime) / (rangeEndTime - rangeStartTime)) * width;
                    const y = height - (point.dist / maxDist) * height;

                    if (!started) {
                        ctx.moveTo(x, y);
                        started = true;
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();

                // Draw user label at the end of the line
                if (distances.length > 0) {
                    const last = distances[distances.length - 1];
                    const x = ((last.ts - rangeStartTime) / (rangeEndTime - rangeStartTime)) * width;
                    const y = height - (last.dist / maxDist) * height;
                    ctx.fillStyle = '#27ae60';
                    ctx.font = 'bold 10px sans-serif';
                    ctx.textAlign = 'right';
                    const distLabel = last.dist >= 1000 ? `${(last.dist / 1000).toFixed(2)}km` : `${Math.round(last.dist)}m`;
                    ctx.fillText(`${getDisplayName(userId)}: ${distLabel}`, Math.min(x, width - 5), y - 5);
                }
            }
        }

        // Graph hover highlighting (shared between battery, signal, and latency graphs)
        let graphHighlightMarkers = [];
        let pendingHighlightUpdate = null;

        function clearGraphHighlight() {
            // Cancel any pending highlight update
            if (pendingHighlightUpdate) {
                cancelAnimationFrame(pendingHighlightUpdate);
                pendingHighlightUpdate = null;
            }

            // Remove highlight markers from map (explicitly remove tooltips to prevent orphans)
            for (const marker of graphHighlightMarkers) {
                const tooltip = marker.getTooltip();
                marker.closeTooltip();
                if (tooltip && map.hasLayer(tooltip)) {
                    map.removeLayer(tooltip);
                }
                marker.unbindTooltip();
                map.removeLayer(marker);
            }
            graphHighlightMarkers = [];

            // Redraw graphs without highlight
            if (document.getElementById('show-speed-graph').checked) {
                drawSpeedGraph();
            }
            if (document.getElementById('show-battery-graph').checked) {
                drawBatteryGraph();
            }
            if (document.getElementById('show-signal-graph').checked) {
                drawSignalGraph();
            }
            if (document.getElementById('show-latency-graph').checked) {
                drawLatencyGraph();
            }
            if (document.getElementById('show-heartrate-graph').checked) {
                drawHeartRateGraph();
            }
            if (document.getElementById('show-accuracy-graph').checked) {
                drawAccuracyGraph();
            }
            if (document.getElementById('show-distance-graph').checked) {
                drawDistanceGraph();
            }
        }

        function showGraphHighlight(mouseX, sourceGraph) {
            // Cancel any pending update to prevent race conditions
            if (pendingHighlightUpdate) {
                cancelAnimationFrame(pendingHighlightUpdate);
            }

            // Debounce with requestAnimationFrame for smooth updates
            pendingHighlightUpdate = requestAnimationFrame(() => {
                pendingHighlightUpdate = null;
                showGraphHighlightImmediate(mouseX, sourceGraph);
            });
        }

        function showGraphHighlightImmediate(mouseX, sourceGraph) {
            const canvas = document.getElementById(sourceGraph);
            const rect = canvas.getBoundingClientRect();
            const width = rect.width;

            // Calculate timestamp from mouse X position
            const ratio = Math.max(0, Math.min(1, mouseX / width));
            const timestamp = rangeStartTime + ratio * (rangeEndTime - rangeStartTime);

            // Clear previous highlight markers (explicitly remove tooltips to prevent orphans)
            for (const marker of graphHighlightMarkers) {
                const tooltip = marker.getTooltip();
                marker.closeTooltip();
                if (tooltip && map.hasLayer(tooltip)) {
                    map.removeLayer(tooltip);
                }
                marker.unbindTooltip();
                map.removeLayer(marker);
            }
            graphHighlightMarkers = [];

            // Find and highlight position for each selected user
            let colorIdx = 0;
            for (const [userId, entries] of Object.entries(userData)) {
                const userColor = userColors[colorIdx % userColors.length];
                colorIdx++;

                if (!selectedUsers.has(userId)) continue;

                // Filter entries by time range
                const filtered = entries.filter(e => e.ts >= rangeStartTime && e.ts <= rangeEndTime);
                if (filtered.length === 0) continue;

                // Find closest entry to timestamp
                let closest = filtered[0];
                let closestDist = Math.abs(filtered[0].ts - timestamp);
                for (const entry of filtered) {
                    const dist = Math.abs(entry.ts - timestamp);
                    if (dist < closestDist) {
                        closestDist = dist;
                        closest = entry;
                    }
                }

                // Create highlight marker on map
                const marker = L.circleMarker([closest.lat, closest.lon], {
                    radius: 12,
                    fillColor: userColor,
                    color: '#fff',
                    weight: 3,
                    fillOpacity: 0.9,
                    opacity: 1
                });

                // Add tooltip with info
                const time = formatTimeInTz(closest.ts);
                let tooltipHtml = `
                    <b>${getDisplayName(userId)}</b><br>
                    Time: ${time}<br>
                    Battery: ${closest.bat !== undefined ? closest.bat + '%' : 'N/A'}<br>
                    Speed: ${(closest.spd || 0).toFixed(1)} kts`;

                // Add accuracy if available
                if (closest.hac !== undefined) {
                    const hacColor = closest.hac > 50 ? '#e74c3c' : closest.hac > 20 ? '#f39c12' : '#2ecc71';
                    tooltipHtml += `<br>Accuracy: <span style="color:${hacColor}">${closest.hac.toFixed(1)}m</span>`;
                }

                // Add signal strength if available
                if (closest.sig !== undefined && closest.sig !== null) {
                    const sigBars = '‚ñÇ‚ñÑ‚ñÜ‚ñà'.slice(0, Math.max(1, Math.min(4, closest.sig)));
                    tooltipHtml += `<br>Signal: ${sigBars} (${closest.sig})`;
                }

                // Add latency if available
                const latency = getNetworkLatency(closest);
                if (latency !== null && Math.abs(latency) < 300) {
                    let latencyColor, latencyText;
                    if (latency < 0) {
                        // Negative = phone clock ahead of server
                        latencyColor = '#9b59b6'; // Purple for clock ahead
                        latencyText = `${latency.toFixed(1)}s (clock ahead)`;
                    } else {
                        latencyColor = latency > 5 ? '#e74c3c' : latency > 2 ? '#f39c12' : '#2ecc71';
                        latencyText = `${latency.toFixed(1)}s`;
                    }
                    tooltipHtml += `<br>Latency: <span style="color:${latencyColor}">${latencyText}</span>`;
                }

                // Add heart rate if available (search nearby entries since HR only sent every ~10 samples)
                let hrValue = closest.hr;
                if (hrValue === undefined || hrValue <= 0) {
                    // Search nearby entries for HR data (within 15 seconds)
                    for (const entry of filtered) {
                        if (Math.abs(entry.ts - closest.ts) <= 15 && entry.hr !== undefined && entry.hr > 0) {
                            hrValue = entry.hr;
                            break;
                        }
                    }
                }
                if (hrValue !== undefined && hrValue > 0) {
                    tooltipHtml += `<br>Heart Rate: <span style="color:#e91e63">${hrValue} bpm</span>`;
                }

                // Add battery saver warning if active
                if (closest.flg) {
                    if (closest.flg.ps) {
                        tooltipHtml += `<br><span style="color:#e74c3c">‚ö†Ô∏è Battery Saver ON</span>`;
                    }
                    if (closest.flg.bo === false) {
                        tooltipHtml += `<br><span style="color:#f39c12">‚ö†Ô∏è Battery Opt OFF</span>`;
                    }
                }

                marker.bindTooltip(tooltipHtml, { permanent: true, direction: 'top', offset: [0, -10] });

                marker.addTo(map);
                graphHighlightMarkers.push(marker);
            }

            // Redraw graphs with highlight line
            drawGraphsWithHighlight(mouseX, ratio);
        }

        function drawGraphsWithHighlight(highlightX, ratio) {
            const timestamp = rangeStartTime + ratio * (rangeEndTime - rangeStartTime);

            // Draw speed graph with highlight if visible
            if (document.getElementById('show-speed-graph').checked) {
                drawSpeedGraph();
                // Calculate speed range for proper scaling (only from visible time range)
                let maxSpeed = 0;
                let hasSpeedData = false;
                for (const [userId, entries] of Object.entries(userData)) {
                    if (!selectedUsers.has(userId)) continue;
                    for (const entry of entries) {
                        if (entry.ts < rangeStartTime || entry.ts > rangeEndTime) continue;
                        if (entry.spd !== undefined && entry.spd !== null && entry.spd >= 0) {
                            maxSpeed = Math.max(maxSpeed, entry.spd);
                            hasSpeedData = true;
                        }
                    }
                }
                if (!hasSpeedData || maxSpeed === 0) {
                    maxSpeed = 20;
                } else {
                    maxSpeed = Math.ceil((maxSpeed * 1.1) / 2) * 2;
                    if (maxSpeed < 5) maxSpeed = 5;
                }
                drawHighlightOnGraph('speed-graph', highlightX, ratio, timestamp, 'spd', maxSpeed, 0);
            }

            // Draw battery graph with highlight if visible
            if (document.getElementById('show-battery-graph').checked) {
                drawBatteryGraph();
                // Calculate battery range for proper scaling
                let maxBat = 0;
                let minBat = 100;
                let hasBatData = false;
                for (const [userId, entries] of Object.entries(userData)) {
                    if (!selectedUsers.has(userId)) continue;
                    for (const entry of entries) {
                        if (entry.ts < rangeStartTime || entry.ts > rangeEndTime) continue;
                        if (entry.bat !== undefined && entry.bat !== null && entry.bat >= 0) {
                            maxBat = Math.max(maxBat, entry.bat);
                            minBat = Math.min(minBat, entry.bat);
                            hasBatData = true;
                        }
                    }
                }
                if (!hasBatData) {
                    maxBat = 100;
                    minBat = 0;
                } else {
                    maxBat = maxBat > 95 ? 100 : Math.ceil((maxBat + 5) / 5) * 5;
                    minBat = Math.floor(minBat / 5) * 5;
                    if (maxBat - minBat < 10) {
                        if (maxBat < 100) maxBat = Math.min(100, minBat + 10);
                        else minBat = Math.max(0, maxBat - 10);
                    }
                }
                drawHighlightOnGraph('battery-graph', highlightX, ratio, timestamp, 'bat', maxBat, minBat);
            }

            // Draw signal graph with highlight if visible
            if (document.getElementById('show-signal-graph').checked) {
                drawSignalGraph();
                drawHighlightOnGraph('signal-graph', highlightX, ratio, timestamp, 'sig', 4);
            }

            // Draw latency graph with highlight if visible
            if (document.getElementById('show-latency-graph').checked) {
                drawLatencyGraph();
                // Calculate current max latency for proper scaling (only from visible time range)
                let maxLatency = 0;
                let hasLatencyValues = false;
                for (const [userId, entries] of Object.entries(userData)) {
                    if (!selectedUsers.has(userId)) continue;
                    for (const entry of entries) {
                        if (entry.ts < rangeStartTime || entry.ts > rangeEndTime) continue;
                        const latency = getNetworkLatency(entry);
                        if (latency !== null && Math.abs(latency) < 300) {
                            maxLatency = Math.max(maxLatency, Math.abs(latency));
                            hasLatencyValues = true;
                        }
                    }
                }
                if (!hasLatencyValues || maxLatency === 0) {
                    maxLatency = 10;
                } else {
                    maxLatency = maxLatency * 1.1;
                    if (maxLatency < 2) {
                        maxLatency = Math.ceil(maxLatency * 4) / 4;
                        if (maxLatency < 0.5) maxLatency = 0.5;
                    } else if (maxLatency < 5) {
                        maxLatency = Math.ceil(maxLatency);
                    } else {
                        maxLatency = Math.ceil(maxLatency / 2) * 2;
                    }
                }
                drawLatencyHighlightOnGraph('latency-graph', highlightX, ratio, timestamp, maxLatency);
            }

            // Draw heart rate graph with highlight if visible
            if (document.getElementById('show-heartrate-graph').checked) {
                drawHeartRateGraph();
                // Calculate heart rate range for proper scaling (only from visible time range)
                let maxHR = 0;
                let minHR = Infinity;
                let hasHRData = false;
                for (const [userId, entries] of Object.entries(userData)) {
                    if (!selectedUsers.has(userId)) continue;
                    for (const entry of entries) {
                        if (entry.ts < rangeStartTime || entry.ts > rangeEndTime) continue;
                        if (entry.hr !== undefined && entry.hr > 0) {
                            maxHR = Math.max(maxHR, entry.hr);
                            minHR = Math.min(minHR, entry.hr);
                            hasHRData = true;
                        }
                    }
                }
                if (!hasHRData || maxHR === 0) {
                    maxHR = 200;
                    minHR = 0;
                } else {
                    maxHR = Math.ceil((maxHR * 1.1) / 10) * 10;
                    minHR = Math.max(0, Math.floor((minHR * 0.9) / 10) * 10);
                    if (maxHR - minHR < 40) {
                        const mid = (maxHR + minHR) / 2;
                        maxHR = Math.ceil((mid + 20) / 10) * 10;
                        minHR = Math.max(0, Math.floor((mid - 20) / 10) * 10);
                    }
                }
                drawHighlightOnGraph('heartrate-graph', highlightX, ratio, timestamp, 'hr', maxHR, minHR);
            }

            // Draw accuracy graph with highlight if visible
            if (document.getElementById('show-accuracy-graph').checked) {
                drawAccuracyGraph();
                // Calculate accuracy range for proper scaling (only from visible time range)
                let maxAcc = 0;
                let hasAccData = false;
                for (const [userId, entries] of Object.entries(userData)) {
                    if (!selectedUsers.has(userId)) continue;
                    for (const entry of entries) {
                        if (entry.ts < rangeStartTime || entry.ts > rangeEndTime) continue;
                        if (entry.hac !== undefined && entry.hac > 0) {
                            maxAcc = Math.max(maxAcc, entry.hac);
                            hasAccData = true;
                        }
                    }
                }
                if (!hasAccData || maxAcc === 0) {
                    maxAcc = 100;
                } else {
                    maxAcc = Math.ceil((maxAcc * 1.1) / 10) * 10;
                    maxAcc = Math.max(maxAcc, 10);
                }
                drawHighlightOnGraph('accuracy-graph', highlightX, ratio, timestamp, 'hac', maxAcc, 0);
            }
        }

        function drawLatencyHighlightOnGraph(canvasId, highlightX, ratio, timestamp, maxLatency) {
            const canvas = document.getElementById(canvasId);
            const ctx = canvas.getContext('2d');
            const rect = canvas.getBoundingClientRect();
            const height = rect.height;

            // Draw vertical highlight line
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 3]);
            ctx.beginPath();
            ctx.moveTo(highlightX * window.devicePixelRatio, 0);
            ctx.lineTo(highlightX * window.devicePixelRatio, height * window.devicePixelRatio);
            ctx.stroke();
            ctx.setLineDash([]);

            // Draw dots at intersection points
            let colorIdx = 0;
            for (const [userId, entries] of Object.entries(userData)) {
                const userColor = userColors[colorIdx % userColors.length];
                colorIdx++;

                if (!selectedUsers.has(userId)) continue;

                const filtered = entries.filter(e => e.ts >= rangeStartTime && e.ts <= rangeEndTime);
                if (filtered.length === 0) continue;

                // Find closest entry
                let closest = filtered[0];
                let closestDist = Math.abs(filtered[0].ts - timestamp);
                for (const entry of filtered) {
                    const dist = Math.abs(entry.ts - timestamp);
                    if (dist < closestDist) {
                        closestDist = dist;
                        closest = entry;
                    }
                }

                const rawLatency = getNetworkLatency(closest);
                if (rawLatency !== null) {
                    const latency = Math.abs(rawLatency);
                    if (latency < 300) {
                        const x = ((closest.ts - rangeStartTime) / (rangeEndTime - rangeStartTime)) * rect.width;
                        const y = height - (latency / maxLatency) * height;

                        ctx.beginPath();
                        ctx.arc(x * window.devicePixelRatio, y * window.devicePixelRatio, 6 * window.devicePixelRatio, 0, Math.PI * 2);
                        ctx.fillStyle = userColor;
                        ctx.fill();
                        ctx.strokeStyle = '#fff';
                        ctx.lineWidth = 2 * window.devicePixelRatio;
                        ctx.stroke();
                    }
                }
            }
        }

        function drawHighlightOnGraph(canvasId, highlightX, ratio, timestamp, dataField, maxValue, minValue = 0) {
            const canvas = document.getElementById(canvasId);
            const ctx = canvas.getContext('2d');
            const rect = canvas.getBoundingClientRect();
            const height = rect.height;
            const valueRange = maxValue - minValue;

            // Draw vertical highlight line
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 3]);
            ctx.beginPath();
            ctx.moveTo(highlightX * window.devicePixelRatio, 0);
            ctx.lineTo(highlightX * window.devicePixelRatio, height * window.devicePixelRatio);
            ctx.stroke();
            ctx.setLineDash([]);

            // Draw dots at intersection points
            let colorIdx = 0;
            for (const [userId, entries] of Object.entries(userData)) {
                const userColor = userColors[colorIdx % userColors.length];
                colorIdx++;

                if (!selectedUsers.has(userId)) continue;

                const filtered = entries.filter(e => e.ts >= rangeStartTime && e.ts <= rangeEndTime);
                if (filtered.length === 0) continue;

                // Find closest entry
                let closest = filtered[0];
                let closestDist = Math.abs(filtered[0].ts - timestamp);
                for (const entry of filtered) {
                    const dist = Math.abs(entry.ts - timestamp);
                    if (dist < closestDist) {
                        closestDist = dist;
                        closest = entry;
                    }
                }

                const value = closest[dataField];
                if (value !== undefined && value !== null) {
                    const x = ((closest.ts - rangeStartTime) / (rangeEndTime - rangeStartTime)) * rect.width;
                    const y = height - ((value - minValue) / valueRange) * height;

                    ctx.beginPath();
                    ctx.arc(x * window.devicePixelRatio, y * window.devicePixelRatio, 6 * window.devicePixelRatio, 0, Math.PI * 2);
                    ctx.fillStyle = userColor;
                    ctx.fill();
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2 * window.devicePixelRatio;
                    ctx.stroke();
                }
            }
        }

        // Set up graph mouse events
        document.getElementById('speed-graph').addEventListener('mousemove', (e) => {
            const rect = e.target.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            showGraphHighlight(mouseX, 'speed-graph');
        });

        document.getElementById('speed-graph').addEventListener('mouseleave', () => {
            clearGraphHighlight();
        });

        document.getElementById('battery-graph').addEventListener('mousemove', (e) => {
            const rect = e.target.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            showGraphHighlight(mouseX, 'battery-graph');
        });

        document.getElementById('battery-graph').addEventListener('mouseleave', () => {
            clearGraphHighlight();
        });

        document.getElementById('signal-graph').addEventListener('mousemove', (e) => {
            const rect = e.target.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            showGraphHighlight(mouseX, 'signal-graph');
        });

        document.getElementById('signal-graph').addEventListener('mouseleave', () => {
            clearGraphHighlight();
        });

        document.getElementById('latency-graph').addEventListener('mousemove', (e) => {
            const rect = e.target.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            showGraphHighlight(mouseX, 'latency-graph');
        });

        document.getElementById('latency-graph').addEventListener('mouseleave', () => {
            clearGraphHighlight();
        });

        document.getElementById('heartrate-graph').addEventListener('mousemove', (e) => {
            const rect = e.target.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            showGraphHighlight(mouseX, 'heartrate-graph');
        });

        document.getElementById('heartrate-graph').addEventListener('mouseleave', () => {
            clearGraphHighlight();
        });

        document.getElementById('accuracy-graph').addEventListener('mousemove', (e) => {
            const rect = e.target.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            showGraphHighlight(mouseX, 'accuracy-graph');
        });

        document.getElementById('accuracy-graph').addEventListener('mouseleave', () => {
            clearGraphHighlight();
        });

        document.getElementById('distance-graph').addEventListener('mousemove', (e) => {
            const rect = e.target.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            showGraphHighlight(mouseX, 'distance-graph');
        });

        document.getElementById('distance-graph').addEventListener('mouseleave', () => {
            clearGraphHighlight();
        });

        // Graph resize functionality
        let speedGraphHeight = parseInt(localStorage.getItem('speedGraphHeight')) || 150;
        let batteryGraphHeight = parseInt(localStorage.getItem('batteryGraphHeight')) || 150;
        let signalGraphHeight = parseInt(localStorage.getItem('signalGraphHeight')) || 150;
        let latencyGraphHeight = parseInt(localStorage.getItem('latencyGraphHeight')) || 150;
        let heartrateGraphHeight = parseInt(localStorage.getItem('heartrateGraphHeight')) || 150;
        let accuracyGraphHeight = parseInt(localStorage.getItem('accuracyGraphHeight')) || 150;
        let distanceGraphHeight = parseInt(localStorage.getItem('distanceGraphHeight')) || 150;
        const speedPanel = document.getElementById('speed-graph-panel');
        const batteryPanel = document.getElementById('battery-graph-panel');
        const signalPanel = document.getElementById('signal-graph-panel');
        const latencyPanel = document.getElementById('latency-graph-panel');
        const heartratePanel = document.getElementById('heartrate-graph-panel');
        const accuracyPanel = document.getElementById('accuracy-graph-panel');
        const distancePanel = document.getElementById('distance-graph-panel');
        const speedResizeHandle = document.getElementById('speed-graph-resize');
        const batteryResizeHandle = document.getElementById('battery-graph-resize');
        const signalResizeHandle = document.getElementById('signal-graph-resize');
        const latencyResizeHandle = document.getElementById('latency-graph-resize');
        const heartrateResizeHandle = document.getElementById('heartrate-graph-resize');
        const accuracyResizeHandle = document.getElementById('accuracy-graph-resize');
        const distanceResizeHandle = document.getElementById('distance-graph-resize');
        let isResizing = false;
        let resizingPanel = null;
        let startY = 0;
        let startHeight = 0;

        // Apply saved heights
        speedPanel.style.height = speedGraphHeight + 'px';
        batteryPanel.style.height = batteryGraphHeight + 'px';
        signalPanel.style.height = signalGraphHeight + 'px';
        latencyPanel.style.height = latencyGraphHeight + 'px';
        heartratePanel.style.height = heartrateGraphHeight + 'px';
        accuracyPanel.style.height = accuracyGraphHeight + 'px';
        distancePanel.style.height = distanceGraphHeight + 'px';

        function updateGraphPositions() {
            const mapEl = document.getElementById('map');
            const speedVisible = document.getElementById('show-speed-graph').checked;
            const batteryVisible = document.getElementById('show-battery-graph').checked;
            const signalVisible = document.getElementById('show-signal-graph').checked;
            const latencyVisible = document.getElementById('show-latency-graph').checked;
            const heartrateVisible = document.getElementById('show-heartrate-graph').checked;
            const accuracyVisible = document.getElementById('show-accuracy-graph').checked;
            const distanceVisible = document.getElementById('show-distance-graph').checked;

            let totalHeight = 80; // timeline height
            let currentBottom = 80;

            // Stack from bottom: distance, accuracy, heartrate, latency, signal, battery, speed
            if (distanceVisible) {
                distancePanel.style.display = 'block';
                distancePanel.style.bottom = currentBottom + 'px';
                currentBottom += distanceGraphHeight;
                totalHeight += distanceGraphHeight;
            } else {
                distancePanel.style.display = 'none';
            }

            if (accuracyVisible) {
                accuracyPanel.style.display = 'block';
                accuracyPanel.style.bottom = currentBottom + 'px';
                currentBottom += accuracyGraphHeight;
                totalHeight += accuracyGraphHeight;
            } else {
                accuracyPanel.style.display = 'none';
            }

            if (heartrateVisible) {
                heartratePanel.style.display = 'block';
                heartratePanel.style.bottom = currentBottom + 'px';
                currentBottom += heartrateGraphHeight;
                totalHeight += heartrateGraphHeight;
            } else {
                heartratePanel.style.display = 'none';
            }

            if (latencyVisible) {
                latencyPanel.style.display = 'block';
                latencyPanel.style.bottom = currentBottom + 'px';
                currentBottom += latencyGraphHeight;
                totalHeight += latencyGraphHeight;
            } else {
                latencyPanel.style.display = 'none';
            }

            if (signalVisible) {
                signalPanel.style.display = 'block';
                signalPanel.style.bottom = currentBottom + 'px';
                currentBottom += signalGraphHeight;
                totalHeight += signalGraphHeight;
            } else {
                signalPanel.style.display = 'none';
            }

            if (batteryVisible) {
                batteryPanel.style.display = 'block';
                batteryPanel.style.bottom = currentBottom + 'px';
                currentBottom += batteryGraphHeight;
                totalHeight += batteryGraphHeight;
            } else {
                batteryPanel.style.display = 'none';
            }

            if (speedVisible) {
                speedPanel.style.display = 'block';
                speedPanel.style.bottom = currentBottom + 'px';
                totalHeight += speedGraphHeight;
            } else {
                speedPanel.style.display = 'none';
            }

            mapEl.style.bottom = totalHeight + 'px';
            map.invalidateSize();
        }

        speedResizeHandle.addEventListener('mousedown', (e) => {
            isResizing = true;
            resizingPanel = 'speed';
            startY = e.clientY;
            startHeight = speedGraphHeight;
            speedResizeHandle.classList.add('dragging');
            document.body.style.cursor = 'ns-resize';
            document.body.style.userSelect = 'none';
            e.preventDefault();
        });

        batteryResizeHandle.addEventListener('mousedown', (e) => {
            isResizing = true;
            resizingPanel = 'battery';
            startY = e.clientY;
            startHeight = batteryPanel.offsetHeight;
            batteryResizeHandle.classList.add('dragging');
            document.body.style.cursor = 'ns-resize';
            document.body.style.userSelect = 'none';
            e.preventDefault();
        });

        signalResizeHandle.addEventListener('mousedown', (e) => {
            isResizing = true;
            resizingPanel = 'signal';
            startY = e.clientY;
            startHeight = signalPanel.offsetHeight;
            signalResizeHandle.classList.add('dragging');
            document.body.style.cursor = 'ns-resize';
            document.body.style.userSelect = 'none';
            e.preventDefault();
        });

        latencyResizeHandle.addEventListener('mousedown', (e) => {
            isResizing = true;
            resizingPanel = 'latency';
            startY = e.clientY;
            startHeight = latencyPanel.offsetHeight;
            latencyResizeHandle.classList.add('dragging');
            document.body.style.cursor = 'ns-resize';
            document.body.style.userSelect = 'none';
            e.preventDefault();
        });

        heartrateResizeHandle.addEventListener('mousedown', (e) => {
            isResizing = true;
            resizingPanel = 'heartrate';
            startY = e.clientY;
            startHeight = heartratePanel.offsetHeight;
            heartrateResizeHandle.classList.add('dragging');
            document.body.style.cursor = 'ns-resize';
            document.body.style.userSelect = 'none';
            e.preventDefault();
        });

        accuracyResizeHandle.addEventListener('mousedown', (e) => {
            isResizing = true;
            resizingPanel = 'accuracy';
            startY = e.clientY;
            startHeight = accuracyPanel.offsetHeight;
            accuracyResizeHandle.classList.add('dragging');
            document.body.style.cursor = 'ns-resize';
            document.body.style.userSelect = 'none';
            e.preventDefault();
        });

        distanceResizeHandle.addEventListener('mousedown', (e) => {
            isResizing = true;
            resizingPanel = 'distance';
            startY = e.clientY;
            startHeight = distancePanel.offsetHeight;
            distanceResizeHandle.classList.add('dragging');
            document.body.style.cursor = 'ns-resize';
            document.body.style.userSelect = 'none';
            e.preventDefault();
        });

        document.addEventListener('mousemove', (e) => {
            if (!isResizing) return;

            const deltaY = startY - e.clientY;
            const newHeight = Math.max(80, Math.min(400, startHeight + deltaY));

            if (resizingPanel === 'speed') {
                speedPanel.style.height = newHeight + 'px';
                speedGraphHeight = newHeight;
            } else if (resizingPanel === 'battery') {
                batteryPanel.style.height = newHeight + 'px';
                batteryGraphHeight = newHeight;
            } else if (resizingPanel === 'signal') {
                signalPanel.style.height = newHeight + 'px';
                signalGraphHeight = newHeight;
            } else if (resizingPanel === 'latency') {
                latencyPanel.style.height = newHeight + 'px';
                latencyGraphHeight = newHeight;
            } else if (resizingPanel === 'heartrate') {
                heartratePanel.style.height = newHeight + 'px';
                heartrateGraphHeight = newHeight;
            } else if (resizingPanel === 'accuracy') {
                accuracyPanel.style.height = newHeight + 'px';
                accuracyGraphHeight = newHeight;
            } else if (resizingPanel === 'distance') {
                distancePanel.style.height = newHeight + 'px';
                distanceGraphHeight = newHeight;
            }

            updateGraphPositions();

            // Redraw graphs at new size
            drawSpeedGraph();
            drawSpeedGraph();
            drawBatteryGraph();
            drawSignalGraph();
            drawLatencyGraph();
            drawHeartRateGraph();
            drawAccuracyGraph();
            drawDistanceGraph();
        });

        document.addEventListener('mouseup', () => {
            if (isResizing) {
                isResizing = false;
                speedResizeHandle.classList.remove('dragging');
                batteryResizeHandle.classList.remove('dragging');
                signalResizeHandle.classList.remove('dragging');
                latencyResizeHandle.classList.remove('dragging');
                heartrateResizeHandle.classList.remove('dragging');
                accuracyResizeHandle.classList.remove('dragging');
                distanceResizeHandle.classList.remove('dragging');
                document.body.style.cursor = '';
                document.body.style.userSelect = '';
                localStorage.setItem('speedGraphHeight', speedGraphHeight);
                localStorage.setItem('batteryGraphHeight', batteryGraphHeight);
                localStorage.setItem('signalGraphHeight', signalGraphHeight);
                localStorage.setItem('latencyGraphHeight', latencyGraphHeight);
                localStorage.setItem('heartrateGraphHeight', heartrateGraphHeight);
                localStorage.setItem('accuracyGraphHeight', accuracyGraphHeight);
                localStorage.setItem('distanceGraphHeight', distanceGraphHeight);
                resizingPanel = null;
            }
        });

        function zoomToUser(userId) {
            if (!userData[userId]) return;

            const entries = userData[userId];
            if (entries.length === 0) return;

            // Select only this user
            selectedUsers.clear();
            document.querySelectorAll('.user-item').forEach(el => el.classList.remove('selected'));

            selectedUsers.add(userId);
            const element = document.querySelector(`.user-item[data-user-id="${userId}"]`);
            if (element) element.classList.add('selected');

            // Reset playback to show all of this user's data
            resetPlaybackToSelection();

            // Zoom to all of user's points
            const coords = entries.map(e => [e.lat, e.lon]);
            map.fitBounds(coords, { padding: [50, 50] });
        }

        function getSelectedTimeRange() {
            // Get time range for selected users only
            let selMinTime = Infinity;
            let selMaxTime = -Infinity;

            for (const userId of selectedUsers) {
                if (userData[userId] && userData[userId].length > 0) {
                    const entries = userData[userId];
                    selMinTime = Math.min(selMinTime, entries[0].ts);
                    selMaxTime = Math.max(selMaxTime, entries[entries.length - 1].ts);
                }
            }

            // Fall back to global range if no users selected
            if (selMinTime === Infinity) {
                return { min: minTime, max: maxTime };
            }

            return { min: selMinTime, max: selMaxTime };
        }

        function timeToSliderValue(timestamp) {
            // Convert timestamp to slider value (0-100) based on global range
            if (maxTime === minTime) return 100;
            return ((timestamp - minTime) / (maxTime - minTime)) * 100;
        }

        function sliderValueToTime(value) {
            // Convert slider value (0-100) to timestamp based on global range
            return minTime + (maxTime - minTime) * (value / 100);
        }

        // Event listeners
        document.getElementById('load-btn').addEventListener('click', loadSummary);

        // Options dropdown toggle
        document.getElementById('options-btn').addEventListener('click', (e) => {
            e.stopPropagation();
            document.getElementById('options-dropdown-content').classList.toggle('show');
            document.getElementById('graphs-dropdown-content').classList.remove('show');
        });

        // Graphs dropdown toggle
        document.getElementById('graphs-btn').addEventListener('click', (e) => {
            e.stopPropagation();
            document.getElementById('graphs-dropdown-content').classList.toggle('show');
            document.getElementById('options-dropdown-content').classList.remove('show');
        });

        // Close dropdowns when clicking outside
        document.addEventListener('click', (e) => {
            const graphsDropdown = document.getElementById('graphs-dropdown-content');
            const graphsBtn = document.getElementById('graphs-btn');
            const optionsDropdown = document.getElementById('options-dropdown-content');
            const optionsBtn = document.getElementById('options-btn');

            if (!graphsDropdown.contains(e.target) && e.target !== graphsBtn) {
                graphsDropdown.classList.remove('show');
            }
            if (!optionsDropdown.contains(e.target) && e.target !== optionsBtn) {
                optionsDropdown.classList.remove('show');
            }
        });

        // About modal
        document.getElementById('about-btn').addEventListener('click', () => {
            document.getElementById('about-modal').classList.add('show');
        });

        document.getElementById('about-close-btn').addEventListener('click', () => {
            document.getElementById('about-modal').classList.remove('show');
        });

        document.getElementById('about-modal').addEventListener('click', (e) => {
            if (e.target.id === 'about-modal') {
                document.getElementById('about-modal').classList.remove('show');
            }
        });

        document.getElementById('start-slider').addEventListener('input', (e) => {
            const startVal = parseFloat(e.target.value);
            const endVal = parseFloat(document.getElementById('end-slider').value);
            // Don't let start go past end
            if (startVal > endVal) {
                e.target.value = endVal;
            }
            // Update visual indicators immediately (cheap)
            updateSliderRange();
            updateTimeDisplay();
            // Debounce expensive redraws until slider stops moving
            debouncedRedrawAll();
        });

        document.getElementById('end-slider').addEventListener('input', (e) => {
            const endVal = parseFloat(e.target.value);
            const startVal = parseFloat(document.getElementById('start-slider').value);
            // Don't let end go before start
            if (endVal < startVal) {
                e.target.value = startVal;
            }
            // Update visual indicators immediately (cheap)
            updateSliderRange();
            updateTimeDisplay();
            // Debounce expensive redraws until slider stops moving
            debouncedRedrawAll();
        });

        document.getElementById('speed-color').addEventListener('change', () => {
            drawTracks();
        });

        document.getElementById('show-markers').addEventListener('change', () => {
            drawTracks();
        });

        document.getElementById('filter-outliers').addEventListener('change', () => {
            drawTracks();
        });

        document.getElementById('show-outliers').addEventListener('change', () => {
            drawTracks();
        });

        document.getElementById('show-course').addEventListener('change', (e) => {
            showCourse = e.target.checked;
            if (showCourse && currentCourseFile) {
                // Re-load and display course
                const courseFilename = currentCourseFile;
                currentCourseFile = null;  // Reset to force reload
                loadCourse(courseFilename);
            } else {
                clearCourseDisplay();
            }
        });

        document.getElementById('show-speed-graph').addEventListener('change', (e) => {
            updateGraphPositions();
            if (e.target.checked) {
                drawSpeedGraph();
            }
        });

        document.getElementById('show-battery-graph').addEventListener('change', (e) => {
            updateGraphPositions();
            if (e.target.checked) {
                drawBatteryGraph();
            }
        });

        document.getElementById('show-signal-graph').addEventListener('change', (e) => {
            updateGraphPositions();
            if (e.target.checked) {
                drawSignalGraph();
            }
        });

        document.getElementById('show-latency-graph').addEventListener('change', (e) => {
            updateGraphPositions();
            if (e.target.checked) {
                drawLatencyGraph();
            }
        });

        document.getElementById('show-heartrate-graph').addEventListener('change', (e) => {
            updateGraphPositions();
            if (e.target.checked) {
                drawHeartRateGraph();
            }
        });

        document.getElementById('show-accuracy-graph').addEventListener('change', (e) => {
            updateGraphPositions();
            if (e.target.checked) {
                drawAccuracyGraph();
            }
        });

        document.getElementById('show-distance-graph').addEventListener('change', (e) => {
            updateGraphPositions();
            if (e.target.checked) {
                drawDistanceGraph();
            }
        });

        document.getElementById('reset-range-btn').addEventListener('click', () => {
            document.getElementById('start-slider').value = 0;
            document.getElementById('end-slider').value = 100;
            updateSliderRange();
            updateTimeDisplay();
            drawTracks();
            drawSpeedGraph();
            drawBatteryGraph();
            drawSignalGraph();
            drawLatencyGraph();
            drawHeartRateGraph();
            drawAccuracyGraph();
            drawDistanceGraph();
        });

        // Playback controls - animate through the selected range
        let playbackCurrentTime = 0;

        document.getElementById('play-btn').addEventListener('click', function() {
            if (playbackInterval) {
                clearInterval(playbackInterval);
                playbackInterval = null;
                this.textContent = '‚ñ∂ Play';
                // Reset to show full range
                drawTracks();
            } else {
                if (selectedUsers.size === 0) {
                    alert('Select at least one user to play back');
                    return;
                }

                this.textContent = '‚è∏ Pause';

                // Start playback from start of range
                playbackCurrentTime = rangeStartTime;

                playbackInterval = setInterval(() => {
                    // Advance time (playbackSpeed seconds per 100ms tick)
                    playbackCurrentTime += playbackSpeed;

                    if (playbackCurrentTime >= rangeEndTime) {
                        playbackCurrentTime = rangeEndTime;
                        clearInterval(playbackInterval);
                        playbackInterval = null;
                        document.getElementById('play-btn').textContent = '‚ñ∂ Play';
                    }

                    // Draw tracks up to current playback time
                    drawTracksUpTo(playbackCurrentTime);
                }, 100);
            }
        });

        // Draw tracks up to a specific time (for playback animation)
        function drawTracksUpTo(upToTime) {
            // Clear existing layers
            for (const layer of Object.values(trackLayers)) {
                map.removeLayer(layer);
            }
            for (const layer of Object.values(markerLayers)) {
                map.removeLayer(layer);
            }
            for (const layer of Object.values(pointLayers)) {
                map.removeLayer(layer);
            }
            for (const layer of Object.values(outlierLayers)) {
                map.removeLayer(layer);
            }
            trackLayers = {};
            markerLayers = {};
            pointLayers = {};
            outlierLayers = {};

            const useSpeedColor = document.getElementById('speed-color').checked;
            const showMarkers = document.getElementById('show-markers').checked;
            const doFilterOutliers = document.getElementById('filter-outliers').checked;

            let colorIdx = 0;
            for (const [userId, entries] of Object.entries(userData)) {
                if (!selectedUsers.has(userId)) {
                    colorIdx++;
                    continue;
                }

                const userColor = userColors[colorIdx % userColors.length];
                colorIdx++;

                // Filter: start from rangeStartTime, end at upToTime
                let timeFiltered = entries.filter(e => e.ts >= rangeStartTime && e.ts <= upToTime);
                if (timeFiltered.length < 2) continue;

                // Apply outlier filtering if enabled
                let filtered = timeFiltered;
                if (doFilterOutliers) {
                    const result = filterOutliers(timeFiltered);
                    filtered = result.filtered;
                }

                if (filtered.length < 2) continue;

                if (useSpeedColor) {
                    const layerGroup = L.layerGroup();
                    for (let i = 1; i < filtered.length; i++) {
                        const prev = filtered[i-1];
                        const curr = filtered[i];
                        const color = speedToColor(curr.spd || 0);
                        const line = L.polyline(
                            [[prev.lat, prev.lon], [curr.lat, curr.lon]],
                            { color: color, weight: 3, opacity: 0.8 }
                        );
                        layerGroup.addLayer(line);
                    }
                    layerGroup.addTo(map);
                    trackLayers[userId] = layerGroup;
                } else {
                    const coords = filtered.map(e => [e.lat, e.lon]);
                    const polyline = L.polyline(coords, {
                        color: userColor,
                        weight: 3,
                        opacity: 0.8
                    }).addTo(map);
                    trackLayers[userId] = polyline;
                }

                // Add current position marker
                if (showMarkers && filtered.length > 0) {
                    const last = filtered[filtered.length - 1];
                    const marker = L.circleMarker([last.lat, last.lon], {
                        radius: 8,
                        fillColor: userColor,
                        color: '#fff',
                        weight: 2,
                        fillOpacity: 1
                    }).addTo(map);
                    markerLayers[userId] = marker;
                }
            }

            // Update time display during playback
            document.getElementById('time-display').innerHTML =
                `<span style="color:#2ecc71">Start: ${formatTimeInTz(rangeStartTime)}</span> &nbsp;|&nbsp;` +
                `<span style="color:#f39c12">Playing: ${formatTimeInTz(upToTime)}</span> &nbsp;|&nbsp;` +
                `<span style="color:#e74c3c">End: ${formatTimeInTz(rangeEndTime)}</span>`;
        }

        document.getElementById('speed-1x').addEventListener('click', () => playbackSpeed = 1);
        document.getElementById('speed-5x').addEventListener('click', () => playbackSpeed = 5);
        document.getElementById('speed-20x').addEventListener('click', () => playbackSpeed = 20);

        document.getElementById('show-all-btn').addEventListener('click', () => {
            selectedUsers = new Set(Object.keys(userData));
            document.querySelectorAll('.user-item').forEach(el => el.classList.add('selected'));
            resetPlaybackToSelection();
            fitMapToData();
        });

        document.getElementById('hide-all-btn').addEventListener('click', () => {
            selectedUsers.clear();
            document.querySelectorAll('.user-item').forEach(el => el.classList.remove('selected'));
            resetPlaybackToSelection();
        });

        // Update live tracking link to include event ID
        const liveLink = document.getElementById('live-link');
        if (liveLink) {
            liveLink.href = `event.html?eid=${EVENT_ID}`;
        }

        // Load today's summary on start
        loadSummary();
    </script>
</body>
</html>
