<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <title>Track Review - Windsurfer Tracker</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="stylesheet" href="css/common.css" />
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; }

        #map {
            position: absolute;
            top: 60px;
            left: 0;
            right: 300px;
            bottom: 80px;
        }

        #controls {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 60px;
            background: #2c3e50;
            color: white;
            display: flex;
            align-items: center;
            padding: 0 20px;
            gap: 20px;
            z-index: 1000;
        }

        #controls label {
            font-size: 14px;
        }

        #controls select, #controls input {
            padding: 8px 12px;
            border: none;
            border-radius: 4px;
            font-size: 14px;
        }

        #controls button {
            padding: 8px 16px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }

        #controls button:hover {
            background: #2980b9;
        }

        .graphs-dropdown {
            position: relative;
            display: inline-block;
        }

        .graphs-dropdown-content {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            background: #2c3e50;
            border: 1px solid #3498db;
            border-radius: 4px;
            padding: 8px 12px;
            z-index: 1001;
            white-space: nowrap;
            margin-top: 4px;
        }

        .graphs-dropdown-content.show {
            display: block;
        }

        .graphs-dropdown-content label {
            display: block;
            padding: 4px 0;
            cursor: pointer;
        }

        .graphs-dropdown-content label:hover {
            color: #3498db;
        }

        .export-format-btn {
            width: 100%;
            padding: 6px 12px;
            margin: 2px 0;
            background: #34495e;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            text-align: left;
            font-size: 13px;
        }

        .export-format-btn:hover {
            background: #3498db;
        }

        .about-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 2000;
            justify-content: center;
            align-items: center;
        }

        .about-modal.show {
            display: flex;
        }

        .about-content {
            background: white;
            padding: 30px;
            border-radius: 8px;
            max-width: 400px;
            text-align: center;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }

        .about-content h2 {
            margin: 0 0 20px 0;
            color: #2c3e50;
        }

        .about-content p {
            margin: 15px 0;
            color: #555;
        }

        .about-content a {
            color: #3498db;
            text-decoration: none;
        }

        .about-content a:hover {
            text-decoration: underline;
        }

        .about-content button {
            margin-top: 20px;
            padding: 10px 30px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }

        .about-content button:hover {
            background: #2980b9;
        }

        #sidebar {
            position: absolute;
            top: 60px;
            right: 0;
            width: 300px;
            bottom: 80px;
            background: #f5f5f5;
            overflow-y: auto;
            padding: 15px;
            border-left: 1px solid #ddd;
        }

        #sidebar h3 {
            margin-bottom: 10px;
            color: #2c3e50;
        }

        .user-item {
            display: flex;
            align-items: center;
            padding: 10px;
            margin-bottom: 8px;
            background: white;
            border-radius: 6px;
            cursor: pointer;
            border: 2px solid transparent;
        }

        .user-item:hover {
            border-color: #3498db;
        }

        .user-item.selected {
            border-color: #2ecc71;
            background: #e8f8f0;
        }

        .user-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            margin-right: 10px;
        }

        .user-info {
            flex: 1;
        }

        .user-name {
            font-weight: bold;
            color: #2c3e50;
        }

        .user-stats {
            font-size: 12px;
            color: #666;
        }

        #timeline {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 80px;
            background: #2c3e50;
            padding: 10px 20px;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        #time-display {
            color: white;
            text-align: center;
            margin-bottom: 10px;
            font-size: 16px;
        }

        .time-slider-container {
            position: relative;
            width: 100%;
            height: 30px;
        }

        .time-slider {
            position: absolute;
            width: 100%;
            pointer-events: none;
            -webkit-appearance: none;
            appearance: none;
            height: 8px;
            background: transparent;
            top: 10px;
        }

        .time-slider::-webkit-slider-thumb {
            pointer-events: auto;
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #3498db;
            cursor: pointer;
            border-radius: 50%;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .time-slider::-moz-range-thumb {
            pointer-events: auto;
            width: 20px;
            height: 20px;
            background: #3498db;
            cursor: pointer;
            border-radius: 50%;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        #start-slider::-webkit-slider-thumb {
            background: #2ecc71;
        }

        #start-slider::-moz-range-thumb {
            background: #2ecc71;
        }

        #end-slider::-webkit-slider-thumb {
            background: #e74c3c;
        }

        #end-slider::-moz-range-thumb {
            background: #e74c3c;
        }

        .slider-track {
            position: absolute;
            width: 100%;
            height: 8px;
            background: #555;
            border-radius: 4px;
            top: 10px;
        }

        .slider-range {
            position: absolute;
            height: 8px;
            background: #3498db;
            border-radius: 4px;
            top: 10px;
        }

        .playback-indicator {
            position: absolute;
            width: 12px;
            height: 12px;
            background: #e67e22;
            border-radius: 50%;
            top: 8px;
            transform: translateX(-50%);
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            z-index: 10;
            display: none;
            pointer-events: none;
        }

        .playback-indicator.draggable {
            pointer-events: auto;
            cursor: grab;
        }

        .playback-indicator.dragging {
            cursor: grabbing;
        }

        .time-labels {
            display: flex;
            justify-content: space-between;
            color: #bdc3c7;
            font-size: 11px;
            margin-top: 5px;
        }

        #playback-controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 10px;
        }

        #playback-controls button {
            padding: 5px 15px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        .date-display {
            padding: 4px 8px;
            background: white;
            color: #333;
            border: 1px solid #ccc;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            white-space: nowrap;
        }

        .date-display:hover {
            background: #f0f0f0;
        }

        .speed-legend {
            position: fixed;
            bottom: 100px;
            left: 20px;
            background: white;
            padding: 10px;
            border-radius: 6px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            z-index: 1000;
        }

        .speed-legend h4 {
            margin-bottom: 8px;
            font-size: 12px;
        }

        .speed-gradient {
            width: 150px;
            height: 15px;
            background: linear-gradient(to right, #3498db, #2ecc71, #f1c40f, #e74c3c);
            border-radius: 3px;
        }

        .speed-labels {
            display: flex;
            justify-content: space-between;
            font-size: 10px;
            margin-top: 3px;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 20px 40px;
            border-radius: 8px;
            z-index: 2000;
            display: none;
        }

        #status {
            color: #bdc3c7;
            font-size: 12px;
        }

        /* Battery graph panel */
        #speed-graph-panel {
            position: absolute;
            bottom: 80px;
            left: 0;
            right: 300px;
            height: 150px;
            background: #1a252f;
            border-top: 1px solid #34495e;
            display: none;
        }

        #speed-graph-resize {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 8px;
            cursor: ns-resize;
            background: linear-gradient(to bottom, #34495e, transparent);
            z-index: 10;
        }

        #speed-graph-resize:hover,
        #speed-graph-resize.dragging {
            background: linear-gradient(to bottom, #3498db, transparent);
        }

        #speed-graph-resize::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 50%;
            transform: translateX(-50%);
            width: 40px;
            height: 4px;
            background: #5a6a7a;
            border-radius: 2px;
        }

        #speed-graph-resize:hover::after,
        #speed-graph-resize.dragging::after {
            background: #7a8a9a;
        }

        #speed-graph-panel.visible {
            display: block;
        }

        #speed-graph-container {
            position: relative;
            width: 100%;
            height: 100%;
            padding: 10px 50px 25px 50px;
        }

        #speed-graph {
            width: 100%;
            height: 100%;
            background: #2c3e50;
            border-radius: 4px;
        }

        .speed-graph-title {
            position: absolute;
            top: 5px;
            left: 60px;
            color: #3498db;
            font-size: 12px;
            font-weight: bold;
        }

        .speed-y-axis {
            position: absolute;
            left: 10px;
            top: 10px;
            bottom: 25px;
            width: 35px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            color: #7f8c8d;
            font-size: 11px;
            text-align: right;
            padding-right: 5px;
        }

        .speed-time-axis {
            position: absolute;
            bottom: 5px;
            left: 50px;
            right: 50px;
            display: flex;
            justify-content: space-between;
            color: #7f8c8d;
            font-size: 11px;
        }

        #battery-graph-panel {
            position: absolute;
            bottom: 80px;
            left: 0;
            right: 300px;
            height: 150px;
            background: #1a252f;
            border-top: 1px solid #34495e;
            display: none;
        }

        #battery-graph-resize {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 8px;
            cursor: ns-resize;
            background: linear-gradient(to bottom, #34495e, transparent);
            z-index: 10;
        }

        #battery-graph-resize:hover,
        #battery-graph-resize.dragging {
            background: linear-gradient(to bottom, #3498db, transparent);
        }

        #battery-graph-resize::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 50%;
            transform: translateX(-50%);
            width: 40px;
            height: 4px;
            background: #5a6a7a;
            border-radius: 2px;
        }

        #battery-graph-resize:hover::after,
        #battery-graph-resize.dragging::after {
            background: #7a8a9a;
        }

        #battery-graph-panel.visible {
            display: block;
        }

        #battery-graph-container {
            position: relative;
            width: 100%;
            height: 100%;
            padding: 10px 50px 25px 50px;
        }

        #battery-graph {
            width: 100%;
            height: 100%;
            background: #2c3e50;
            border-radius: 4px;
        }

        .battery-graph-title {
            position: absolute;
            top: 5px;
            left: 50%;
            transform: translateX(-50%);
            color: #bdc3c7;
            font-size: 12px;
            font-weight: bold;
        }

        .battery-y-axis {
            position: absolute;
            left: 10px;
            top: 10px;
            bottom: 25px;
            width: 35px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: flex-end;
            color: #95a5a6;
            font-size: 10px;
        }

        .battery-x-axis {
            position: absolute;
            bottom: 5px;
            left: 50px;
            right: 50px;
            display: flex;
            justify-content: space-between;
            color: #95a5a6;
            font-size: 10px;
        }

        /* Battery graph panel visibility is controlled by JavaScript for dynamic height */

        /* Signal graph panel */
        #signal-graph-panel {
            position: absolute;
            bottom: 80px;
            left: 0;
            right: 300px;
            height: 150px;
            background: #1a252f;
            border-top: 1px solid #34495e;
            display: none;
        }

        #signal-graph-resize {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 8px;
            cursor: ns-resize;
            background: linear-gradient(to bottom, #34495e, transparent);
            z-index: 10;
        }

        #signal-graph-resize:hover,
        #signal-graph-resize.dragging {
            background: linear-gradient(to bottom, #27ae60, transparent);
        }

        #signal-graph-resize::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 50%;
            transform: translateX(-50%);
            width: 40px;
            height: 4px;
            background: #5a6a7a;
            border-radius: 2px;
        }

        #signal-graph-resize:hover::after,
        #signal-graph-resize.dragging::after {
            background: #7a8a9a;
        }

        #signal-graph-container {
            position: relative;
            width: 100%;
            height: 100%;
            padding: 10px 50px 25px 50px;
        }

        #signal-graph {
            width: 100%;
            height: 100%;
            background: #2c3e50;
            border-radius: 4px;
        }

        .signal-graph-title {
            position: absolute;
            top: 5px;
            left: 50%;
            transform: translateX(-50%);
            color: #bdc3c7;
            font-size: 12px;
            font-weight: bold;
        }

        .signal-y-axis {
            position: absolute;
            left: 10px;
            top: 10px;
            bottom: 25px;
            width: 35px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: flex-end;
            color: #95a5a6;
            font-size: 10px;
        }

        .signal-x-axis {
            position: absolute;
            bottom: 5px;
            left: 50px;
            right: 50px;
            display: flex;
            justify-content: space-between;
            color: #95a5a6;
            font-size: 10px;
        }

        /* Latency graph panel */
        #latency-graph-panel {
            position: absolute;
            bottom: 80px;
            left: 0;
            right: 300px;
            height: 150px;
            background: #1a252f;
            border-top: 1px solid #34495e;
            display: none;
        }

        #latency-graph-resize {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 8px;
            cursor: ns-resize;
            background: linear-gradient(to bottom, #34495e, transparent);
            z-index: 10;
        }

        #latency-graph-resize:hover,
        #latency-graph-resize.dragging {
            background: linear-gradient(to bottom, #e67e22, transparent);
        }

        #latency-graph-resize::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 50%;
            transform: translateX(-50%);
            width: 40px;
            height: 4px;
            background: #5a6a7a;
            border-radius: 2px;
        }

        #latency-graph-resize:hover::after,
        #latency-graph-resize.dragging::after {
            background: #7a8a9a;
        }

        #latency-graph-container {
            position: relative;
            width: 100%;
            height: 100%;
            padding: 10px 50px 25px 50px;
        }

        #latency-graph {
            width: 100%;
            height: 100%;
            background: #2c3e50;
            border-radius: 4px;
        }

        .latency-graph-title {
            position: absolute;
            top: 5px;
            left: 50%;
            transform: translateX(-50%);
            color: #bdc3c7;
            font-size: 12px;
            font-weight: bold;
        }

        .latency-y-axis {
            position: absolute;
            left: 10px;
            top: 10px;
            bottom: 25px;
            width: 35px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: flex-end;
            color: #95a5a6;
            font-size: 10px;
        }

        .latency-x-axis {
            position: absolute;
            bottom: 5px;
            left: 50px;
            right: 50px;
            display: flex;
            justify-content: space-between;
            color: #95a5a6;
            font-size: 10px;
        }

        /* Heart rate graph panel */
        #heartrate-graph-panel {
            position: absolute;
            bottom: 80px;
            left: 0;
            right: 300px;
            height: 150px;
            background: #1a252f;
            border-top: 1px solid #34495e;
            display: none;
        }

        #heartrate-graph-resize {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 8px;
            cursor: ns-resize;
            background: linear-gradient(to bottom, #34495e, transparent);
            z-index: 10;
        }

        #heartrate-graph-resize:hover,
        #heartrate-graph-resize.dragging {
            background: linear-gradient(to bottom, #e91e63, transparent);
        }

        #heartrate-graph-resize::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 50%;
            transform: translateX(-50%);
            width: 40px;
            height: 4px;
            background: #5a6a7a;
            border-radius: 2px;
        }

        #heartrate-graph-resize:hover::after,
        #heartrate-graph-resize.dragging::after {
            background: #7a8a9a;
        }

        #heartrate-graph-container {
            position: relative;
            width: 100%;
            height: 100%;
            padding: 10px 50px 25px 50px;
        }

        #heartrate-graph {
            width: 100%;
            height: 100%;
            background: #2c3e50;
            border-radius: 4px;
        }

        .heartrate-graph-title {
            position: absolute;
            top: 5px;
            left: 50%;
            transform: translateX(-50%);
            color: #e91e63;
            font-size: 12px;
            font-weight: bold;
        }

        .heartrate-y-axis {
            position: absolute;
            left: 10px;
            top: 10px;
            bottom: 25px;
            width: 35px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: flex-end;
            color: #95a5a6;
            font-size: 10px;
        }

        .heartrate-x-axis {
            position: absolute;
            bottom: 5px;
            left: 50px;
            right: 50px;
            display: flex;
            justify-content: space-between;
            color: #95a5a6;
            font-size: 10px;
        }

        /* Accuracy graph panel */
        #accuracy-graph-panel {
            position: absolute;
            bottom: 80px;
            left: 0;
            right: 300px;
            height: 150px;
            background: #1a252f;
            border-top: 1px solid #34495e;
            display: none;
        }

        #accuracy-graph-resize {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 8px;
            cursor: ns-resize;
            background: linear-gradient(to bottom, #34495e, transparent);
            z-index: 10;
        }

        #accuracy-graph-resize:hover,
        #accuracy-graph-resize.dragging {
            background: linear-gradient(to bottom, #9b59b6, transparent);
        }

        #accuracy-graph-resize::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 50%;
            transform: translateX(-50%);
            width: 40px;
            height: 4px;
            background: #5a6a7a;
            border-radius: 2px;
        }

        #accuracy-graph-resize:hover::after,
        #accuracy-graph-resize.dragging::after {
            background: #7a8a9a;
        }

        #accuracy-graph-container {
            position: relative;
            width: 100%;
            height: 100%;
            padding: 10px 50px 25px 50px;
        }

        #accuracy-graph {
            width: 100%;
            height: 100%;
            background: #2c3e50;
            border-radius: 4px;
        }

        .accuracy-graph-title {
            position: absolute;
            top: 5px;
            left: 50%;
            transform: translateX(-50%);
            color: #9b59b6;
            font-size: 12px;
            font-weight: bold;
        }

        .accuracy-y-axis {
            position: absolute;
            left: 10px;
            top: 10px;
            bottom: 25px;
            width: 35px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: flex-end;
            color: #95a5a6;
            font-size: 10px;
        }

        .accuracy-x-axis {
            position: absolute;
            bottom: 5px;
            left: 50px;
            right: 50px;
            display: flex;
            justify-content: space-between;
            color: #95a5a6;
            font-size: 10px;
        }

        /* Distance graph panel */
        #distance-graph-panel {
            position: absolute;
            bottom: 80px;
            left: 0;
            right: 300px;
            height: 150px;
            background: #1a252f;
            border-top: 1px solid #34495e;
            display: none;
        }

        #distance-graph-resize {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 8px;
            cursor: ns-resize;
            background: linear-gradient(to bottom, #34495e, transparent);
            z-index: 10;
        }

        #distance-graph-resize:hover,
        #distance-graph-resize.dragging {
            background: linear-gradient(to bottom, #27ae60, transparent);
        }

        #distance-graph-resize::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 50%;
            transform: translateX(-50%);
            width: 40px;
            height: 4px;
            background: #5a6a7a;
            border-radius: 2px;
        }

        #distance-graph-resize:hover::after,
        #distance-graph-resize.dragging::after {
            background: #7a8a9a;
        }

        #distance-graph-container {
            position: relative;
            width: 100%;
            height: 100%;
            padding: 10px 50px 25px 50px;
        }

        #distance-graph {
            width: 100%;
            height: 100%;
            background: #2c3e50;
            border-radius: 4px;
        }

        .distance-graph-title {
            position: absolute;
            top: 5px;
            left: 50%;
            transform: translateX(-50%);
            color: #27ae60;
            font-size: 12px;
            font-weight: bold;
        }

        .distance-y-axis {
            position: absolute;
            left: 10px;
            top: 10px;
            bottom: 25px;
            width: 35px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: flex-end;
            color: #95a5a6;
            font-size: 10px;
        }

        .distance-x-axis {
            position: absolute;
            bottom: 5px;
            left: 50px;
            right: 50px;
            display: flex;
            justify-content: space-between;
            color: #95a5a6;
            font-size: 10px;
        }

        /* Hamburger menu button (hidden on desktop) */
        #sidebar-toggle {
            display: none;
            position: fixed;
            top: 70px;
            right: 15px;
            z-index: 1001;
            width: 44px;
            height: 44px;
            background: #2c3e50;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 5px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }

        #sidebar-toggle span {
            display: block;
            width: 24px;
            height: 3px;
            background: white;
            border-radius: 2px;
            transition: transform 0.3s, opacity 0.3s;
        }

        #sidebar-toggle.open span:nth-child(1) {
            transform: rotate(45deg) translate(5px, 5px);
        }
        #sidebar-toggle.open span:nth-child(2) {
            opacity: 0;
        }
        #sidebar-toggle.open span:nth-child(3) {
            transform: rotate(-45deg) translate(5px, -5px);
        }

        /* Overlay when drawer is open */
        #sidebar-overlay {
            display: none;
            position: fixed;
            top: 60px;
            left: 0;
            right: 0;
            bottom: 80px;
            background: black;
            opacity: 0;
            pointer-events: none;
            z-index: 1000;
            transition: opacity 0.3s;
        }

        #sidebar-overlay.visible {
            opacity: 0.5;
            pointer-events: auto;
        }

        /* Race selector styles */
        .race-item {
            display: flex;
            flex-direction: column;
            padding: 12px;
            margin-bottom: 8px;
            background: white;
            border-radius: 6px;
            cursor: pointer;
            border: 2px solid transparent;
        }

        .race-item:hover {
            border-color: #3498db;
        }

        .race-item.selected {
            border-color: #2ecc71;
            background: #e8f8f0;
        }

        .race-time {
            font-weight: bold;
            color: #2c3e50;
        }

        .race-stats {
            font-size: 12px;
            color: #666;
            margin-top: 4px;
        }

        #race-selector {
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px solid #ddd;
        }

        /* Mobile responsive layout */
        @media (max-width: 768px) {
            #sidebar-toggle {
                display: flex;
            }

            #sidebar-overlay {
                display: block;
            }

            #sidebar {
                position: fixed;
                right: -320px;
                transition: right 0.3s ease-in-out;
                z-index: 1002;
                box-shadow: -2px 0 10px rgba(0,0,0,0.3);
            }

            #sidebar.open {
                right: 0;
            }

            #map {
                right: 0;
                top: 110px;
                bottom: 140px;
            }

            #controls {
                position: fixed;
                flex-wrap: wrap;
                height: auto;
                min-height: 60px;
                padding: 10px;
                gap: 8px;
            }

            #controls label {
                font-size: 11px;
            }

            #controls > a {
                font-size: 11px;
                padding: 5px 8px !important;
            }

            #controls button {
                font-size: 12px;
                padding: 6px 10px;
            }

            #timeline {
                position: fixed;
                height: auto;
                min-height: 130px;
                padding: 8px 10px;
            }

            #time-display {
                font-size: 12px;
                margin-bottom: 5px;
            }

            .time-slider-container {
                height: 40px;
            }

            .time-slider::-webkit-slider-thumb {
                width: 28px;
                height: 28px;
            }

            .time-slider::-moz-range-thumb {
                width: 28px;
                height: 28px;
            }

            #playback-controls {
                flex-wrap: wrap;
                margin-top: 5px;
            }

            #playback-controls button {
                padding: 8px 10px;
                font-size: 12px;
            }

            .speed-legend {
                bottom: 150px;
                left: 10px;
                padding: 6px;
            }

            .speed-legend h4 {
                font-size: 10px;
                margin-bottom: 4px;
            }

            .speed-gradient {
                width: 100px;
                height: 10px;
            }

            .speed-labels {
                font-size: 9px;
            }

            .custom-scale {
                bottom: 150px;
                left: unset !important;
                right: 10px;
                padding: 4px 6px;
                font-size: 11px;
                width: fit-content;
            }

            .scale-bar {
                height: 6px;
                max-width: 60px !important;
            }

            #speed-graph-panel,
            #distance-graph-panel,
            #battery-graph-panel,
            #signal-graph-panel,
            #latency-graph-panel,
            #heartrate-graph-panel,
            #accuracy-graph-panel {
                right: 0;
                bottom: 130px;
            }

            .speed-graph-title,
            .distance-graph-title,
            .battery-graph-title,
            .signal-graph-title,
            .latency-graph-title,
            .heartrate-graph-title,
            .accuracy-graph-title {
                font-size: 10px;
            }

            .speed-y-axis,
            .distance-y-axis,
            .battery-y-axis,
            .signal-y-axis,
            .latency-y-axis,
            .accuracy-y-axis {
                font-size: 8px;
                width: 25px;
                left: 5px;
            }

            #speed-graph-container,
            #distance-graph-container,
            #battery-graph-container,
            #signal-graph-container,
            #latency-graph-container,
            #heartrate-graph-container,
            #accuracy-graph-container {
                padding: 8px 35px 20px 35px;
            }
        }

        /* Scale control styling */
        .custom-scale {
            position: fixed;
            bottom: 175px;
            left: 20px;
            z-index: 1001;
            background: white;
            padding: 6px 12px;
            border-radius: 6px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            font-size: 14px;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 10px;
            max-width: calc(100vw - 20px);
        }

        .scale-bar {
            height: 10px;
            background: repeating-linear-gradient(
                90deg,
                #333 0px,
                #333 25%,
                #fff 25%,
                #fff 50%
            );
            border: 2px solid #333;
            min-width: 80px;
            max-width: 200px;
        }

        .scale-text {
            white-space: nowrap;
        }

        /* Event name in header */
        .event-header-name {
            color: #f0f0f0;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            padding: 6px 12px;
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
            max-width: 300px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            display: none;
        }

        .event-header-name:hover {
            background: rgba(255,255,255,0.2);
        }

        /* Override modal header color for review page */
        .event-modal-header {
            background: #2c3e50;
        }

        /* Marker labels */
        .marker-label {
            position: absolute;
            left: 50%;
            top: 100%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.75);
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 11px;
            white-space: nowrap;
            pointer-events: none;
            margin-top: 2px;
        }
    </style>
</head>
<body>
    <!-- Event description modal -->
    <div class="event-modal-overlay" id="eventModalOverlay" onclick="hideEventModal(event)">
        <div class="event-modal" onclick="event.stopPropagation()">
            <div class="event-modal-header">
                <h2 id="eventModalTitle"></h2>
                <button class="event-modal-close" onclick="hideEventModal()">&times;</button>
            </div>
            <div class="event-modal-body">
                <p id="eventModalDescription"></p>
            </div>
            <div class="event-modal-footer">
                <a href="index.html">‚Üê Back to Events List</a>
            </div>
        </div>
    </div>

    <div id="controls">
        <a id="live-link" href="event.html" style="color:white;text-decoration:none;padding:8px 12px;background:#27ae60;border-radius:4px;margin-right:10px;">‚Üê Live Tracking</a>
        <span class="event-header-name" id="eventHeaderName" onclick="showEventModal()" title="Click for event details"></span>
        <span class="date-display" onclick="document.getElementById('date-picker').showPicker()" style="cursor:pointer;position:relative;">
            <span id="date-display"></span>
            <input type="date" id="date-picker" style="position:absolute;left:0;top:100%;width:0;height:0;border:none;padding:0;margin:0;opacity:0;">
        </span>
        <div class="graphs-dropdown">
            <button id="options-btn">Options ‚ñº</button>
            <div id="options-dropdown-content" class="graphs-dropdown-content">
                <label><input type="checkbox" id="speed-color" checked> Color by speed</label>
                <label><input type="checkbox" id="show-markers" checked> Show markers</label>
                <label><input type="checkbox" id="filter-outliers" checked> Filter outliers</label>
                <label><input type="checkbox" id="show-outliers"> Show outliers (red)</label>
                <label><input type="checkbox" id="show-course" checked> Show course</label>
                <div style="border-top:1px solid #3498db;margin:5px 0;padding-top:5px;">
                    <label style="font-size:11px;color:#aaa;margin-bottom:3px;display:block;">Map Type</label>
                    <label><input type="radio" name="map-type" value="osm" checked onchange="setMapType(this.value)"> OpenStreetMap</label>
                    <label style="display:none"><input type="radio" name="map-type" value="roads" onchange="setMapType(this.value)"> Google Roads</label>
                    <label style="display:none"><input type="radio" name="map-type" value="satellite" onchange="setMapType(this.value)"> Google Satellite</label>
                    <label style="display:none"><input type="radio" name="map-type" value="hybrid" onchange="setMapType(this.value)"> Google Hybrid</label>
                </div>
            </div>
        </div>
        <div class="graphs-dropdown">
            <button id="graphs-btn">Graphs ‚ñº</button>
            <div id="graphs-dropdown-content" class="graphs-dropdown-content">
                <label><input type="checkbox" id="show-speed-graph"> Speed</label>
                <label><input type="checkbox" id="show-distance-graph"> Distance</label>
                <label><input type="checkbox" id="show-battery-graph"> Battery</label>
                <label><input type="checkbox" id="show-signal-graph"> Signal</label>
                <label><input type="checkbox" id="show-latency-graph"> Latency</label>
                <label><input type="checkbox" id="show-heartrate-graph"> Heart Rate</label>
                <label><input type="checkbox" id="show-accuracy-graph"> Accuracy</label>
            </div>
        </div>
        <div class="graphs-dropdown">
            <button id="export-btn" style="background:#27ae60">Export ‚ñº</button>
            <div id="export-dropdown-content" class="graphs-dropdown-content">
                <label><button id="export-fit" class="export-format-btn">FIT (Garmin/Waterspeed)</button></label>
                <label><button id="export-gpx" class="export-format-btn">GPX (GPS Exchange)</button></label>
                <label><button id="export-csv" class="export-format-btn">CSV (Spreadsheet)</button></label>
                <label><button id="export-geojson" class="export-format-btn">GeoJSON (Mapping)</button></label>
            </div>
        </div>
        <button id="reload-tiles-btn" title="Reload map tiles">‚ü≥</button>
        <span id="status"></span>
    </div>

    <!-- About modal -->
    <div id="about-modal" class="about-modal">
        <div class="about-content">
            <h2>Windsurfer Tracker</h2>
            <p>GPS tracking system for windsurfing races</p>
            <p><a href="https://wstracker.org/install" target="_blank">Install App (Android/iPhone)</a></p>
            <p><a href="support.html" target="_blank">Support &amp; Help</a></p>
            <p><a href="https://github.com/tridge/windsurfer-tracker" target="_blank">Source Code on GitHub</a></p>
            <button id="about-close-btn">Close</button>
        </div>
    </div>

    <div id="map"></div>

    <div class="custom-scale" id="customScale">
        <div class="scale-bar" id="scaleBar"></div>
        <span class="scale-text" id="scaleText">100m</span>
    </div>

    <!-- Speed graph panel -->
    <div id="speed-graph-panel">
        <div id="speed-graph-resize"></div>
        <div id="speed-graph-container">
            <div class="speed-graph-title">Speed (knots)</div>
            <div class="speed-y-axis" id="speed-y-labels">
                <span>40</span>
                <span>30</span>
                <span>20</span>
                <span>10</span>
                <span>0</span>
            </div>
            <canvas id="speed-graph"></canvas>
            <div class="speed-time-axis">
                <span id="speed-time-start">--:--</span>
                <span id="speed-time-end">--:--</span>
            </div>
        </div>
    </div>

    <!-- Battery graph panel -->
    <div id="battery-graph-panel">
        <div id="battery-graph-resize"></div>
        <div id="battery-graph-container">
            <div class="battery-graph-title">Battery Level (%)</div>
            <div class="battery-y-axis" id="battery-y-labels">
                <span>100</span>
                <span>75</span>
                <span>50</span>
                <span>25</span>
                <span>0</span>
            </div>
            <canvas id="battery-graph"></canvas>
            <div class="battery-x-axis">
                <span id="battery-time-start">--:--</span>
                <span id="battery-time-end">--:--</span>
            </div>
        </div>
    </div>

    <!-- Signal graph panel -->
    <div id="signal-graph-panel">
        <div id="signal-graph-resize"></div>
        <div id="signal-graph-container">
            <div class="signal-graph-title">Signal Strength</div>
            <div class="signal-y-axis">
                <span>4</span>
                <span>3</span>
                <span>2</span>
                <span>1</span>
                <span>0</span>
            </div>
            <canvas id="signal-graph"></canvas>
            <div class="signal-x-axis">
                <span id="signal-time-start">--:--</span>
                <span id="signal-time-end">--:--</span>
            </div>
        </div>
    </div>

    <!-- Latency graph panel -->
    <div id="latency-graph-panel">
        <div id="latency-graph-resize"></div>
        <div id="latency-graph-container">
            <div class="latency-graph-title">Network Latency (seconds)</div>
            <div class="latency-y-axis" id="latency-y-labels">
                <span>10</span>
                <span>7.5</span>
                <span>5</span>
                <span>2.5</span>
                <span>0</span>
            </div>
            <canvas id="latency-graph"></canvas>
            <div class="latency-x-axis">
                <span id="latency-time-start">--:--</span>
                <span id="latency-time-end">--:--</span>
            </div>
        </div>
    </div>

    <!-- Heart rate graph panel -->
    <div id="heartrate-graph-panel">
        <div id="heartrate-graph-resize"></div>
        <div id="heartrate-graph-container">
            <div class="heartrate-graph-title">Heart Rate (bpm)</div>
            <div class="heartrate-y-axis" id="heartrate-y-labels">
                <span>200</span>
                <span>150</span>
                <span>100</span>
                <span>50</span>
                <span>0</span>
            </div>
            <canvas id="heartrate-graph"></canvas>
            <div class="heartrate-x-axis">
                <span id="heartrate-time-start">--:--</span>
                <span id="heartrate-time-end">--:--</span>
            </div>
        </div>
    </div>

    <!-- Accuracy graph panel -->
    <div id="accuracy-graph-panel">
        <div id="accuracy-graph-resize"></div>
        <div id="accuracy-graph-container">
            <div class="accuracy-graph-title">GPS Accuracy (meters)</div>
            <div class="accuracy-y-axis" id="accuracy-y-labels">
                <span>100</span>
                <span>75</span>
                <span>50</span>
                <span>25</span>
                <span>0</span>
            </div>
            <canvas id="accuracy-graph"></canvas>
            <div class="accuracy-x-axis">
                <span id="accuracy-time-start">--:--</span>
                <span id="accuracy-time-end">--:--</span>
            </div>
        </div>
    </div>

    <!-- Distance graph panel -->
    <div id="distance-graph-panel">
        <div id="distance-graph-resize"></div>
        <div id="distance-graph-container">
            <div class="distance-graph-title">Distance (meters)</div>
            <div class="distance-y-axis" id="distance-y-labels">
                <span>10000</span>
                <span>7500</span>
                <span>5000</span>
                <span>2500</span>
                <span>0</span>
            </div>
            <canvas id="distance-graph"></canvas>
            <div class="distance-x-axis">
                <span id="distance-time-start">--:--</span>
                <span id="distance-time-end">--:--</span>
            </div>
        </div>
    </div>

    <!-- Hamburger menu button (mobile only) -->
    <button id="sidebar-toggle" aria-label="Toggle sidebar">
        <span></span>
        <span></span>
        <span></span>
    </button>

    <!-- Overlay when drawer is open (mobile only) -->
    <div id="sidebar-overlay"></div>

    <div id="sidebar">
        <div id="timezone-display" style="display:none;background:#e8f4fd;border-radius:4px;padding:8px 12px;margin-bottom:12px;font-size:13px;color:#1e40af;">
            <strong>Timezone:</strong> <span id="event-timezone">-</span>
        </div>
        <div id="race-selector">
            <h3>Select Log</h3>
            <div id="race-list">
                <p style="color:#666">Select a date to see logs</p>
            </div>
        </div>
        <h3>Users</h3>
        <div style="margin-bottom:10px;">
            <button id="show-all-btn" style="padding:5px 10px;margin-right:5px;">Show All</button>
            <button id="hide-all-btn" style="padding:5px 10px;">Hide All</button>
        </div>
        <div id="user-list">
            <p style="color:#666">Select a log to see users</p>
        </div>
    </div>

    <div id="timeline">
        <div id="time-display">
            <span style="color:#2ecc71">Start: --:--:--</span> &nbsp;|&nbsp;
            <span style="color:#e74c3c">End: --:--:--</span> &nbsp;|&nbsp;
            Duration: --:--
        </div>
        <div class="time-slider-container">
            <div class="slider-track"></div>
            <div class="slider-range" id="slider-range"></div>
            <div class="playback-indicator" id="playback-indicator"></div>
            <input type="range" class="time-slider" id="start-slider" min="0" max="100" value="0" step="any">
            <input type="range" class="time-slider" id="end-slider" min="0" max="100" value="100" step="any">
        </div>
        <div class="time-labels">
            <span id="label-start">--:--:--</span>
            <span id="label-end">--:--:--</span>
        </div>
        <div id="playback-controls">
            <button id="play-btn">‚ñ∂ Play</button>
            <button id="speed-1x" class="speed-btn">1x</button>
            <button id="speed-5x" class="speed-btn">5x</button>
            <button id="speed-20x" class="speed-btn">20x</button>
            <button id="reset-range-btn" style="background:#95a5a6" title="Reset time range">‚ü≤</button>
            <button id="copy-link-btn" style="background:#9b59b6" title="Copy shareable link">üìã</button>
            <button id="about-btn" style="background:#7f8c8d" title="About">‚Ñπ</button>
        </div>
    </div>

    <div class="speed-legend">
        <h4>Speed (knots)</h4>
        <div class="speed-gradient"></div>
        <div class="speed-labels">
            <span>0</span>
            <span>7.5</span>
            <span>15</span>
        </div>
    </div>

    <div id="loading">Loading tracks...</div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet.gridlayer.googlemutant@0.14.1/dist/Leaflet.GoogleMutant.js"></script>
    <!-- Google Maps API key (optional - create config.js from config.js.example) -->
    <script>
        var GMAPS_API_KEY = null;
    </script>
    <script src="config.js" onerror=""></script>
    <script>
        // Load Google Maps API dynamically if API key is configured
        if (GMAPS_API_KEY && GMAPS_API_KEY !== 'YOUR_API_KEY_HERE') {
            var script = document.createElement('script');
            script.src = 'https://maps.googleapis.com/maps/api/js?key=' + GMAPS_API_KEY + '&loading=async';
            script.async = true;
            document.head.appendChild(script);
        }
    </script>
    <script src="js/utils.js"></script>
    <script src="js/modal.js"></script>
    <script>
        // Event ID from URL parameter (default to 2)
        const urlParams = new URLSearchParams(window.location.search);
        const EVENT_ID = parseInt(urlParams.get('eid')) || 2;
        const DATA_BASE = `${EVENT_ID}/`;

        // Store event info for modal (used by modal.js)
        let currentEventInfo = null;

        // Event timezone (defaults to local, updated when event info is fetched)
        let eventTimezone = Intl.DateTimeFormat().resolvedOptions().timeZone;

        // Get today's date in event timezone (for date picker)
        function getTodayInEventTz() {
            // Get current date parts in event timezone
            const parts = new Date().toLocaleDateString('en-CA', { timeZone: eventTimezone });
            return parts; // Format: YYYY-MM-DD (en-CA gives ISO format)
        }

        // Format date as "DD Mon YYYY" for consistent display across platforms
        const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
        function formatDateDisplay(dateStr) {
            // Input: YYYY-MM-DD or YYYY_MM_DD
            const normalized = dateStr.replace(/_/g, '-');
            const parts = normalized.split('-');
            if (parts.length !== 3) return dateStr;
            const year = parts[0];
            const month = parseInt(parts[1], 10) - 1;
            const day = parseInt(parts[2], 10);
            return `${day} ${monthNames[month]} ${year}`;
        }

        // Format time in event timezone
        function formatTimeInTz(ts) {
            return new Date(ts * 1000).toLocaleTimeString([], {
                timeZone: eventTimezone,
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit'
            });
        }

        function formatTimeShortInTz(ts) {
            return new Date(ts * 1000).toLocaleTimeString([], {
                timeZone: eventTimezone,
                hour: '2-digit',
                minute: '2-digit'
            });
        }

        // Build shareable URL with current view state
        function buildShareableUrl() {
            const params = new URLSearchParams();

            // Event ID
            params.set('eid', EVENT_ID);

            // Map state
            const center = map.getCenter();
            params.set('lat', center.lat.toFixed(6));
            params.set('lon', center.lng.toFixed(6));
            params.set('z', map.getZoom());

            // Date
            const dateStr = document.getElementById('date-picker').value;
            if (dateStr) params.set('date', dateStr);

            // Selected log (by start timestamp for stability across rotations)
            if (currentLogStartTs) params.set('logts', currentLogStartTs);

            // Selected users
            if (selectedUsers.size > 0) {
                params.set('users', Array.from(selectedUsers).join(','));
            }

            // Time range (as percentages of global log range for stable URLs)
            const startPercent = timeToGlobalPercent(rangeStartTime);
            const endPercent = timeToGlobalPercent(rangeEndTime);
            if (startPercent > 0.01 || endPercent < 99.99) {
                params.set('start', startPercent.toFixed(2));
                params.set('end', endPercent.toFixed(2));
            }

            // Options
            if (!document.getElementById('speed-color').checked) params.set('nospeedcolor', '1');
            if (!document.getElementById('show-markers').checked) params.set('nomarkers', '1');
            if (!document.getElementById('filter-outliers').checked) params.set('nofilter', '1');
            if (document.getElementById('show-outliers').checked) params.set('showoutliers', '1');
            if (!document.getElementById('show-course').checked) params.set('nocourse', '1');

            // Graphs
            const graphs = [];
            if (document.getElementById('show-speed-graph').checked) graphs.push('speed');
            if (document.getElementById('show-distance-graph').checked) graphs.push('distance');
            if (document.getElementById('show-battery-graph').checked) graphs.push('battery');
            if (document.getElementById('show-signal-graph').checked) graphs.push('signal');
            if (document.getElementById('show-latency-graph').checked) graphs.push('latency');
            if (document.getElementById('show-heartrate-graph').checked) graphs.push('heartrate');
            if (document.getElementById('show-accuracy-graph').checked) graphs.push('accuracy');
            if (graphs.length > 0) params.set('graphs', graphs.join(','));

            // Build URL
            const url = new URL(window.location.href);
            url.search = params.toString();
            return url.toString();
        }

        // Parse URL params and restore state (called after data loads)
        function restoreStateFromUrl() {
            const params = new URLSearchParams(window.location.search);

            // Map position
            const lat = parseFloat(params.get('lat'));
            const lon = parseFloat(params.get('lon'));
            const zoom = parseInt(params.get('z'));
            if (!isNaN(lat) && !isNaN(lon) && !isNaN(zoom)) {
                map.setView([lat, lon], zoom);
            }

            // Options (apply before loading data)
            if (params.has('nospeedcolor')) document.getElementById('speed-color').checked = false;
            if (params.has('nomarkers')) document.getElementById('show-markers').checked = false;
            if (params.has('nofilter')) document.getElementById('filter-outliers').checked = false;
            if (params.has('showoutliers')) document.getElementById('show-outliers').checked = true;
            if (params.has('nocourse')) document.getElementById('show-course').checked = false;

            // Graphs
            if (params.has('graphs')) {
                const graphs = params.get('graphs').split(',');
                if (graphs.includes('speed')) document.getElementById('show-speed-graph').checked = true;
                if (graphs.includes('distance')) document.getElementById('show-distance-graph').checked = true;
                if (graphs.includes('battery')) document.getElementById('show-battery-graph').checked = true;
                if (graphs.includes('signal')) document.getElementById('show-signal-graph').checked = true;
                if (graphs.includes('latency')) document.getElementById('show-latency-graph').checked = true;
                if (graphs.includes('heartrate')) document.getElementById('show-heartrate-graph').checked = true;
                if (graphs.includes('accuracy')) document.getElementById('show-accuracy-graph').checked = true;
                updateGraphPositions();
            }

            return params;
        }

        // Restore state that depends on loaded data
        function restoreDataDependentState(params) {
            // First restore selected users (affects slider range)
            if (params.has('users')) {
                const users = params.get('users').split(',');
                for (const userId of users) {
                    if (userData[userId]) {
                        selectedUsers.add(userId);
                        // Update UI to show selection
                        const userDiv = document.querySelector(`.user-item[data-user-id="${userId}"]`);
                        if (userDiv) {
                            userDiv.classList.add('selected');
                        }
                    }
                }
            }

            // Update slider endpoints based on selected users
            updateSliderEndpoints();

            // Time range (URL stores percentages of global log range)
            if (params.has('start') || params.has('end')) {
                const startPercent = parseFloat(params.get('start') || '0');
                const endPercent = parseFloat(params.get('end') || '100');

                // Convert global percentages to timestamps
                rangeStartTime = globalPercentToTime(startPercent);
                rangeEndTime = globalPercentToTime(endPercent);

                // Update slider positions (will use current sliderMinTime/sliderMaxTime)
                const startSlider = document.getElementById('start-slider');
                const endSlider = document.getElementById('end-slider');

                // Clamp to slider range and convert to slider percentage
                const clampedStart = Math.max(sliderMinTime, Math.min(sliderMaxTime, rangeStartTime));
                const clampedEnd = Math.max(sliderMinTime, Math.min(sliderMaxTime, rangeEndTime));
                rangeStartTime = clampedStart;
                rangeEndTime = clampedEnd;

                startSlider.value = timeToSliderValue(clampedStart);
                endSlider.value = timeToSliderValue(clampedEnd);

                updateSliderRange();
                updateTimeDisplay();
            }
        }

        // Fetch event name and update page title + header
        (async function() {
            try {
                const response = await fetch('/api/events');
                if (response.ok) {
                    const data = await response.json();
                    const event = data.events.find(e => e.eid === EVENT_ID);
                    if (event && event.name) {
                        currentEventInfo = event;
                        document.title = `${event.name} - Track Review`;
                        const headerEl = document.getElementById('eventHeaderName');
                        headerEl.textContent = event.name;
                        headerEl.style.display = 'inline-block';

                        // Display and use event timezone
                        if (event.timezone) {
                            eventTimezone = event.timezone;
                            document.getElementById('event-timezone').textContent = event.timezone;
                            document.getElementById('timezone-display').style.display = 'block';
                            // Update date picker to use event timezone (only if no URL date param)
                            const urlDateParams = new URLSearchParams(window.location.search);
                            if (!urlDateParams.has('date')) {
                                document.getElementById('date-picker').value = getTodayInEventTz();
                                updateDateDisplay();
                            }
                        }

                        // Center map on event home location if available (only if URL doesn't specify position)
                        const urlPosParams = new URLSearchParams(window.location.search);
                        if (event.home_lat && event.home_lon && !urlPosParams.has('lat')) {
                            map.setView([event.home_lat, event.home_lon], 13);
                        }
                    }
                }
            } catch (e) {
                console.error('Failed to fetch event name:', e);
            }
        })();

        // Initialize map with fractional zoom for finer scroll wheel control
        const map = L.map('map', {
            zoomSnap: 0.25,      // Allow fractional zoom levels (0.25 increments)
            zoomDelta: 0.5,      // Smaller zoom steps per scroll event
            wheelPxPerZoomLevel: 120  // Pixels of scrolling per zoom level
        }).setView([-36.85, 174.88], 13);

        // Map layers
        const osmLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; OpenStreetMap contributors',
            maxZoom: 19
        });
        let googleLayers = {};
        let currentMapType = localStorage.getItem('mapType') || 'osm';
        let currentLayer = null;

        // Initialize map layers after Google Maps API loads
        function initMapLayers() {
            if (GMAPS_API_KEY && GMAPS_API_KEY !== 'YOUR_API_KEY_HERE' && typeof google !== 'undefined') {
                // Enable Google Maps radio options
                document.querySelectorAll('input[name="map-type"][value="roads"], input[name="map-type"][value="satellite"], input[name="map-type"][value="hybrid"]').forEach(el => {
                    el.parentElement.style.display = '';
                });

                // Create Google layers for each type
                googleLayers.roads = L.gridLayer.googleMutant({ type: 'roadmap', maxZoom: 21 });
                googleLayers.satellite = L.gridLayer.googleMutant({ type: 'satellite', maxZoom: 21 });
                googleLayers.hybrid = L.gridLayer.googleMutant({ type: 'hybrid', maxZoom: 21 });

                // Apply saved map type
                setMapType(currentMapType);
            } else {
                // No Google Maps available, use OSM only
                osmLayer.addTo(map);
                currentLayer = osmLayer;
                currentMapType = 'osm';
            }
        }

        function setMapType(mapType) {
            // Remove current layer
            if (currentLayer) {
                map.removeLayer(currentLayer);
            }

            // Add new layer
            if (mapType === 'osm') {
                currentLayer = osmLayer;
            } else if (googleLayers[mapType]) {
                currentLayer = googleLayers[mapType];
            } else {
                // Fallback to OSM
                currentLayer = osmLayer;
                mapType = 'osm';
            }
            currentLayer.addTo(map);
            currentMapType = mapType;
            localStorage.setItem('mapType', mapType);

            // Update radio button selection
            const radio = document.querySelector(`input[name="map-type"][value="${mapType}"]`);
            if (radio) radio.checked = true;
        }

        // Initialize layers - wait for Google Maps to load if configured
        if (GMAPS_API_KEY && GMAPS_API_KEY !== 'YOUR_API_KEY_HERE') {
            // Wait for Google Maps to load
            const checkGoogle = setInterval(() => {
                if (typeof google !== 'undefined') {
                    clearInterval(checkGoogle);
                    initMapLayers();
                }
            }, 100);
            // Timeout fallback - use OSM if Google doesn't load
            setTimeout(() => {
                clearInterval(checkGoogle);
                if (!currentLayer) {
                    osmLayer.addTo(map);
                    currentLayer = osmLayer;
                }
            }, 5000);
        } else {
            osmLayer.addTo(map);
            currentLayer = osmLayer;
        }

        // Custom scale control
        function updateScale() {
            const center = map.getCenter();
            const zoom = map.getZoom();

            // Calculate meters per pixel at current zoom and latitude
            // At zoom 0, the world is 256 pixels wide = 40075km at equator
            const metersPerPixel = 40075016.686 * Math.cos(center.lat * Math.PI / 180) / Math.pow(2, zoom + 8);

            // Find a nice round distance that fits in ~80-200 pixels
            const distances = [10, 20, 50, 100, 200, 500, 1000, 2000, 5000, 10000, 20000, 50000];
            let bestDist = distances[0];
            let bestWidth = bestDist / metersPerPixel;

            for (const dist of distances) {
                const width = dist / metersPerPixel;
                if (width >= 80 && width <= 200) {
                    bestDist = dist;
                    bestWidth = width;
                    break;
                }
                if (width < 200) {
                    bestDist = dist;
                    bestWidth = width;
                }
            }

            // Update the scale bar
            document.getElementById('scaleBar').style.width = bestWidth + 'px';

            // Format the distance text
            let text;
            if (bestDist >= 1000) {
                text = (bestDist / 1000) + ' km';
            } else {
                text = bestDist + ' m';
            }
            document.getElementById('scaleText').textContent = text;
        }

        // Update scale on zoom/move
        map.on('zoomend', updateScale);
        map.on('moveend', updateScale);
        updateScale();  // Initial update

        // State
        let allData = [];
        let userData = {};
        let userOverrides = {};  // Name mappings from users.json
        let trackLayers = {};
        let markerLayers = {};
        let pointLayers = {};
        let outlierLayers = {};  // Outlier markers per user
        let cachedDistanceData = {};  // Cached distance calculations for hover display
        let trackHoverPopup = null;  // Popup shown when hovering over track
        let selectedUsers = new Set();
        let playbackInterval = null;
        let playbackSpeed = 1;
        let minTime = 0;
        let maxTime = 0;
        let rangeStartTime = 0;  // User-selected start time
        let rangeEndTime = 0;    // User-selected end time
        let sliderMinTime = 0;   // Current slider min (selected users' min or global)
        let sliderMaxTime = 0;   // Current slider max (selected users' max or global)
        let currentSummary = null;  // Summary data for selected date
        let currentLogFile = null;  // Currently loaded log file
        let currentLogStartTs = null;  // Start timestamp of current log (for stable URLs)
        let sliderDebounceTimer = null;  // Debounce timer for slider redraw
        let courseMarkers = [];  // Course marker layers
        let courseLines = [];    // Course line layers
        let showCourse = true;   // Whether to display course
        let currentCourseFile = null;  // Currently loaded course filename

        // Expand log entry - handles both old format (lat/lon direct) and new format (pos array)
        function expandEntry(entry) {
            if (entry.pos && Array.isArray(entry.pos)) {
                // Compact format: pos array [[ts, lat, lon], ...] or [[ts, lat, lon, spd], ...]
                // Expand into individual entries, each inheriting all metadata
                return entry.pos.map(p => ({
                    id: entry.id,
                    ts: p[0],
                    lat: p[1],
                    lon: p[2],
                    spd: p.length >= 4 ? p[3] : entry.spd,  // Use per-point speed if available
                    hdg: entry.hdg,
                    bat: entry.bat,
                    sig: entry.sig,
                    hr: entry.hr,
                    hac: entry.hac,
                    role: entry.role,
                    ver: entry.ver,
                    flg: entry.flg,
                    ast: entry.ast,
                    bdr: entry.bdr,
                    os: entry.os,
                    recv_ts: entry.recv_ts
                }));
            }
            // Old format: single position with lat/lon directly
            return [entry];
        }

        // Course display functions
        function clearCourseDisplay() {
            courseMarkers.forEach(m => map.removeLayer(m));
            courseMarkers = [];
            courseLines.forEach(l => map.removeLayer(l));
            courseLines = [];
        }

        function displayCourse(course) {
            clearCourseDisplay();
            if (!showCourse) return;

            const points = [];

            // Start marker
            if (course.start) {
                const marker = L.marker([course.start.lat, course.start.lon], {
                    icon: createStartIcon()
                }).addTo(map);
                marker.bindPopup('<strong>Start</strong>');
                courseMarkers.push(marker);
                points.push([course.start.lat, course.start.lon]);
            }

            // Mark markers
            if (course.marks) {
                course.marks.forEach((mark, idx) => {
                    const color = mark.color || '#f97316';
                    const label = mark.comment || null;
                    const marker = L.marker([mark.lat, mark.lon], {
                        icon: createMarkIcon(idx + 1, color, label)
                    }).addTo(map);

                    // Build popup with mark info
                    let popupContent = `<strong>Mark ${idx + 1}</strong>`;
                    if (mark.comment) {
                        popupContent += `<br><em>${mark.comment}</em>`;
                    }
                    marker.bindPopup(popupContent);

                    courseMarkers.push(marker);
                    points.push([mark.lat, mark.lon]);
                });
            }

            // Finish marker
            if (course.finish) {
                const marker = L.marker([course.finish.lat, course.finish.lon], {
                    icon: createFinishIcon()
                }).addTo(map);
                marker.bindPopup('<strong>Finish</strong>');
                courseMarkers.push(marker);
                points.push([course.finish.lat, course.finish.lon]);
            }

            // Course line
            if (points.length >= 2) {
                const line = L.polyline(points, {
                    color: '#ff6600',
                    weight: 3,
                    opacity: 0.7,
                    dashArray: '10, 5'
                }).addTo(map);
                courseLines.push(line);
            }
        }

        // Course marker icons
        function createStartIcon() {
            const svg = `
                <svg width="32" height="32" viewBox="-16 -16 32 32" xmlns="http://www.w3.org/2000/svg">
                    <circle cx="0" cy="0" r="12" fill="#22c55e" stroke="#166534" stroke-width="2"/>
                    <text x="0" y="5" text-anchor="middle" fill="white" font-size="12" font-weight="bold">S</text>
                </svg>
            `;
            return L.divIcon({
                html: svg,
                className: 'course-marker',
                iconSize: [32, 32],
                iconAnchor: [16, 16]
            });
        }

        // Darken a hex color by reducing RGB values ~30%
        function darkenColor(hex) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            const darken = (v) => Math.max(0, Math.floor(v * 0.7)).toString(16).padStart(2, '0');
            return `#${darken(r)}${darken(g)}${darken(b)}`;
        }

        function createMarkIcon(number, color = '#f97316', label = null) {
            const strokeColor = darkenColor(color);
            const svg = `
                <svg width="32" height="32" viewBox="-16 -16 32 32" xmlns="http://www.w3.org/2000/svg">
                    <circle cx="0" cy="0" r="12" fill="${color}" stroke="${strokeColor}" stroke-width="2"/>
                    <text x="0" y="5" text-anchor="middle" fill="white" font-size="11" font-weight="bold">${number}</text>
                </svg>
            `;
            const labelHtml = label ? `<div class="marker-label">${label}</div>` : '';
            return L.divIcon({
                html: `<div style="position:relative">${svg}${labelHtml}</div>`,
                className: 'course-marker',
                iconSize: [32, 32 + (label ? 20 : 0)],
                iconAnchor: [16, 16]
            });
        }

        function createFinishIcon() {
            const svg = `
                <svg width="32" height="32" viewBox="-16 -16 32 32" xmlns="http://www.w3.org/2000/svg">
                    <!-- Checkered flag pattern -->
                    <rect x="-12" y="-12" width="24" height="24" fill="white" stroke="#333" stroke-width="2" rx="3"/>
                    <rect x="-12" y="-12" width="6" height="6" fill="#333"/>
                    <rect x="0" y="-12" width="6" height="6" fill="#333"/>
                    <rect x="-6" y="-6" width="6" height="6" fill="#333"/>
                    <rect x="6" y="-6" width="6" height="6" fill="#333"/>
                    <rect x="-12" y="0" width="6" height="6" fill="#333"/>
                    <rect x="0" y="0" width="6" height="6" fill="#333"/>
                    <rect x="-6" y="6" width="6" height="6" fill="#333"/>
                    <rect x="6" y="6" width="6" height="6" fill="#333"/>
                </svg>
            `;
            return L.divIcon({
                html: svg,
                className: 'course-marker',
                iconSize: [32, 32],
                iconAnchor: [16, 16]
            });
        }

        async function loadCourse(courseFilename) {
            if (!courseFilename || courseFilename === currentCourseFile) {
                return;
            }
            try {
                const courseUrl = `${DATA_BASE}${courseFilename}`;
                const response = await fetch(courseUrl);
                if (response.ok) {
                    const courseData = await response.json();
                    currentCourseFile = courseFilename;
                    displayCourse(courseData);
                } else {
                    clearCourseDisplay();
                    currentCourseFile = null;
                }
            } catch (e) {
                console.log('Error loading course:', e);
                clearCourseDisplay();
                currentCourseFile = null;
            }
        }

        // Mobile drawer toggle
        const sidebarToggle = document.getElementById('sidebar-toggle');
        const sidebar = document.getElementById('sidebar');
        const sidebarOverlay = document.getElementById('sidebar-overlay');

        function toggleSidebar() {
            sidebar.classList.toggle('open');
            sidebarToggle.classList.toggle('open');
            sidebarOverlay.classList.toggle('visible');
        }

        function closeSidebarIfMobile() {
            if (window.innerWidth <= 768) {
                sidebar.classList.remove('open');
                sidebarToggle.classList.remove('open');
                sidebarOverlay.classList.remove('visible');
            }
        }

        sidebarToggle.addEventListener('click', toggleSidebar);
        sidebarOverlay.addEventListener('click', toggleSidebar);

        // Calculate distance between two points using Haversine formula (returns km)
        function haversineDistance(lat1, lon1, lat2, lon2) {
            const R = 6371; // Earth's radius in km
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                      Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                      Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }

        // Filter outliers from track positions using physics-based detection
        function filterOutliers(positions) {
            const SPEED_MARGIN_KNOTS = 20;
            const filtered = [];
            const outliers = [];

            for (let i = 0; i < positions.length; i++) {
                const pos = positions[i];

                if (i === 0) {
                    filtered.push(pos);
                    continue;
                }

                const prev = positions[i - 1];
                const timeDelta = pos.ts - prev.ts;

                if (timeDelta > 0) {
                    const distanceKm = haversineDistance(prev.lat, prev.lon, pos.lat, pos.lon);
                    const distanceM = distanceKm * 1000;
                    const impliedSpeedMs = distanceM / timeDelta;
                    const impliedSpeedKnots = impliedSpeedMs * 1.94384;
                    const prevSpeedKnots = (prev.spd || 0);  // spd is already in knots
                    const currSpeedKnots = (pos.spd || 0);   // spd is already in knots
                    const maxAllowed = Math.max(prevSpeedKnots, currSpeedKnots) + SPEED_MARGIN_KNOTS;

                    if (impliedSpeedKnots > maxAllowed) {
                        outliers.push(pos);
                        continue;
                    }
                }

                filtered.push(pos);
            }

            return { filtered, outliers };
        }

        // Load user overrides (name mappings)
        async function loadUserOverrides() {
            try {
                const response = await fetch(`${DATA_BASE}users.json?` + Date.now());
                if (response.ok) {
                    const data = await response.json();
                    userOverrides = data.users || {};
                }
            } catch (e) {
                console.log('No users.json found');
            }
        }

        // Get display name for a user ID
        function getDisplayName(userId) {
            if (userOverrides[userId] && userOverrides[userId].name) {
                return userOverrides[userId].name;
            }
            return userId;
        }

        // Load user overrides on startup
        loadUserOverrides();

        // User colors
        const userColors = [
            '#e74c3c', '#3498db', '#2ecc71', '#9b59b6', '#f39c12',
            '#1abc9c', '#e91e63', '#00bcd4', '#ff5722', '#795548'
        ];

        // Speed scale max (updated dynamically based on data)
        let speedScaleMax = 15;

        // Speed to color (0 to speedScaleMax knots)
        function speedToColor(speedKnots) {
            const knots = speedKnots;  // spd is already in knots
            const ratio = Math.min(knots / speedScaleMax, 1);

            if (ratio < 0.33) {
                // Blue to green
                const t = ratio / 0.33;
                return interpolateColor('#3498db', '#2ecc71', t);
            } else if (ratio < 0.66) {
                // Green to yellow
                const t = (ratio - 0.33) / 0.33;
                return interpolateColor('#2ecc71', '#f1c40f', t);
            } else {
                // Yellow to red
                const t = (ratio - 0.66) / 0.34;
                return interpolateColor('#f1c40f', '#e74c3c', t);
            }
        }

        function interpolateColor(c1, c2, t) {
            const r1 = parseInt(c1.slice(1,3), 16);
            const g1 = parseInt(c1.slice(3,5), 16);
            const b1 = parseInt(c1.slice(5,7), 16);
            const r2 = parseInt(c2.slice(1,3), 16);
            const g2 = parseInt(c2.slice(3,5), 16);
            const b2 = parseInt(c2.slice(5,7), 16);

            const r = Math.round(r1 + (r2 - r1) * t);
            const g = Math.round(g1 + (g2 - g1) * t);
            const b = Math.round(b1 + (b2 - b1) * t);

            return `rgb(${r},${g},${b})`;
        }

        // Open date picker (with fallback for browsers without showPicker)
        function openDatePicker() {
            const picker = document.getElementById('date-picker');
            if (picker.showPicker) {
                picker.showPicker();
            } else {
                picker.focus();
                picker.click();
            }
        }

        // Update date display when picker changes
        function updateDateDisplay() {
            const dateStr = document.getElementById('date-picker').value;
            document.getElementById('date-display').textContent = dateStr ? formatDateDisplay(dateStr) : 'Select date';
        }
        document.getElementById('date-picker').addEventListener('change', () => {
            updateDateDisplay();
            loadSummary();  // Auto-load when date changes
        });

        // Set date: use URL param if provided, otherwise today in event timezone
        const initDateParams = new URLSearchParams(window.location.search);
        if (initDateParams.has('date')) {
            document.getElementById('date-picker').value = initDateParams.get('date');
        } else {
            document.getElementById('date-picker').value = getTodayInEventTz();
        }
        updateDateDisplay();  // Initialize display

        // Load summary for a date (phase 1)
        async function loadSummary() {
            const dateStr = document.getElementById('date-picker').value;
            if (!dateStr) return;

            document.getElementById('loading').style.display = 'block';
            document.getElementById('status').textContent = 'Loading summary...';

            const dateParts = dateStr.split('-');
            const logDate = `${dateParts[0]}_${dateParts[1]}_${dateParts[2]}`;

            // Clear previous state
            currentSummary = null;
            currentLogFile = null;
            currentLogStartTs = null;
            allData = [];
            userData = {};
            selectedUsers = new Set();
            document.getElementById('user-list').innerHTML = '<p style="color:#666">Select a log to see users</p>';

            try {
                // Try to fetch summary file
                const summaryUrl = `${DATA_BASE}logs/${logDate}_summary.json?${Date.now()}`;
                const response = await fetch(summaryUrl);

                if (response.ok) {
                    currentSummary = await response.json();
                    updateRaceList();
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('status').textContent = `Found ${currentSummary.logs.length} log(s) for this date`;
                } else {
                    // No summary file - fall back to direct loading
                    document.getElementById('race-list').innerHTML = '<p style="color:#666">No summary available - loading all data...</p>';
                    await loadTracksLegacy(logDate);
                }
            } catch (e) {
                console.error('Error loading summary:', e);
                document.getElementById('loading').style.display = 'none';
                document.getElementById('status').textContent = 'Error loading data';
                document.getElementById('race-list').innerHTML = '<p style="color:#666">Error loading logs</p>';
            }
        }

        // Update race list UI
        function updateRaceList() {
            const container = document.getElementById('race-list');
            container.innerHTML = '';

            if (!currentSummary || !currentSummary.logs || currentSummary.logs.length === 0) {
                container.innerHTML = '<p style="color:#666">No logs found</p>';
                return;
            }

            // Logs are already sorted by start_ts descending in the summary
            currentSummary.logs.forEach((log, index) => {
                const div = document.createElement('div');
                div.className = 'race-item';
                div.dataset.index = index;

                const startTime = formatTimeInTz(log.start_ts);
                const endTime = formatTimeInTz(log.end_ts);
                const duration = Math.round((log.end_ts - log.start_ts) / 60);
                const sailorCount = Object.keys(log.sailors).length;

                div.innerHTML = `
                    <div class="race-time">Log ${currentSummary.logs.length - index}: ${startTime} - ${endTime}</div>
                    <div class="race-stats">
                        Duration: ${duration} min | ${sailorCount} sailors | ${log.point_count.toLocaleString()} points
                    </div>
                `;

                div.addEventListener('click', () => {
                    // Clear previous selection
                    container.querySelectorAll('.race-item').forEach(el => el.classList.remove('selected'));
                    div.classList.add('selected');
                    loadRace(log);
                    closeSidebarIfMobile();
                });

                container.appendChild(div);
            });

            // Auto-select log from URL params if present
            const urlParams = new URLSearchParams(window.location.search);
            let matchingLog = null;

            // Prefer logts (timestamp) over log (filename) for stability across rotations
            if (urlParams.has('logts')) {
                const targetTs = parseInt(urlParams.get('logts'));
                matchingLog = currentSummary.logs.find(log => log.start_ts === targetTs);
            } else if (urlParams.has('log')) {
                // Legacy: match by filename
                const targetLog = urlParams.get('log');
                matchingLog = currentSummary.logs.find(log => log.file === targetLog);
            }

            if (matchingLog) {
                const index = currentSummary.logs.indexOf(matchingLog);
                const logDiv = container.querySelector(`[data-index="${index}"]`);
                if (logDiv) {
                    logDiv.classList.add('selected');
                    loadRace(matchingLog).then(() => {
                        restoreDataDependentState(urlParams);
                        redrawAll();
                    });
                }
            }
        }

        // Helper to fetch and decompress a file (tries .gz first, falls back to uncompressed)
        async function fetchLogFile(url) {
            const canDecompress = typeof DecompressionStream !== 'undefined';

            // Try compressed version first
            if (canDecompress) {
                try {
                    const gzUrl = url + '.gz';
                    const response = await fetch(gzUrl);
                    if (response.ok) {
                        const ds = new DecompressionStream('gzip');
                        const decompressed = response.body.pipeThrough(ds);
                        return await new Response(decompressed).text();
                    }
                } catch (e) {
                    // Fall through to uncompressed
                }
            }

            // Try uncompressed
            const response = await fetch(url);
            if (response.ok) {
                return await response.text();
            }
            return null;
        }

        // Load a specific race/log file (phase 2)
        async function loadRace(logEntry) {
            document.getElementById('loading').style.display = 'block';
            document.getElementById('status').textContent = `Loading ${logEntry.file}...`;

            currentLogFile = logEntry.file;
            currentLogStartTs = logEntry.start_ts;
            allData = [];
            userData = {};
            selectedUsers = new Set();

            try {
                const text = await fetchLogFile(`${DATA_BASE}logs/${logEntry.file}`);
                if (!text) throw new Error('Failed to load');

                const lines = text.trim().split('\n');

                for (const line of lines) {
                    try {
                        const entry = JSON.parse(line);
                        // Expand pos array entries (new format) or use directly (old format)
                        const expanded = expandEntry(entry);
                        for (const e of expanded) {
                            if (e.lat && e.lon && e.ts) {
                                allData.push(e);
                            }
                        }
                    } catch (e) {}
                }

                if (allData.length === 0) {
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('status').textContent = 'No data found in this log';
                    return;
                }

                // Sort by timestamp
                allData.sort((a, b) => a.ts - b.ts);

                // Group by user
                for (const entry of allData) {
                    const id = entry.id;
                    if (!userData[id]) {
                        userData[id] = [];
                    }
                    userData[id].push(entry);
                }

                // Calculate time range
                minTime = allData[0].ts;
                maxTime = allData[allData.length - 1].ts;
                sliderMinTime = minTime;  // Initialize slider range to full log
                sliderMaxTime = maxTime;
                rangeStartTime = minTime;
                rangeEndTime = maxTime;

                document.getElementById('start-slider').value = 0;
                document.getElementById('end-slider').value = 100;
                updateSliderRange();
                updateTimeDisplay();

                // Update user list
                updateUserList();

                // Draw tracks
                drawTracks();

                // Fit map to data
                fitMapToData();

                // Load course if available in log entry
                if (logEntry.course) {
                    await loadCourse(logEntry.course);
                } else {
                    clearCourseDisplay();
                    currentCourseFile = null;
                }

                document.getElementById('loading').style.display = 'none';
                document.getElementById('status').textContent = `Loaded ${allData.length} points from ${Object.keys(userData).length} users`;

            } catch (e) {
                console.error('Error loading log:', e);
                document.getElementById('loading').style.display = 'none';
                document.getElementById('status').textContent = 'Failed to load log';
            }
        }

        // Legacy function for when no summary exists
        async function loadTracksLegacy(logDate) {
            allData = [];
            userData = {};

            // Try to load main file and rotated files
            const baseUrl = `${DATA_BASE}logs/${logDate}.jsonl`;

            // Load base file first
            try {
                const text = await fetchLogFile(baseUrl);
                if (text) {
                    const lines = text.trim().split('\n');
                    for (const line of lines) {
                        try {
                            const entry = JSON.parse(line);
                            const expanded = expandEntry(entry);
                            for (const e of expanded) {
                                if (e.lat && e.lon && e.ts) {
                                    allData.push(e);
                                }
                            }
                        } catch (e) {}
                    }
                    document.getElementById('status').textContent = `Loaded ${baseUrl}...`;
                }
            } catch (e) {}

            // Try numbered rotations - stop on first missing file
            for (let i = 1; i <= 10; i++) {
                const file = `${baseUrl}.${i}`;
                try {
                    const text = await fetchLogFile(file);
                    if (!text) break;  // If file N doesn't exist, N+1 won't either

                    const lines = text.trim().split('\n');
                    for (const line of lines) {
                        try {
                            const entry = JSON.parse(line);
                            const expanded = expandEntry(entry);
                            for (const e of expanded) {
                                if (e.lat && e.lon && e.ts) {
                                    allData.push(e);
                                }
                            }
                        } catch (e) {}
                    }
                    document.getElementById('status').textContent = `Loaded ${file}...`;
                } catch (e) {
                    break;  // Stop on error too
                }
            }

            if (allData.length === 0) {
                document.getElementById('loading').style.display = 'none';
                document.getElementById('status').textContent = 'No data found for this date';
                document.getElementById('race-list').innerHTML = '<p style="color:#666">No logs found</p>';
                return;
            }

            // Sort by timestamp
            allData.sort((a, b) => a.ts - b.ts);

            // Group by user
            for (const entry of allData) {
                const id = entry.id;
                if (!userData[id]) {
                    userData[id] = [];
                }
                userData[id].push(entry);
            }

            // Calculate time range
            minTime = allData[0].ts;
            maxTime = allData[allData.length - 1].ts;
            sliderMinTime = minTime;  // Initialize slider range to full log
            sliderMaxTime = maxTime;
            rangeStartTime = minTime;
            rangeEndTime = maxTime;

            document.getElementById('start-slider').value = 0;
            document.getElementById('end-slider').value = 100;
            updateSliderRange();
            updateTimeDisplay();

            // Update user list
            updateUserList();

            // Show a single "all data" entry in log list
            document.getElementById('race-list').innerHTML = `
                <div class="race-item selected">
                    <div class="race-time">All Data (Legacy Mode)</div>
                    <div class="race-stats">
                        ${Object.keys(userData).length} sailors | ${allData.length.toLocaleString()} points
                    </div>
                </div>
            `;

            // Start with no users selected by default
            selectedUsers = new Set();

            // Draw tracks
            drawTracks();

            // Fit map to data
            fitMapToData();

            // Try to load current course (legacy mode has no course info in summary)
            await loadCourse('course.json');

            document.getElementById('loading').style.display = 'none';
            document.getElementById('status').textContent = `Loaded ${allData.length} points from ${Object.keys(userData).length} users`;
        }

        function updateUserList() {
            const container = document.getElementById('user-list');
            container.innerHTML = '';

            let colorIdx = 0;
            for (const [userId, entries] of Object.entries(userData)) {
                const speeds = entries.map(e => e.spd || 0);
                const maxSpeed = Math.max(...speeds);
                const avgSpeed = speeds.reduce((a,b) => a+b, 0) / speeds.length;
                const points = entries.length;

                const div = document.createElement('div');
                div.className = 'user-item';
                div.dataset.userId = userId;

                const color = userColors[colorIdx % userColors.length];
                colorIdx++;

                div.innerHTML = `
                    <div class="user-color" style="background:${color}"></div>
                    <div class="user-info">
                        <div class="user-name">${getDisplayName(userId)}</div>
                        <div class="user-stats">
                            ${points} pts | Max: ${maxSpeed.toFixed(1)} kts | Avg: ${avgSpeed.toFixed(1)} kts
                        </div>
                    </div>
                `;

                div.addEventListener('click', () => toggleUser(userId, div));
                div.addEventListener('dblclick', (e) => {
                    e.stopPropagation();
                    zoomToUser(userId);
                });
                container.appendChild(div);
            }
        }

        function toggleUser(userId, element) {
            if (selectedUsers.has(userId)) {
                selectedUsers.delete(userId);
                element.classList.remove('selected');
            } else {
                selectedUsers.add(userId);
                element.classList.add('selected');
            }

            // Update slider endpoints based on newly selected users
            updateSliderEndpoints();

            resetPlaybackToSelection();

            // Auto-fit map to show all selected tracks
            if (selectedUsers.size > 0) {
                fitMapToData();
            }
        }

        function resetPlaybackToSelection() {
            // Stop any active playback
            if (playbackInterval) {
                clearInterval(playbackInterval);
                playbackInterval = null;
                document.getElementById('play-btn').textContent = '‚ñ∂ Play';
            }

            updateTimeDisplay();
            drawTracks();
            drawSpeedGraph();
            drawSpeedGraph();
            drawBatteryGraph();
            drawSignalGraph();
            drawLatencyGraph();
            drawHeartRateGraph();
            drawAccuracyGraph();
            drawDistanceGraph();
        }

        function updateSliderRange() {
            const startSlider = document.getElementById('start-slider');
            const endSlider = document.getElementById('end-slider');
            const sliderRange = document.getElementById('slider-range');

            const startVal = parseFloat(startSlider.value);
            const endVal = parseFloat(endSlider.value);

            // Update the visual range indicator
            // Account for 20px thumb width - thumb center is at 10px + (value/100)*(100%-20px)
            sliderRange.style.left = `calc(10px + ${startVal}% - ${startVal * 0.2}px)`;
            sliderRange.style.width = `calc(${endVal - startVal}% - ${(endVal - startVal) * 0.2}px)`;

            // Update times from slider values (using dynamic slider range)
            rangeStartTime = sliderMinTime + (sliderMaxTime - sliderMinTime) * (startVal / 100);
            rangeEndTime = sliderMinTime + (sliderMaxTime - sliderMinTime) * (endVal / 100);

            // Update the edge labels
            document.getElementById('label-start').textContent = formatTimeInTz(sliderMinTime);
            document.getElementById('label-end').textContent = formatTimeInTz(sliderMaxTime);
        }

        function updateTimeDisplay() {
            const durationSec = rangeEndTime - rangeStartTime;
            const durationMin = Math.floor(durationSec / 60);
            const durationRemSec = Math.floor(durationSec % 60);
            const durationStr = `${durationMin}:${String(durationRemSec).padStart(2, '0')}`;

            document.getElementById('time-display').innerHTML =
                `<span style="color:#2ecc71">Start: ${formatTimeInTz(rangeStartTime)}</span> &nbsp;|&nbsp;` +
                `<span style="color:#e74c3c">End: ${formatTimeInTz(rangeEndTime)}</span> &nbsp;|&nbsp;` +
                `Duration: ${durationStr}`;
        }

        // Redraw all tracks and graphs (expensive operation)
        function redrawAll() {
            drawTracks();
            drawSpeedGraph();
            drawBatteryGraph();
            drawSignalGraph();
            drawLatencyGraph();
            drawHeartRateGraph();
            drawAccuracyGraph();
            drawDistanceGraph();
        }

        // Debounced version - waits for slider to stop moving before redrawing
        function debouncedRedrawAll(delay = 500) {
            if (sliderDebounceTimer) {
                clearTimeout(sliderDebounceTimer);
            }
            sliderDebounceTimer = setTimeout(() => {
                redrawAll();
                sliderDebounceTimer = null;
            }, delay);
        }

        function drawTracks() {
            // Calculate max speed from visible data and update scale
            const useSpeedColorForScale = document.getElementById('speed-color').checked;
            if (useSpeedColorForScale) {
                let maxSpeedInData = 0;
                for (const [userId, entries] of Object.entries(userData)) {
                    if (!selectedUsers.has(userId)) continue;
                    for (const entry of entries) {
                        if (entry.ts < rangeStartTime || entry.ts > rangeEndTime) continue;
                        if (entry.spd !== undefined && entry.spd !== null && entry.spd > 0) {
                            maxSpeedInData = Math.max(maxSpeedInData, entry.spd);
                        }
                    }
                }
                // Round up to nearest 5 knots, minimum 5
                speedScaleMax = Math.max(5, Math.ceil(maxSpeedInData / 5) * 5);
                // Update legend labels
                const mid = speedScaleMax / 2;
                document.querySelector('.speed-labels').innerHTML = `
                    <span>0</span>
                    <span>${mid}</span>
                    <span>${speedScaleMax}</span>
                `;
            }

            // Clear existing layers
            for (const layer of Object.values(trackLayers)) {
                map.removeLayer(layer);
            }
            for (const layer of Object.values(markerLayers)) {
                map.removeLayer(layer);
            }
            for (const layer of Object.values(pointLayers)) {
                map.removeLayer(layer);
            }
            for (const layer of Object.values(outlierLayers)) {
                map.removeLayer(layer);
            }
            trackLayers = {};
            markerLayers = {};
            pointLayers = {};
            outlierLayers = {};

            const useSpeedColor = document.getElementById('speed-color').checked;
            const showMarkers = document.getElementById('show-markers').checked;
            const doFilterOutliers = document.getElementById('filter-outliers').checked;
            const showOutliersMarkers = document.getElementById('show-outliers').checked;

            let colorIdx = 0;
            for (const [userId, entries] of Object.entries(userData)) {
                if (!selectedUsers.has(userId)) {
                    colorIdx++;
                    continue;
                }

                const userColor = userColors[colorIdx % userColors.length];
                colorIdx++;

                // Filter entries within the selected time range
                let timeFiltered = entries.filter(e => e.ts >= rangeStartTime && e.ts <= rangeEndTime);
                if (timeFiltered.length < 2) continue;

                // Apply outlier filtering if enabled
                let filtered = timeFiltered;
                let outliers = [];
                if (doFilterOutliers) {
                    const result = filterOutliers(timeFiltered);
                    filtered = result.filtered;
                    outliers = result.outliers;
                    // Fall back to unfiltered data if outlier filtering removed too many points
                    if (filtered.length < 2 && timeFiltered.length >= 2) {
                        filtered = timeFiltered;
                        outliers = [];
                    }
                }

                if (filtered.length < 2) continue;

                // Draw outlier markers if enabled
                if (showOutliersMarkers && outliers.length > 0) {
                    const outlierGroup = L.layerGroup();
                    for (const point of outliers) {
                        const time = formatTimeInTz(point.ts);
                        const speedKnots = (point.spd || 0).toFixed(1);

                        const marker = L.circleMarker([point.lat, point.lon], {
                            radius: 6,
                            fillColor: '#ff0000',
                            color: '#ff0000',
                            fillOpacity: 0.7,
                            weight: 2
                        });

                        let tooltipText = `Outlier: ${time}<br>Speed: ${speedKnots} kn`;
                        if (point.ast) {
                            tooltipText += '<br><span style="color:#ff0000">üÜò ASSIST REQUESTED</span>';
                            // Add larger assist circle
                            const assistMarker = L.circleMarker([point.lat, point.lon], {
                                radius: 12,
                                fillColor: 'transparent',
                                color: '#ff0000',
                                weight: 3,
                                fillOpacity: 0,
                                opacity: 0.9
                            });
                            outlierGroup.addLayer(assistMarker);
                        }
                        marker.bindTooltip(tooltipText, { permanent: false });

                        outlierGroup.addLayer(marker);
                    }
                    outlierGroup.addTo(map);
                    outlierLayers[userId] = outlierGroup;
                }

                // Create coords array for both cases
                const coords = filtered.map(e => [e.lat, e.lon]);

                if (useSpeedColor) {
                    // Draw segments colored by speed
                    const layerGroup = L.layerGroup();

                    for (let i = 1; i < filtered.length; i++) {
                        const prev = filtered[i-1];
                        const curr = filtered[i];
                        const color = speedToColor(curr.spd || 0);

                        const line = L.polyline(
                            [[prev.lat, prev.lon], [curr.lat, curr.lon]],
                            { color: color, weight: 3, opacity: 0.8 }
                        );
                        layerGroup.addLayer(line);
                    }

                    // Add invisible wider polyline for hover detection
                    const hitArea = L.polyline(coords, {
                        color: 'transparent',
                        weight: 15,
                        opacity: 0
                    });
                    layerGroup.addLayer(hitArea);

                    layerGroup.addTo(map);
                    trackLayers[userId] = layerGroup;
                    trackLayers[userId].hitArea = hitArea;
                } else {
                    // Draw single color track with invisible hit area for hover
                    const layerGroup = L.layerGroup();
                    const polyline = L.polyline(coords, {
                        color: userColor,
                        weight: 3,
                        opacity: 0.8
                    });
                    layerGroup.addLayer(polyline);

                    // Add invisible wider polyline for hover detection
                    const hitArea = L.polyline(coords, {
                        color: 'transparent',
                        weight: 15,
                        opacity: 0
                    });
                    layerGroup.addLayer(hitArea);

                    layerGroup.addTo(map);
                    trackLayers[userId] = layerGroup;
                    trackLayers[userId].hitArea = hitArea;
                }

                // Store filtered data for hover lookup (no individual markers for performance)
                trackLayers[userId].trackData = filtered;
                trackLayers[userId].trackUserId = userId;

                // Add hover/click handler to show closest point info
                const hoverTarget = trackLayers[userId].hitArea || trackLayers[userId];

                // Function to show popup at closest point to given latlng
                const showTrackPopup = (latlng, withCloseButton = false) => {
                    const data = trackLayers[userId].trackData;
                    if (!data || data.length === 0) return;

                    // Find closest point
                    let closest = data[0];
                    let closestDist = Infinity;
                    for (const point of data) {
                        const dist = Math.pow(point.lat - latlng.lat, 2) + Math.pow(point.lon - latlng.lng, 2);
                        if (dist < closestDist) {
                            closestDist = dist;
                            closest = point;
                        }
                    }

                    // Build popup content
                    const speedKnots = (closest.spd || 0).toFixed(1);
                    const time = formatTimeInTz(closest.ts);
                    let content = `<b>${getDisplayName(userId)}</b><br>
                        Time: ${time}<br>
                        Speed: ${speedKnots} kts<br>
                        Heading: ${closest.hdg || 0}¬∞<br>
                        Battery: ${closest.bat || '?'}%`;
                    if (closest.hac !== undefined) {
                        content += `<br>Accuracy: ${closest.hac.toFixed(1)}m`;
                    }
                    if (closest.hr !== undefined && closest.hr > 0) {
                        content += `<br>Heart Rate: <span style="color:#e91e63">${closest.hr} bpm</span>`;
                    }
                    if (closest.ast) {
                        content += '<br><span style="color:#ff0000">üÜò ASSIST REQUESTED</span>';
                    }

                    // Show or update popup
                    if (trackHoverPopup && !withCloseButton) {
                        trackHoverPopup.setLatLng([closest.lat, closest.lon]).setContent(content);
                    } else {
                        if (trackHoverPopup) {
                            map.closePopup(trackHoverPopup);
                        }
                        trackHoverPopup = L.popup({ closeButton: withCloseButton, offset: [0, -5] })
                            .setLatLng([closest.lat, closest.lon])
                            .setContent(content)
                            .openOn(map);
                    }
                };

                // Desktop: mousemove for live tracking
                hoverTarget.on('mousemove', (e) => showTrackPopup(e.latlng, false));

                // Mobile: click/tap to show popup with close button
                hoverTarget.on('click', (e) => {
                    showTrackPopup(e.latlng, true);
                    L.DomEvent.stopPropagation(e);
                });

                hoverTarget.on('mouseout', () => {
                    if (trackHoverPopup) {
                        map.closePopup(trackHoverPopup);
                        trackHoverPopup = null;
                    }
                });

                // Add current position marker
                if (showMarkers && filtered.length > 0) {
                    const last = filtered[filtered.length - 1];
                    const speedKnots = (last.spd || 0).toFixed(1);

                    // Build warnings for battery issues
                    let markerWarnings = '';
                    if (last.flg) {
                        if (last.flg.ps) {
                            markerWarnings += '<br><span style="color:#e74c3c">‚ö†Ô∏è Battery Saver ON</span>';
                        }
                        if (last.flg.bo === false) {
                            markerWarnings += '<br><span style="color:#f39c12">‚ö†Ô∏è Battery Optimization ON</span>';
                        }
                    }

                    let markerHrText = '';
                    if (last.hr !== undefined && last.hr > 0) {
                        markerHrText = `<br>Heart Rate: <span style="color:#e91e63">${last.hr} bpm</span>`;
                    }

                    let markerHacText = '';
                    if (last.hac !== undefined) {
                        markerHacText = `<br>Accuracy: ${last.hac.toFixed(1)}m`;
                    }

                    const marker = L.circleMarker([last.lat, last.lon], {
                        radius: 8,
                        fillColor: userColor,
                        color: '#fff',
                        weight: 2,
                        fillOpacity: 1
                    }).bindPopup(`
                        <b>${getDisplayName(userId)}</b><br>
                        Speed: ${speedKnots} kts<br>
                        Heading: ${last.hdg || 0}¬∞<br>
                        Battery: ${last.bat || '?'}%${markerHacText}${markerHrText}${markerWarnings}
                    `).addTo(map);
                    markerLayers[userId] = marker;
                }
            }
        }

        function fitMapToData() {
            const allCoords = [];
            for (const userId of selectedUsers) {
                if (userData[userId]) {
                    for (const entry of userData[userId]) {
                        allCoords.push([entry.lat, entry.lon]);
                    }
                }
            }
            if (allCoords.length > 0) {
                map.fitBounds(allCoords, { padding: [50, 50] });
            }
        }

        function drawSpeedGraph() {
            // Only draw if speed graph is visible
            if (!document.getElementById('show-speed-graph').checked) return;

            const canvas = document.getElementById('speed-graph');
            const ctx = canvas.getContext('2d');

            // Set canvas size to match display size (for sharp rendering)
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * window.devicePixelRatio;
            canvas.height = rect.height * window.devicePixelRatio;
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);

            const width = rect.width;
            const height = rect.height;

            // Clear canvas
            ctx.clearRect(0, 0, width, height);

            // Update time axis labels
            document.getElementById('speed-time-start').textContent = formatTimeShortInTz(rangeStartTime);
            document.getElementById('speed-time-end').textContent = formatTimeShortInTz(rangeEndTime);

            // Calculate speed range for Y axis scaling (only from visible time range)
            let maxSpeed = 0;
            let minSpeed = Infinity;
            let hasSpeedData = false;
            for (const [userId, entries] of Object.entries(userData)) {
                if (!selectedUsers.has(userId)) continue;
                for (const entry of entries) {
                    if (entry.ts < rangeStartTime || entry.ts > rangeEndTime) continue;
                    if (entry.spd !== undefined && entry.spd !== null && entry.spd >= 0) {
                        maxSpeed = Math.max(maxSpeed, entry.spd);
                        minSpeed = Math.min(minSpeed, entry.spd);
                        hasSpeedData = true;
                    }
                }
            }

            // Set sensible defaults and add padding
            if (!hasSpeedData || maxSpeed === 0) {
                maxSpeed = 20;
                minSpeed = 0;
            } else {
                // Add 10% padding above max
                maxSpeed = Math.ceil((maxSpeed * 1.1) / 2) * 2;  // Round to nearest 2 knots
                // Round min down, but keep at 0 for speed (negative speed doesn't make sense)
                minSpeed = 0;
                // Ensure at least 5 knot range for readability
                if (maxSpeed - minSpeed < 5) {
                    maxSpeed = minSpeed + 5;
                }
            }
            const speedRange = maxSpeed - minSpeed;

            // Update Y axis labels
            const yLabels = document.getElementById('speed-y-labels');
            yLabels.innerHTML = `
                <span>${maxSpeed}</span>
                <span>${(minSpeed + speedRange * 0.75).toFixed(0)}</span>
                <span>${(minSpeed + speedRange * 0.5).toFixed(0)}</span>
                <span>${(minSpeed + speedRange * 0.25).toFixed(0)}</span>
                <span>${minSpeed}</span>
            `;

            // Draw grid lines
            ctx.strokeStyle = '#34495e';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 4; i++) {
                const y = (i / 4) * height;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }

            // No users selected
            if (selectedUsers.size === 0) {
                ctx.fillStyle = '#7f8c8d';
                ctx.font = '14px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Select a user to see speed graph', width / 2, height / 2);
                return;
            }

            // Draw speed line for each selected user
            let colorIdx = 0;
            for (const [userId, entries] of Object.entries(userData)) {
                const userColor = userColors[colorIdx % userColors.length];
                colorIdx++;

                if (!selectedUsers.has(userId)) continue;

                // Filter entries by time range
                const filtered = entries.filter(e => e.ts >= rangeStartTime && e.ts <= rangeEndTime);
                if (filtered.length < 2) continue;

                // Draw the speed line
                ctx.strokeStyle = userColor;
                ctx.lineWidth = 2;
                ctx.beginPath();

                let started = false;
                for (const entry of filtered) {
                    if (entry.spd === undefined || entry.spd === null) continue;

                    const x = ((entry.ts - rangeStartTime) / (rangeEndTime - rangeStartTime)) * width;
                    const y = height - ((entry.spd - minSpeed) / speedRange) * height;

                    if (!started) {
                        ctx.moveTo(x, y);
                        started = true;
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();

                // Draw user label at the end of the line
                if (filtered.length > 0) {
                    const last = filtered[filtered.length - 1];
                    if (last.spd !== undefined && last.spd !== null) {
                        const x = ((last.ts - rangeStartTime) / (rangeEndTime - rangeStartTime)) * width;
                        const y = height - ((last.spd - minSpeed) / speedRange) * height;
                        ctx.fillStyle = userColor;
                        ctx.font = 'bold 10px sans-serif';
                        ctx.textAlign = 'right';
                        ctx.fillText(`${getDisplayName(userId)}: ${last.spd.toFixed(1)} kts`, Math.min(x, width - 5), y - 5);
                    }
                }
            }
        }

        function drawBatteryGraph() {
            // Only draw if battery graph is visible
            if (!document.getElementById('show-battery-graph').checked) return;

            const canvas = document.getElementById('battery-graph');
            const ctx = canvas.getContext('2d');

            // Set canvas size to match display size (for sharp rendering)
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * window.devicePixelRatio;
            canvas.height = rect.height * window.devicePixelRatio;
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);

            const width = rect.width;
            const height = rect.height;

            // Clear canvas
            ctx.clearRect(0, 0, width, height);

            // Update time axis labels
            document.getElementById('battery-time-start').textContent = formatTimeShortInTz(rangeStartTime);
            document.getElementById('battery-time-end').textContent = formatTimeShortInTz(rangeEndTime);

            // Calculate battery range for Y axis scaling (only from visible time range)
            let maxBat = 0;
            let minBat = 100;
            let hasBatData = false;
            for (const [userId, entries] of Object.entries(userData)) {
                if (!selectedUsers.has(userId)) continue;
                for (const entry of entries) {
                    if (entry.ts < rangeStartTime || entry.ts > rangeEndTime) continue;
                    if (entry.bat !== undefined && entry.bat !== null && entry.bat >= 0) {
                        maxBat = Math.max(maxBat, entry.bat);
                        minBat = Math.min(minBat, entry.bat);
                        hasBatData = true;
                    }
                }
            }

            // Set sensible defaults and add padding
            if (!hasBatData) {
                maxBat = 100;
                minBat = 0;
            } else {
                // Keep max at 100 if close, otherwise add padding
                maxBat = maxBat > 95 ? 100 : Math.ceil((maxBat + 5) / 5) * 5;
                // Round min down to nearest 5%
                minBat = Math.floor(minBat / 5) * 5;
                // Ensure at least 10% range for readability
                if (maxBat - minBat < 10) {
                    if (maxBat < 100) maxBat = Math.min(100, minBat + 10);
                    else minBat = Math.max(0, maxBat - 10);
                }
            }
            // Ensure batRange is never 0 (prevents division by zero)
            const batRange = Math.max(10, maxBat - minBat);

            // Update Y axis labels
            const yLabels = document.getElementById('battery-y-labels');
            yLabels.innerHTML = `
                <span>${maxBat}</span>
                <span>${Math.round(minBat + batRange * 0.75)}</span>
                <span>${Math.round(minBat + batRange * 0.5)}</span>
                <span>${Math.round(minBat + batRange * 0.25)}</span>
                <span>${minBat}</span>
            `;

            // Draw grid lines
            ctx.strokeStyle = '#34495e';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 4; i++) {
                const y = (i / 4) * height;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }

            // No users selected
            if (selectedUsers.size === 0) {
                ctx.fillStyle = '#7f8c8d';
                ctx.font = '14px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Select a user to see battery graph', width / 2, height / 2);
                return;
            }

            // No battery data available
            if (!hasBatData) {
                ctx.fillStyle = '#7f8c8d';
                ctx.font = '14px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('No battery data available', width / 2, height / 2);
                return;
            }

            // Draw battery line for each selected user
            let colorIdx = 0;
            for (const [userId, entries] of Object.entries(userData)) {
                const userColor = userColors[colorIdx % userColors.length];
                colorIdx++;

                if (!selectedUsers.has(userId)) continue;

                // Filter entries by time range
                const filtered = entries.filter(e => e.ts >= rangeStartTime && e.ts <= rangeEndTime);
                if (filtered.length < 2) continue;

                // Draw the battery line
                ctx.strokeStyle = userColor;
                ctx.lineWidth = 2;
                ctx.beginPath();

                let started = false;
                for (const entry of filtered) {
                    if (entry.bat === undefined || entry.bat === null || entry.bat < 0) continue;

                    const x = ((entry.ts - rangeStartTime) / (rangeEndTime - rangeStartTime)) * width;
                    const y = height - ((entry.bat - minBat) / batRange) * height;

                    if (!started) {
                        ctx.moveTo(x, y);
                        started = true;
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();

                // Draw user label at the end of the line
                if (filtered.length > 0) {
                    const last = filtered[filtered.length - 1];
                    if (last.bat !== undefined && last.bat !== null && last.bat >= 0) {
                        const x = ((last.ts - rangeStartTime) / (rangeEndTime - rangeStartTime)) * width;
                        const y = height - ((last.bat - minBat) / batRange) * height;
                        ctx.fillStyle = userColor;
                        ctx.font = 'bold 10px sans-serif';
                        ctx.textAlign = 'right';
                        ctx.fillText(`${getDisplayName(userId)}: ${last.bat}%`, Math.min(x, width - 5), y - 5);
                    }
                }
            }
        }

        function drawSignalGraph() {
            // Only draw if signal graph is visible
            if (!document.getElementById('show-signal-graph').checked) return;

            const canvas = document.getElementById('signal-graph');
            const ctx = canvas.getContext('2d');

            // Set canvas size to match display size (for sharp rendering)
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * window.devicePixelRatio;
            canvas.height = rect.height * window.devicePixelRatio;
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);

            const width = rect.width;
            const height = rect.height;

            // Clear canvas
            ctx.clearRect(0, 0, width, height);

            // Update time axis labels
            document.getElementById('signal-time-start').textContent = formatTimeShortInTz(rangeStartTime);
            document.getElementById('signal-time-end').textContent = formatTimeShortInTz(rangeEndTime);

            // Draw grid lines
            ctx.strokeStyle = '#34495e';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 4; i++) {
                const y = (i / 4) * height;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }

            // No users selected
            if (selectedUsers.size === 0) {
                ctx.fillStyle = '#7f8c8d';
                ctx.font = '14px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Select a user to see signal graph', width / 2, height / 2);
                return;
            }

            // Draw signal line for each selected user
            let colorIdx = 0;
            for (const [userId, entries] of Object.entries(userData)) {
                const userColor = userColors[colorIdx % userColors.length];
                colorIdx++;

                if (!selectedUsers.has(userId)) continue;

                // Filter entries by time range
                const filtered = entries.filter(e => e.ts >= rangeStartTime && e.ts <= rangeEndTime);
                if (filtered.length < 2) continue;

                // Draw the signal line
                ctx.strokeStyle = userColor;
                ctx.lineWidth = 2;
                ctx.beginPath();

                let started = false;
                for (const entry of filtered) {
                    if (entry.sig === undefined || entry.sig === null) continue;

                    const x = ((entry.ts - rangeStartTime) / (rangeEndTime - rangeStartTime)) * width;
                    const y = height - (entry.sig / 4) * height;

                    if (!started) {
                        ctx.moveTo(x, y);
                        started = true;
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();

                // Draw user label at the end of the line
                if (filtered.length > 0) {
                    const last = filtered[filtered.length - 1];
                    if (last.sig !== undefined && last.sig !== null) {
                        const x = ((last.ts - rangeStartTime) / (rangeEndTime - rangeStartTime)) * width;
                        const y = height - (last.sig / 4) * height;
                        const sigBars = '‚ñÇ‚ñÑ‚ñÜ‚ñà'.slice(0, Math.max(1, Math.min(4, last.sig)));
                        ctx.fillStyle = userColor;
                        ctx.font = 'bold 10px sans-serif';
                        ctx.textAlign = 'right';
                        ctx.fillText(`${getDisplayName(userId)}: ${sigBars}`, Math.min(x, width - 5), y - 5);
                    }
                }
            }
        }

        // Calculate network latency for an entry
        // For 1Hz batched positions, use batch_ts (when batch was sent) instead of ts
        function getNetworkLatency(entry) {
            if (entry.recv_ts === undefined) return null;
            // Use batch_ts if available (for batched 1Hz positions), otherwise use ts
            const sendTime = entry.batch_ts !== undefined ? entry.batch_ts : entry.ts;
            return entry.recv_ts - sendTime;
        }

        function drawLatencyGraph() {
            // Only draw if latency graph is visible
            if (!document.getElementById('show-latency-graph').checked) return;

            const canvas = document.getElementById('latency-graph');
            const ctx = canvas.getContext('2d');

            // Set canvas size to match display size (for sharp rendering)
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * window.devicePixelRatio;
            canvas.height = rect.height * window.devicePixelRatio;
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);

            const width = rect.width;
            const height = rect.height;

            // Clear canvas
            ctx.clearRect(0, 0, width, height);

            // Update time axis labels
            document.getElementById('latency-time-start').textContent = formatTimeShortInTz(rangeStartTime);
            document.getElementById('latency-time-end').textContent = formatTimeShortInTz(rangeEndTime);

            // Calculate max latency for Y axis scaling (only from visible time range)
            let maxLatency = 0;
            let hasLatencyValues = false;
            for (const [userId, entries] of Object.entries(userData)) {
                if (!selectedUsers.has(userId)) continue;
                for (const entry of entries) {
                    if (entry.ts < rangeStartTime || entry.ts > rangeEndTime) continue;
                    const latency = getNetworkLatency(entry);
                    if (latency !== null && Math.abs(latency) < 300) {
                        maxLatency = Math.max(maxLatency, Math.abs(latency));
                        hasLatencyValues = true;
                    }
                }
            }

            // Set sensible defaults and add padding
            if (!hasLatencyValues || maxLatency === 0) {
                maxLatency = 10;
            } else {
                // Add 10% padding above max
                maxLatency = maxLatency * 1.1;
                // Round to nice number based on magnitude
                if (maxLatency < 2) {
                    maxLatency = Math.ceil(maxLatency * 4) / 4;  // Round to 0.25s
                    if (maxLatency < 0.5) maxLatency = 0.5;
                } else if (maxLatency < 5) {
                    maxLatency = Math.ceil(maxLatency);  // Round to 1s
                } else {
                    maxLatency = Math.ceil(maxLatency / 2) * 2;  // Round to 2s
                }
            }

            // Update Y axis labels
            const yLabels = document.getElementById('latency-y-labels');
            yLabels.innerHTML = `
                <span>${maxLatency.toFixed(maxLatency < 2 ? 2 : 0)}</span>
                <span>${(maxLatency * 0.75).toFixed(maxLatency < 2 ? 2 : 1)}</span>
                <span>${(maxLatency * 0.5).toFixed(maxLatency < 2 ? 2 : 1)}</span>
                <span>${(maxLatency * 0.25).toFixed(maxLatency < 2 ? 2 : 1)}</span>
                <span>0</span>
            `;

            // Draw grid lines
            ctx.strokeStyle = '#34495e';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 4; i++) {
                const y = (i / 4) * height;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }

            // No users selected
            if (selectedUsers.size === 0) {
                ctx.fillStyle = '#7f8c8d';
                ctx.font = '14px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Select a user to see latency graph', width / 2, height / 2);
                return;
            }

            // Check if any data has recv_ts
            let hasLatencyData = false;
            for (const [userId, entries] of Object.entries(userData)) {
                if (!selectedUsers.has(userId)) continue;
                if (entries.some(e => e.recv_ts !== undefined)) {
                    hasLatencyData = true;
                    break;
                }
            }

            if (!hasLatencyData) {
                ctx.fillStyle = '#7f8c8d';
                ctx.font = '14px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('No latency data (requires server update)', width / 2, height / 2);
                return;
            }

            // Draw latency line for each selected user
            let colorIdx = 0;
            for (const [userId, entries] of Object.entries(userData)) {
                const userColor = userColors[colorIdx % userColors.length];
                colorIdx++;

                if (!selectedUsers.has(userId)) continue;

                // Filter entries by time range
                const filtered = entries.filter(e => e.ts >= rangeStartTime && e.ts <= rangeEndTime);
                if (filtered.length < 2) continue;

                // Draw the latency line (use absolute value, dashed for negative)
                ctx.strokeStyle = userColor;
                ctx.lineWidth = 2;

                let started = false;
                let lastWasNegative = false;
                for (const entry of filtered) {
                    const rawLatency = getNetworkLatency(entry);
                    if (rawLatency === null) continue;
                    const latency = Math.abs(rawLatency);
                    if (latency > 300) continue; // Skip extreme values

                    const isNegative = rawLatency < 0;
                    const x = ((entry.ts - rangeStartTime) / (rangeEndTime - rangeStartTime)) * width;
                    const y = height - (latency / maxLatency) * height;

                    // Switch line style when sign changes
                    if (started && isNegative !== lastWasNegative) {
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(x, y);
                    }

                    // Use dashed line for negative latencies (clock ahead)
                    ctx.setLineDash(isNegative ? [4, 2] : []);

                    if (!started) {
                        ctx.beginPath();
                        ctx.moveTo(x, y);
                        started = true;
                    } else {
                        ctx.lineTo(x, y);
                    }
                    lastWasNegative = isNegative;
                }
                ctx.stroke();
                ctx.setLineDash([]);

                // Draw user label at the end of the line
                if (filtered.length > 0) {
                    const last = filtered[filtered.length - 1];
                    const rawLatency = getNetworkLatency(last);
                    if (rawLatency !== null) {
                        const latency = Math.abs(rawLatency);
                        if (latency <= 300) {
                            const x = ((last.ts - rangeStartTime) / (rangeEndTime - rangeStartTime)) * width;
                            const y = height - (latency / maxLatency) * height;
                            ctx.fillStyle = userColor;
                            ctx.font = 'bold 10px sans-serif';
                            ctx.textAlign = 'right';
                            const sign = rawLatency < 0 ? '-' : '';
                            ctx.fillText(`${getDisplayName(userId)}: ${sign}${latency.toFixed(1)}s`, Math.min(x, width - 5), y - 5);
                        }
                    }
                }
            }
        }

        function drawHeartRateGraph() {
            // Only draw if heart rate graph is visible
            if (!document.getElementById('show-heartrate-graph').checked) return;

            const canvas = document.getElementById('heartrate-graph');
            const ctx = canvas.getContext('2d');

            // Set canvas size to match display size (for sharp rendering)
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * window.devicePixelRatio;
            canvas.height = rect.height * window.devicePixelRatio;
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);

            const width = rect.width;
            const height = rect.height;

            // Clear canvas
            ctx.clearRect(0, 0, width, height);

            // Update time axis labels
            document.getElementById('heartrate-time-start').textContent = formatTimeShortInTz(rangeStartTime);
            document.getElementById('heartrate-time-end').textContent = formatTimeShortInTz(rangeEndTime);

            // Calculate heart rate range for Y axis scaling (only from visible time range)
            let maxHR = 0;
            let minHR = Infinity;
            let hasHRData = false;
            for (const [userId, entries] of Object.entries(userData)) {
                if (!selectedUsers.has(userId)) continue;
                for (const entry of entries) {
                    if (entry.ts < rangeStartTime || entry.ts > rangeEndTime) continue;
                    if (entry.hr !== undefined && entry.hr > 0) {
                        maxHR = Math.max(maxHR, entry.hr);
                        minHR = Math.min(minHR, entry.hr);
                        hasHRData = true;
                    }
                }
            }

            // Set sensible defaults and add padding
            if (!hasHRData || maxHR === 0) {
                maxHR = 200;
                minHR = 0;
            } else {
                // Add 10% padding above max
                maxHR = Math.ceil((maxHR * 1.1) / 10) * 10;
                // Round min down to nearest 10, with some padding below
                minHR = Math.max(0, Math.floor((minHR * 0.9) / 10) * 10);
                // Ensure at least 40 bpm range for readability
                if (maxHR - minHR < 40) {
                    const mid = (maxHR + minHR) / 2;
                    maxHR = Math.ceil((mid + 20) / 10) * 10;
                    minHR = Math.max(0, Math.floor((mid - 20) / 10) * 10);
                }
            }

            // Update Y axis labels
            const yLabels = document.getElementById('heartrate-y-labels');
            const range = maxHR - minHR;
            yLabels.innerHTML = `
                <span>${maxHR}</span>
                <span>${Math.round(minHR + range * 0.75)}</span>
                <span>${Math.round(minHR + range * 0.5)}</span>
                <span>${Math.round(minHR + range * 0.25)}</span>
                <span>${minHR}</span>
            `;

            // Draw grid lines
            ctx.strokeStyle = '#34495e';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 4; i++) {
                const y = (i / 4) * height;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }

            // No users selected
            if (selectedUsers.size === 0) {
                ctx.fillStyle = '#7f8c8d';
                ctx.font = '14px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Select a user to see heart rate graph', width / 2, height / 2);
                return;
            }

            if (!hasHRData) {
                ctx.fillStyle = '#7f8c8d';
                ctx.font = '14px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('No heart rate data available', width / 2, height / 2);
                return;
            }

            // Draw heart rate line for each selected user
            let colorIdx = 0;
            for (const [userId, entries] of Object.entries(userData)) {
                const userColor = userColors[colorIdx % userColors.length];
                colorIdx++;

                if (!selectedUsers.has(userId)) continue;

                // Filter entries by time range and having HR data
                const filtered = entries.filter(e => e.ts >= rangeStartTime && e.ts <= rangeEndTime && e.hr !== undefined && e.hr > 0);
                if (filtered.length < 2) continue;

                // Draw the heart rate line
                ctx.strokeStyle = '#e91e63'; // Pink color for heart rate
                ctx.lineWidth = 2;
                ctx.beginPath();

                let started = false;
                for (const entry of filtered) {
                    const x = ((entry.ts - rangeStartTime) / (rangeEndTime - rangeStartTime)) * width;
                    const y = height - ((entry.hr - minHR) / range) * height;

                    if (!started) {
                        ctx.moveTo(x, y);
                        started = true;
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();

                // Draw user label at the end of the line
                if (filtered.length > 0) {
                    const last = filtered[filtered.length - 1];
                    const x = ((last.ts - rangeStartTime) / (rangeEndTime - rangeStartTime)) * width;
                    const y = height - ((last.hr - minHR) / range) * height;
                    ctx.fillStyle = '#e91e63';
                    ctx.font = 'bold 10px sans-serif';
                    ctx.textAlign = 'right';
                    ctx.fillText(`${getDisplayName(userId)}: ${last.hr} bpm`, Math.min(x, width - 5), y - 5);
                }
            }
        }

        function drawAccuracyGraph() {
            // Only draw if accuracy graph is visible
            if (!document.getElementById('show-accuracy-graph').checked) return;

            const canvas = document.getElementById('accuracy-graph');
            const ctx = canvas.getContext('2d');

            // Set canvas size to match display size (for sharp rendering)
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * window.devicePixelRatio;
            canvas.height = rect.height * window.devicePixelRatio;
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);

            const width = rect.width;
            const height = rect.height;

            // Clear canvas
            ctx.clearRect(0, 0, width, height);

            // Update time axis labels
            document.getElementById('accuracy-time-start').textContent = formatTimeShortInTz(rangeStartTime);
            document.getElementById('accuracy-time-end').textContent = formatTimeShortInTz(rangeEndTime);

            // Calculate accuracy range for Y axis scaling (only from visible time range)
            let maxAcc = 0;
            let hasAccData = false;
            for (const [userId, entries] of Object.entries(userData)) {
                if (!selectedUsers.has(userId)) continue;
                for (const entry of entries) {
                    if (entry.ts < rangeStartTime || entry.ts > rangeEndTime) continue;
                    if (entry.hac !== undefined && entry.hac > 0) {
                        maxAcc = Math.max(maxAcc, entry.hac);
                        hasAccData = true;
                    }
                }
            }

            // Set sensible defaults and add padding
            if (!hasAccData || maxAcc === 0) {
                maxAcc = 100;
            } else {
                // Add 10% padding above max, round to nice number
                maxAcc = Math.ceil((maxAcc * 1.1) / 10) * 10;
                maxAcc = Math.max(maxAcc, 10); // At least 10m range
            }

            // Update Y axis labels
            const yLabels = document.getElementById('accuracy-y-labels');
            yLabels.innerHTML = `
                <span>${maxAcc}</span>
                <span>${Math.round(maxAcc * 0.75)}</span>
                <span>${Math.round(maxAcc * 0.5)}</span>
                <span>${Math.round(maxAcc * 0.25)}</span>
                <span>0</span>
            `;

            // Draw grid lines
            ctx.strokeStyle = '#34495e';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 4; i++) {
                const y = (i / 4) * height;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }

            // No users selected
            if (selectedUsers.size === 0) {
                ctx.fillStyle = '#7f8c8d';
                ctx.font = '14px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Select a user to see accuracy graph', width / 2, height / 2);
                return;
            }

            if (!hasAccData) {
                ctx.fillStyle = '#7f8c8d';
                ctx.font = '14px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('No accuracy data available', width / 2, height / 2);
                return;
            }

            // Draw accuracy line for each selected user
            let colorIdx = 0;
            for (const [userId, entries] of Object.entries(userData)) {
                const userColor = userColors[colorIdx % userColors.length];
                colorIdx++;

                if (!selectedUsers.has(userId)) continue;

                // Filter entries by time range and having accuracy data
                const filtered = entries.filter(e => e.ts >= rangeStartTime && e.ts <= rangeEndTime && e.hac !== undefined && e.hac > 0);
                if (filtered.length < 2) continue;

                // Draw the accuracy line
                ctx.strokeStyle = '#9b59b6'; // Purple color for accuracy
                ctx.lineWidth = 2;
                ctx.beginPath();

                let started = false;
                for (const entry of filtered) {
                    const x = ((entry.ts - rangeStartTime) / (rangeEndTime - rangeStartTime)) * width;
                    const y = height - (entry.hac / maxAcc) * height;

                    if (!started) {
                        ctx.moveTo(x, y);
                        started = true;
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();

                // Draw user label at the end of the line
                if (filtered.length > 0) {
                    const last = filtered[filtered.length - 1];
                    const x = ((last.ts - rangeStartTime) / (rangeEndTime - rangeStartTime)) * width;
                    const y = height - (last.hac / maxAcc) * height;
                    ctx.fillStyle = '#9b59b6';
                    ctx.font = 'bold 10px sans-serif';
                    ctx.textAlign = 'right';
                    ctx.fillText(`${getDisplayName(userId)}: ${last.hac.toFixed(1)}m`, Math.min(x, width - 5), y - 5);
                }
            }
        }

        function drawDistanceGraph() {
            // Only draw if distance graph is visible
            if (!document.getElementById('show-distance-graph').checked) return;

            const canvas = document.getElementById('distance-graph');
            const ctx = canvas.getContext('2d');

            // Set canvas size to match display size (for sharp rendering)
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * window.devicePixelRatio;
            canvas.height = rect.height * window.devicePixelRatio;
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);

            const width = rect.width;
            const height = rect.height;

            // Clear canvas
            ctx.clearRect(0, 0, width, height);

            // Update time axis labels
            document.getElementById('distance-time-start').textContent = formatTimeShortInTz(rangeStartTime);
            document.getElementById('distance-time-end').textContent = formatTimeShortInTz(rangeEndTime);

            // Calculate cumulative distance for each user (only 10s points for CPU efficiency)
            let maxDist = 0;
            let hasDistData = false;
            const userDistances = {};
            cachedDistanceData = {};  // Reset cache

            for (const [userId, entries] of Object.entries(userData)) {
                if (!selectedUsers.has(userId)) continue;

                // Filter to only 10s points (skip 1s high-frequency points)
                // 10s points have gaps >= 5 seconds from the previous point
                const filtered = [];
                let lastTs = -Infinity;
                for (const entry of entries) {
                    if (entry.ts < rangeStartTime || entry.ts > rangeEndTime) continue;
                    // Only include points that are at least 5 seconds apart (to catch 10s points)
                    if (entry.ts - lastTs >= 5) {
                        filtered.push(entry);
                        lastTs = entry.ts;
                    }
                }

                if (filtered.length < 2) continue;

                // Calculate cumulative distance
                const distances = [{ts: filtered[0].ts, dist: 0}];
                let cumDist = 0;
                for (let i = 1; i < filtered.length; i++) {
                    const prev = filtered[i - 1];
                    const curr = filtered[i];
                    const d = haversineDistance(prev.lat, prev.lon, curr.lat, curr.lon) * 1000; // km to meters
                    cumDist += d;
                    distances.push({ts: curr.ts, dist: cumDist});
                }

                if (distances.length > 1) {
                    userDistances[userId] = distances;
                    maxDist = Math.max(maxDist, cumDist);
                    hasDistData = true;
                }
            }

            // Cache for hover display
            cachedDistanceData = userDistances;

            // Set sensible defaults and add padding
            if (!hasDistData || maxDist === 0) {
                maxDist = 10000;
            } else {
                // Add 10% padding above max, round to nice number
                maxDist = Math.ceil((maxDist * 1.1) / 1000) * 1000;
                maxDist = Math.max(maxDist, 1000); // At least 1km range
            }

            // Update Y axis labels (show in km if over 10km, otherwise meters)
            const yLabels = document.getElementById('distance-y-labels');
            if (maxDist >= 10000) {
                yLabels.innerHTML = `
                    <span>${(maxDist / 1000).toFixed(1)}km</span>
                    <span>${(maxDist * 0.75 / 1000).toFixed(1)}km</span>
                    <span>${(maxDist * 0.5 / 1000).toFixed(1)}km</span>
                    <span>${(maxDist * 0.25 / 1000).toFixed(1)}km</span>
                    <span>0</span>
                `;
            } else {
                yLabels.innerHTML = `
                    <span>${Math.round(maxDist)}m</span>
                    <span>${Math.round(maxDist * 0.75)}m</span>
                    <span>${Math.round(maxDist * 0.5)}m</span>
                    <span>${Math.round(maxDist * 0.25)}m</span>
                    <span>0</span>
                `;
            }

            // Draw grid lines
            ctx.strokeStyle = '#34495e';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 4; i++) {
                const y = (i / 4) * height;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }

            // No users selected
            if (selectedUsers.size === 0) {
                ctx.fillStyle = '#7f8c8d';
                ctx.font = '14px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Select a user to see distance graph', width / 2, height / 2);
                return;
            }

            if (!hasDistData) {
                ctx.fillStyle = '#7f8c8d';
                ctx.font = '14px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Not enough data for distance calculation', width / 2, height / 2);
                return;
            }

            // Draw distance line for each selected user
            let colorIdx = 0;
            for (const [userId, distances] of Object.entries(userDistances)) {
                const userColor = userColors[colorIdx % userColors.length];
                colorIdx++;

                if (distances.length < 2) continue;

                // Draw the distance line
                ctx.strokeStyle = '#27ae60'; // Green color for distance
                ctx.lineWidth = 2;
                ctx.beginPath();

                let started = false;
                for (const point of distances) {
                    const x = ((point.ts - rangeStartTime) / (rangeEndTime - rangeStartTime)) * width;
                    const y = height - (point.dist / maxDist) * height;

                    if (!started) {
                        ctx.moveTo(x, y);
                        started = true;
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();

                // Draw user label at the end of the line
                if (distances.length > 0) {
                    const last = distances[distances.length - 1];
                    const x = ((last.ts - rangeStartTime) / (rangeEndTime - rangeStartTime)) * width;
                    const y = height - (last.dist / maxDist) * height;
                    ctx.fillStyle = '#27ae60';
                    ctx.font = 'bold 10px sans-serif';
                    ctx.textAlign = 'right';
                    const distLabel = last.dist >= 1000 ? `${(last.dist / 1000).toFixed(2)}km` : `${Math.round(last.dist)}m`;
                    ctx.fillText(`${getDisplayName(userId)}: ${distLabel}`, Math.min(x, width - 5), y - 5);
                }
            }
        }

        // Graph hover highlighting (shared between battery, signal, and latency graphs)
        let graphHighlightMarkers = [];
        let pendingHighlightUpdate = null;

        function clearGraphHighlight() {
            // Cancel any pending highlight update
            if (pendingHighlightUpdate) {
                cancelAnimationFrame(pendingHighlightUpdate);
                pendingHighlightUpdate = null;
            }

            // Remove highlight markers from map (explicitly remove tooltips to prevent orphans)
            for (const marker of graphHighlightMarkers) {
                const tooltip = marker.getTooltip();
                marker.closeTooltip();
                if (tooltip && map.hasLayer(tooltip)) {
                    map.removeLayer(tooltip);
                }
                marker.unbindTooltip();
                map.removeLayer(marker);
            }
            graphHighlightMarkers = [];

            // Redraw graphs without highlight
            if (document.getElementById('show-speed-graph').checked) {
                drawSpeedGraph();
            }
            if (document.getElementById('show-battery-graph').checked) {
                drawBatteryGraph();
            }
            if (document.getElementById('show-signal-graph').checked) {
                drawSignalGraph();
            }
            if (document.getElementById('show-latency-graph').checked) {
                drawLatencyGraph();
            }
            if (document.getElementById('show-heartrate-graph').checked) {
                drawHeartRateGraph();
            }
            if (document.getElementById('show-accuracy-graph').checked) {
                drawAccuracyGraph();
            }
            if (document.getElementById('show-distance-graph').checked) {
                drawDistanceGraph();
            }
        }

        function showGraphHighlight(mouseX, sourceGraph) {
            // Cancel any pending update to prevent race conditions
            if (pendingHighlightUpdate) {
                cancelAnimationFrame(pendingHighlightUpdate);
            }

            // Debounce with requestAnimationFrame for smooth updates
            pendingHighlightUpdate = requestAnimationFrame(() => {
                pendingHighlightUpdate = null;
                showGraphHighlightImmediate(mouseX, sourceGraph);
            });
        }

        function showGraphHighlightImmediate(mouseX, sourceGraph) {
            const canvas = document.getElementById(sourceGraph);
            const rect = canvas.getBoundingClientRect();
            const width = rect.width;

            // Calculate timestamp from mouse X position
            const ratio = Math.max(0, Math.min(1, mouseX / width));
            const timestamp = rangeStartTime + ratio * (rangeEndTime - rangeStartTime);

            // Clear previous highlight markers (explicitly remove tooltips to prevent orphans)
            for (const marker of graphHighlightMarkers) {
                const tooltip = marker.getTooltip();
                marker.closeTooltip();
                if (tooltip && map.hasLayer(tooltip)) {
                    map.removeLayer(tooltip);
                }
                marker.unbindTooltip();
                map.removeLayer(marker);
            }
            graphHighlightMarkers = [];

            // Find and highlight position for each selected user
            let colorIdx = 0;
            for (const [userId, entries] of Object.entries(userData)) {
                const userColor = userColors[colorIdx % userColors.length];
                colorIdx++;

                if (!selectedUsers.has(userId)) continue;

                // Filter entries by time range
                const filtered = entries.filter(e => e.ts >= rangeStartTime && e.ts <= rangeEndTime);
                if (filtered.length === 0) continue;

                // Find closest entry to timestamp
                let closest = filtered[0];
                let closestDist = Math.abs(filtered[0].ts - timestamp);
                for (const entry of filtered) {
                    const dist = Math.abs(entry.ts - timestamp);
                    if (dist < closestDist) {
                        closestDist = dist;
                        closest = entry;
                    }
                }

                // Create highlight marker on map
                const marker = L.circleMarker([closest.lat, closest.lon], {
                    radius: 12,
                    fillColor: userColor,
                    color: '#fff',
                    weight: 3,
                    fillOpacity: 0.9,
                    opacity: 1
                });

                // Add tooltip with info
                const time = formatTimeInTz(closest.ts);
                let tooltipHtml = `
                    <b>${getDisplayName(userId)}</b><br>
                    Time: ${time}<br>
                    Battery: ${closest.bat !== undefined ? closest.bat + '%' : 'N/A'}<br>
                    Speed: ${(closest.spd || 0).toFixed(1)} kts`;

                // Add accuracy if available
                if (closest.hac !== undefined) {
                    const hacColor = closest.hac > 50 ? '#e74c3c' : closest.hac > 20 ? '#f39c12' : '#2ecc71';
                    tooltipHtml += `<br>Accuracy: <span style="color:${hacColor}">${closest.hac.toFixed(1)}m</span>`;
                }

                // Add signal strength if available
                if (closest.sig !== undefined && closest.sig !== null) {
                    const sigBars = '‚ñÇ‚ñÑ‚ñÜ‚ñà'.slice(0, Math.max(1, Math.min(4, closest.sig)));
                    tooltipHtml += `<br>Signal: ${sigBars} (${closest.sig})`;
                }

                // Add latency if available
                const latency = getNetworkLatency(closest);
                if (latency !== null && Math.abs(latency) < 300) {
                    let latencyColor, latencyText;
                    if (latency < 0) {
                        // Negative = phone clock ahead of server
                        latencyColor = '#9b59b6'; // Purple for clock ahead
                        latencyText = `${latency.toFixed(1)}s (clock ahead)`;
                    } else {
                        latencyColor = latency > 5 ? '#e74c3c' : latency > 2 ? '#f39c12' : '#2ecc71';
                        latencyText = `${latency.toFixed(1)}s`;
                    }
                    tooltipHtml += `<br>Latency: <span style="color:${latencyColor}">${latencyText}</span>`;
                }

                // Add heart rate if available (search nearby entries since HR only sent every ~10 samples)
                let hrValue = closest.hr;
                if (hrValue === undefined || hrValue <= 0) {
                    // Search nearby entries for HR data (within 15 seconds)
                    for (const entry of filtered) {
                        if (Math.abs(entry.ts - closest.ts) <= 15 && entry.hr !== undefined && entry.hr > 0) {
                            hrValue = entry.hr;
                            break;
                        }
                    }
                }
                if (hrValue !== undefined && hrValue > 0) {
                    tooltipHtml += `<br>Heart Rate: <span style="color:#e91e63">${hrValue} bpm</span>`;
                }

                // Add battery saver warning if active
                if (closest.flg) {
                    if (closest.flg.ps) {
                        tooltipHtml += `<br><span style="color:#e74c3c">‚ö†Ô∏è Battery Saver ON</span>`;
                    }
                    if (closest.flg.bo === false) {
                        tooltipHtml += `<br><span style="color:#f39c12">‚ö†Ô∏è Battery Opt OFF</span>`;
                    }
                }

                marker.bindTooltip(tooltipHtml, { permanent: true, direction: 'top', offset: [0, -10] });

                marker.addTo(map);
                graphHighlightMarkers.push(marker);
            }

            // Redraw graphs with highlight line
            drawGraphsWithHighlight(mouseX, ratio);
        }

        function drawGraphsWithHighlight(highlightX, ratio) {
            const timestamp = rangeStartTime + ratio * (rangeEndTime - rangeStartTime);

            // Draw speed graph with highlight if visible
            if (document.getElementById('show-speed-graph').checked) {
                drawSpeedGraph();
                // Calculate speed range for proper scaling (only from visible time range)
                let maxSpeed = 0;
                let hasSpeedData = false;
                for (const [userId, entries] of Object.entries(userData)) {
                    if (!selectedUsers.has(userId)) continue;
                    for (const entry of entries) {
                        if (entry.ts < rangeStartTime || entry.ts > rangeEndTime) continue;
                        if (entry.spd !== undefined && entry.spd !== null && entry.spd >= 0) {
                            maxSpeed = Math.max(maxSpeed, entry.spd);
                            hasSpeedData = true;
                        }
                    }
                }
                if (!hasSpeedData || maxSpeed === 0) {
                    maxSpeed = 20;
                } else {
                    maxSpeed = Math.ceil((maxSpeed * 1.1) / 2) * 2;
                    if (maxSpeed < 5) maxSpeed = 5;
                }
                drawHighlightOnGraph('speed-graph', highlightX, ratio, timestamp, 'spd', maxSpeed, 0);
            }

            // Draw battery graph with highlight if visible
            if (document.getElementById('show-battery-graph').checked) {
                drawBatteryGraph();
                // Calculate battery range for proper scaling
                let maxBat = 0;
                let minBat = 100;
                let hasBatData = false;
                for (const [userId, entries] of Object.entries(userData)) {
                    if (!selectedUsers.has(userId)) continue;
                    for (const entry of entries) {
                        if (entry.ts < rangeStartTime || entry.ts > rangeEndTime) continue;
                        if (entry.bat !== undefined && entry.bat !== null && entry.bat >= 0) {
                            maxBat = Math.max(maxBat, entry.bat);
                            minBat = Math.min(minBat, entry.bat);
                            hasBatData = true;
                        }
                    }
                }
                if (!hasBatData) {
                    maxBat = 100;
                    minBat = 0;
                } else {
                    maxBat = maxBat > 95 ? 100 : Math.ceil((maxBat + 5) / 5) * 5;
                    minBat = Math.floor(minBat / 5) * 5;
                    if (maxBat - minBat < 10) {
                        if (maxBat < 100) maxBat = Math.min(100, minBat + 10);
                        else minBat = Math.max(0, maxBat - 10);
                    }
                }
                drawHighlightOnGraph('battery-graph', highlightX, ratio, timestamp, 'bat', maxBat, minBat);
            }

            // Draw signal graph with highlight if visible
            if (document.getElementById('show-signal-graph').checked) {
                drawSignalGraph();
                drawHighlightOnGraph('signal-graph', highlightX, ratio, timestamp, 'sig', 4);
            }

            // Draw latency graph with highlight if visible
            if (document.getElementById('show-latency-graph').checked) {
                drawLatencyGraph();
                // Calculate current max latency for proper scaling (only from visible time range)
                let maxLatency = 0;
                let hasLatencyValues = false;
                for (const [userId, entries] of Object.entries(userData)) {
                    if (!selectedUsers.has(userId)) continue;
                    for (const entry of entries) {
                        if (entry.ts < rangeStartTime || entry.ts > rangeEndTime) continue;
                        const latency = getNetworkLatency(entry);
                        if (latency !== null && Math.abs(latency) < 300) {
                            maxLatency = Math.max(maxLatency, Math.abs(latency));
                            hasLatencyValues = true;
                        }
                    }
                }
                if (!hasLatencyValues || maxLatency === 0) {
                    maxLatency = 10;
                } else {
                    maxLatency = maxLatency * 1.1;
                    if (maxLatency < 2) {
                        maxLatency = Math.ceil(maxLatency * 4) / 4;
                        if (maxLatency < 0.5) maxLatency = 0.5;
                    } else if (maxLatency < 5) {
                        maxLatency = Math.ceil(maxLatency);
                    } else {
                        maxLatency = Math.ceil(maxLatency / 2) * 2;
                    }
                }
                drawLatencyHighlightOnGraph('latency-graph', highlightX, ratio, timestamp, maxLatency);
            }

            // Draw heart rate graph with highlight if visible
            if (document.getElementById('show-heartrate-graph').checked) {
                drawHeartRateGraph();
                // Calculate heart rate range for proper scaling (only from visible time range)
                let maxHR = 0;
                let minHR = Infinity;
                let hasHRData = false;
                for (const [userId, entries] of Object.entries(userData)) {
                    if (!selectedUsers.has(userId)) continue;
                    for (const entry of entries) {
                        if (entry.ts < rangeStartTime || entry.ts > rangeEndTime) continue;
                        if (entry.hr !== undefined && entry.hr > 0) {
                            maxHR = Math.max(maxHR, entry.hr);
                            minHR = Math.min(minHR, entry.hr);
                            hasHRData = true;
                        }
                    }
                }
                if (!hasHRData || maxHR === 0) {
                    maxHR = 200;
                    minHR = 0;
                } else {
                    maxHR = Math.ceil((maxHR * 1.1) / 10) * 10;
                    minHR = Math.max(0, Math.floor((minHR * 0.9) / 10) * 10);
                    if (maxHR - minHR < 40) {
                        const mid = (maxHR + minHR) / 2;
                        maxHR = Math.ceil((mid + 20) / 10) * 10;
                        minHR = Math.max(0, Math.floor((mid - 20) / 10) * 10);
                    }
                }
                drawHighlightOnGraph('heartrate-graph', highlightX, ratio, timestamp, 'hr', maxHR, minHR);
            }

            // Draw accuracy graph with highlight if visible
            if (document.getElementById('show-accuracy-graph').checked) {
                drawAccuracyGraph();
                // Calculate accuracy range for proper scaling (only from visible time range)
                let maxAcc = 0;
                let hasAccData = false;
                for (const [userId, entries] of Object.entries(userData)) {
                    if (!selectedUsers.has(userId)) continue;
                    for (const entry of entries) {
                        if (entry.ts < rangeStartTime || entry.ts > rangeEndTime) continue;
                        if (entry.hac !== undefined && entry.hac > 0) {
                            maxAcc = Math.max(maxAcc, entry.hac);
                            hasAccData = true;
                        }
                    }
                }
                if (!hasAccData || maxAcc === 0) {
                    maxAcc = 100;
                } else {
                    maxAcc = Math.ceil((maxAcc * 1.1) / 10) * 10;
                    maxAcc = Math.max(maxAcc, 10);
                }
                drawHighlightOnGraph('accuracy-graph', highlightX, ratio, timestamp, 'hac', maxAcc, 0);
            }
        }

        function drawLatencyHighlightOnGraph(canvasId, highlightX, ratio, timestamp, maxLatency) {
            const canvas = document.getElementById(canvasId);
            const ctx = canvas.getContext('2d');
            const rect = canvas.getBoundingClientRect();
            const height = rect.height;

            // Draw vertical highlight line
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 3]);
            ctx.beginPath();
            ctx.moveTo(highlightX * window.devicePixelRatio, 0);
            ctx.lineTo(highlightX * window.devicePixelRatio, height * window.devicePixelRatio);
            ctx.stroke();
            ctx.setLineDash([]);

            // Draw dots at intersection points
            let colorIdx = 0;
            for (const [userId, entries] of Object.entries(userData)) {
                const userColor = userColors[colorIdx % userColors.length];
                colorIdx++;

                if (!selectedUsers.has(userId)) continue;

                const filtered = entries.filter(e => e.ts >= rangeStartTime && e.ts <= rangeEndTime);
                if (filtered.length === 0) continue;

                // Find closest entry
                let closest = filtered[0];
                let closestDist = Math.abs(filtered[0].ts - timestamp);
                for (const entry of filtered) {
                    const dist = Math.abs(entry.ts - timestamp);
                    if (dist < closestDist) {
                        closestDist = dist;
                        closest = entry;
                    }
                }

                const rawLatency = getNetworkLatency(closest);
                if (rawLatency !== null) {
                    const latency = Math.abs(rawLatency);
                    if (latency < 300) {
                        const x = ((closest.ts - rangeStartTime) / (rangeEndTime - rangeStartTime)) * rect.width;
                        const y = height - (latency / maxLatency) * height;

                        ctx.beginPath();
                        ctx.arc(x * window.devicePixelRatio, y * window.devicePixelRatio, 6 * window.devicePixelRatio, 0, Math.PI * 2);
                        ctx.fillStyle = userColor;
                        ctx.fill();
                        ctx.strokeStyle = '#fff';
                        ctx.lineWidth = 2 * window.devicePixelRatio;
                        ctx.stroke();
                    }
                }
            }
        }

        function drawHighlightOnGraph(canvasId, highlightX, ratio, timestamp, dataField, maxValue, minValue = 0) {
            const canvas = document.getElementById(canvasId);
            const ctx = canvas.getContext('2d');
            const rect = canvas.getBoundingClientRect();
            const height = rect.height;
            const valueRange = maxValue - minValue;

            // Draw vertical highlight line
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 3]);
            ctx.beginPath();
            ctx.moveTo(highlightX * window.devicePixelRatio, 0);
            ctx.lineTo(highlightX * window.devicePixelRatio, height * window.devicePixelRatio);
            ctx.stroke();
            ctx.setLineDash([]);

            // Draw dots at intersection points
            let colorIdx = 0;
            for (const [userId, entries] of Object.entries(userData)) {
                const userColor = userColors[colorIdx % userColors.length];
                colorIdx++;

                if (!selectedUsers.has(userId)) continue;

                const filtered = entries.filter(e => e.ts >= rangeStartTime && e.ts <= rangeEndTime);
                if (filtered.length === 0) continue;

                // Find closest entry
                let closest = filtered[0];
                let closestDist = Math.abs(filtered[0].ts - timestamp);
                for (const entry of filtered) {
                    const dist = Math.abs(entry.ts - timestamp);
                    if (dist < closestDist) {
                        closestDist = dist;
                        closest = entry;
                    }
                }

                const value = closest[dataField];
                if (value !== undefined && value !== null) {
                    const x = ((closest.ts - rangeStartTime) / (rangeEndTime - rangeStartTime)) * rect.width;
                    const y = height - ((value - minValue) / valueRange) * height;

                    ctx.beginPath();
                    ctx.arc(x * window.devicePixelRatio, y * window.devicePixelRatio, 6 * window.devicePixelRatio, 0, Math.PI * 2);
                    ctx.fillStyle = userColor;
                    ctx.fill();
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2 * window.devicePixelRatio;
                    ctx.stroke();
                }
            }
        }

        // Set up graph mouse events
        document.getElementById('speed-graph').addEventListener('mousemove', (e) => {
            const rect = e.target.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            showGraphHighlight(mouseX, 'speed-graph');
        });

        document.getElementById('speed-graph').addEventListener('mouseleave', () => {
            clearGraphHighlight();
        });

        document.getElementById('battery-graph').addEventListener('mousemove', (e) => {
            const rect = e.target.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            showGraphHighlight(mouseX, 'battery-graph');
        });

        document.getElementById('battery-graph').addEventListener('mouseleave', () => {
            clearGraphHighlight();
        });

        document.getElementById('signal-graph').addEventListener('mousemove', (e) => {
            const rect = e.target.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            showGraphHighlight(mouseX, 'signal-graph');
        });

        document.getElementById('signal-graph').addEventListener('mouseleave', () => {
            clearGraphHighlight();
        });

        document.getElementById('latency-graph').addEventListener('mousemove', (e) => {
            const rect = e.target.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            showGraphHighlight(mouseX, 'latency-graph');
        });

        document.getElementById('latency-graph').addEventListener('mouseleave', () => {
            clearGraphHighlight();
        });

        document.getElementById('heartrate-graph').addEventListener('mousemove', (e) => {
            const rect = e.target.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            showGraphHighlight(mouseX, 'heartrate-graph');
        });

        document.getElementById('heartrate-graph').addEventListener('mouseleave', () => {
            clearGraphHighlight();
        });

        document.getElementById('accuracy-graph').addEventListener('mousemove', (e) => {
            const rect = e.target.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            showGraphHighlight(mouseX, 'accuracy-graph');
        });

        document.getElementById('accuracy-graph').addEventListener('mouseleave', () => {
            clearGraphHighlight();
        });

        document.getElementById('distance-graph').addEventListener('mousemove', (e) => {
            const rect = e.target.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            showGraphHighlight(mouseX, 'distance-graph');

            // Update title with distance at cursor position
            const ratio = Math.max(0, Math.min(1, mouseX / rect.width));
            const timestamp = rangeStartTime + ratio * (rangeEndTime - rangeStartTime);

            // Find the distance at this timestamp (use first selected user's data)
            let distAtCursor = null;
            for (const [userId, distances] of Object.entries(cachedDistanceData)) {
                if (distances.length === 0) continue;
                // Find closest point before or at timestamp
                let closest = distances[0];
                for (const point of distances) {
                    if (point.ts <= timestamp) {
                        closest = point;
                    } else {
                        break;
                    }
                }
                distAtCursor = closest.dist;
                break;  // Just use first user for now
            }

            const titleEl = document.querySelector('.distance-graph-title');
            if (distAtCursor !== null) {
                const label = distAtCursor >= 1000 ? `${(distAtCursor / 1000).toFixed(2)}km` : `${Math.round(distAtCursor)}m`;
                titleEl.textContent = `Distance: ${label}`;
            } else {
                titleEl.textContent = 'Distance (meters)';
            }
        });

        document.getElementById('distance-graph').addEventListener('mouseleave', () => {
            clearGraphHighlight();
            // Reset title
            document.querySelector('.distance-graph-title').textContent = 'Distance (meters)';
        });

        // Graph resize functionality
        let speedGraphHeight = parseInt(localStorage.getItem('speedGraphHeight')) || 150;
        let batteryGraphHeight = parseInt(localStorage.getItem('batteryGraphHeight')) || 150;
        let signalGraphHeight = parseInt(localStorage.getItem('signalGraphHeight')) || 150;
        let latencyGraphHeight = parseInt(localStorage.getItem('latencyGraphHeight')) || 150;
        let heartrateGraphHeight = parseInt(localStorage.getItem('heartrateGraphHeight')) || 150;
        let accuracyGraphHeight = parseInt(localStorage.getItem('accuracyGraphHeight')) || 150;
        let distanceGraphHeight = parseInt(localStorage.getItem('distanceGraphHeight')) || 150;
        const speedPanel = document.getElementById('speed-graph-panel');
        const batteryPanel = document.getElementById('battery-graph-panel');
        const signalPanel = document.getElementById('signal-graph-panel');
        const latencyPanel = document.getElementById('latency-graph-panel');
        const heartratePanel = document.getElementById('heartrate-graph-panel');
        const accuracyPanel = document.getElementById('accuracy-graph-panel');
        const distancePanel = document.getElementById('distance-graph-panel');
        const speedResizeHandle = document.getElementById('speed-graph-resize');
        const batteryResizeHandle = document.getElementById('battery-graph-resize');
        const signalResizeHandle = document.getElementById('signal-graph-resize');
        const latencyResizeHandle = document.getElementById('latency-graph-resize');
        const heartrateResizeHandle = document.getElementById('heartrate-graph-resize');
        const accuracyResizeHandle = document.getElementById('accuracy-graph-resize');
        const distanceResizeHandle = document.getElementById('distance-graph-resize');
        let isResizing = false;
        let resizingPanel = null;
        let startY = 0;
        let startHeight = 0;

        // Apply saved heights
        speedPanel.style.height = speedGraphHeight + 'px';
        batteryPanel.style.height = batteryGraphHeight + 'px';
        signalPanel.style.height = signalGraphHeight + 'px';
        latencyPanel.style.height = latencyGraphHeight + 'px';
        heartratePanel.style.height = heartrateGraphHeight + 'px';
        accuracyPanel.style.height = accuracyGraphHeight + 'px';
        distancePanel.style.height = distanceGraphHeight + 'px';

        function updateGraphPositions() {
            const mapEl = document.getElementById('map');
            const speedVisible = document.getElementById('show-speed-graph').checked;
            const batteryVisible = document.getElementById('show-battery-graph').checked;
            const signalVisible = document.getElementById('show-signal-graph').checked;
            const latencyVisible = document.getElementById('show-latency-graph').checked;
            const heartrateVisible = document.getElementById('show-heartrate-graph').checked;
            const accuracyVisible = document.getElementById('show-accuracy-graph').checked;
            const distanceVisible = document.getElementById('show-distance-graph').checked;

            // Get actual timeline height (different on mobile vs desktop)
            const timelineHeight = document.getElementById('timeline').offsetHeight;
            let totalHeight = timelineHeight;
            let currentBottom = timelineHeight;

            // Stack from bottom: distance, accuracy, heartrate, latency, signal, battery, speed
            if (distanceVisible) {
                distancePanel.style.display = 'block';
                distancePanel.style.bottom = currentBottom + 'px';
                currentBottom += distanceGraphHeight;
                totalHeight += distanceGraphHeight;
            } else {
                distancePanel.style.display = 'none';
            }

            if (accuracyVisible) {
                accuracyPanel.style.display = 'block';
                accuracyPanel.style.bottom = currentBottom + 'px';
                currentBottom += accuracyGraphHeight;
                totalHeight += accuracyGraphHeight;
            } else {
                accuracyPanel.style.display = 'none';
            }

            if (heartrateVisible) {
                heartratePanel.style.display = 'block';
                heartratePanel.style.bottom = currentBottom + 'px';
                currentBottom += heartrateGraphHeight;
                totalHeight += heartrateGraphHeight;
            } else {
                heartratePanel.style.display = 'none';
            }

            if (latencyVisible) {
                latencyPanel.style.display = 'block';
                latencyPanel.style.bottom = currentBottom + 'px';
                currentBottom += latencyGraphHeight;
                totalHeight += latencyGraphHeight;
            } else {
                latencyPanel.style.display = 'none';
            }

            if (signalVisible) {
                signalPanel.style.display = 'block';
                signalPanel.style.bottom = currentBottom + 'px';
                currentBottom += signalGraphHeight;
                totalHeight += signalGraphHeight;
            } else {
                signalPanel.style.display = 'none';
            }

            if (batteryVisible) {
                batteryPanel.style.display = 'block';
                batteryPanel.style.bottom = currentBottom + 'px';
                currentBottom += batteryGraphHeight;
                totalHeight += batteryGraphHeight;
            } else {
                batteryPanel.style.display = 'none';
            }

            if (speedVisible) {
                speedPanel.style.display = 'block';
                speedPanel.style.bottom = currentBottom + 'px';
                totalHeight += speedGraphHeight;
            } else {
                speedPanel.style.display = 'none';
            }

            mapEl.style.bottom = totalHeight + 'px';
            map.invalidateSize();

            // Update speed legend and scale positions to stay above graphs
            document.querySelector('.speed-legend').style.bottom = (totalHeight + 20) + 'px';
            document.getElementById('customScale').style.bottom = (totalHeight + 95) + 'px';
        }

        speedResizeHandle.addEventListener('mousedown', (e) => {
            isResizing = true;
            resizingPanel = 'speed';
            startY = e.clientY;
            startHeight = speedGraphHeight;
            speedResizeHandle.classList.add('dragging');
            document.body.style.cursor = 'ns-resize';
            document.body.style.userSelect = 'none';
            e.preventDefault();
        });

        batteryResizeHandle.addEventListener('mousedown', (e) => {
            isResizing = true;
            resizingPanel = 'battery';
            startY = e.clientY;
            startHeight = batteryPanel.offsetHeight;
            batteryResizeHandle.classList.add('dragging');
            document.body.style.cursor = 'ns-resize';
            document.body.style.userSelect = 'none';
            e.preventDefault();
        });

        signalResizeHandle.addEventListener('mousedown', (e) => {
            isResizing = true;
            resizingPanel = 'signal';
            startY = e.clientY;
            startHeight = signalPanel.offsetHeight;
            signalResizeHandle.classList.add('dragging');
            document.body.style.cursor = 'ns-resize';
            document.body.style.userSelect = 'none';
            e.preventDefault();
        });

        latencyResizeHandle.addEventListener('mousedown', (e) => {
            isResizing = true;
            resizingPanel = 'latency';
            startY = e.clientY;
            startHeight = latencyPanel.offsetHeight;
            latencyResizeHandle.classList.add('dragging');
            document.body.style.cursor = 'ns-resize';
            document.body.style.userSelect = 'none';
            e.preventDefault();
        });

        heartrateResizeHandle.addEventListener('mousedown', (e) => {
            isResizing = true;
            resizingPanel = 'heartrate';
            startY = e.clientY;
            startHeight = heartratePanel.offsetHeight;
            heartrateResizeHandle.classList.add('dragging');
            document.body.style.cursor = 'ns-resize';
            document.body.style.userSelect = 'none';
            e.preventDefault();
        });

        accuracyResizeHandle.addEventListener('mousedown', (e) => {
            isResizing = true;
            resizingPanel = 'accuracy';
            startY = e.clientY;
            startHeight = accuracyPanel.offsetHeight;
            accuracyResizeHandle.classList.add('dragging');
            document.body.style.cursor = 'ns-resize';
            document.body.style.userSelect = 'none';
            e.preventDefault();
        });

        distanceResizeHandle.addEventListener('mousedown', (e) => {
            isResizing = true;
            resizingPanel = 'distance';
            startY = e.clientY;
            startHeight = distancePanel.offsetHeight;
            distanceResizeHandle.classList.add('dragging');
            document.body.style.cursor = 'ns-resize';
            document.body.style.userSelect = 'none';
            e.preventDefault();
        });

        document.addEventListener('mousemove', (e) => {
            if (!isResizing) return;

            const deltaY = startY - e.clientY;
            const newHeight = Math.max(80, Math.min(400, startHeight + deltaY));

            if (resizingPanel === 'speed') {
                speedPanel.style.height = newHeight + 'px';
                speedGraphHeight = newHeight;
            } else if (resizingPanel === 'battery') {
                batteryPanel.style.height = newHeight + 'px';
                batteryGraphHeight = newHeight;
            } else if (resizingPanel === 'signal') {
                signalPanel.style.height = newHeight + 'px';
                signalGraphHeight = newHeight;
            } else if (resizingPanel === 'latency') {
                latencyPanel.style.height = newHeight + 'px';
                latencyGraphHeight = newHeight;
            } else if (resizingPanel === 'heartrate') {
                heartratePanel.style.height = newHeight + 'px';
                heartrateGraphHeight = newHeight;
            } else if (resizingPanel === 'accuracy') {
                accuracyPanel.style.height = newHeight + 'px';
                accuracyGraphHeight = newHeight;
            } else if (resizingPanel === 'distance') {
                distancePanel.style.height = newHeight + 'px';
                distanceGraphHeight = newHeight;
            }

            updateGraphPositions();

            // Redraw graphs at new size
            drawSpeedGraph();
            drawSpeedGraph();
            drawBatteryGraph();
            drawSignalGraph();
            drawLatencyGraph();
            drawHeartRateGraph();
            drawAccuracyGraph();
            drawDistanceGraph();
        });

        document.addEventListener('mouseup', () => {
            if (isResizing) {
                isResizing = false;
                speedResizeHandle.classList.remove('dragging');
                batteryResizeHandle.classList.remove('dragging');
                signalResizeHandle.classList.remove('dragging');
                latencyResizeHandle.classList.remove('dragging');
                heartrateResizeHandle.classList.remove('dragging');
                accuracyResizeHandle.classList.remove('dragging');
                distanceResizeHandle.classList.remove('dragging');
                document.body.style.cursor = '';
                document.body.style.userSelect = '';
                localStorage.setItem('speedGraphHeight', speedGraphHeight);
                localStorage.setItem('batteryGraphHeight', batteryGraphHeight);
                localStorage.setItem('signalGraphHeight', signalGraphHeight);
                localStorage.setItem('latencyGraphHeight', latencyGraphHeight);
                localStorage.setItem('heartrateGraphHeight', heartrateGraphHeight);
                localStorage.setItem('accuracyGraphHeight', accuracyGraphHeight);
                localStorage.setItem('distanceGraphHeight', distanceGraphHeight);
                resizingPanel = null;
            }
        });

        function zoomToUser(userId) {
            if (!userData[userId]) return;

            const entries = userData[userId];
            if (entries.length === 0) return;

            // Select only this user
            selectedUsers.clear();
            document.querySelectorAll('.user-item').forEach(el => el.classList.remove('selected'));

            selectedUsers.add(userId);
            const element = document.querySelector(`.user-item[data-user-id="${userId}"]`);
            if (element) element.classList.add('selected');

            // Reset playback to show all of this user's data
            resetPlaybackToSelection();

            // Zoom to all of user's points
            const coords = entries.map(e => [e.lat, e.lon]);
            map.fitBounds(coords, { padding: [50, 50] });
        }

        function getSelectedTimeRange() {
            // Get time range for selected users only
            let selMinTime = Infinity;
            let selMaxTime = -Infinity;

            for (const userId of selectedUsers) {
                if (userData[userId] && userData[userId].length > 0) {
                    const entries = userData[userId];
                    selMinTime = Math.min(selMinTime, entries[0].ts);
                    selMaxTime = Math.max(selMaxTime, entries[entries.length - 1].ts);
                }
            }

            // Fall back to global range if no users selected
            if (selMinTime === Infinity) {
                return { min: minTime, max: maxTime };
            }

            return { min: selMinTime, max: selMaxTime };
        }

        function timeToSliderValue(timestamp) {
            // Convert timestamp to slider value (0-100) based on current slider range
            if (sliderMaxTime === sliderMinTime) return 100;
            return ((timestamp - sliderMinTime) / (sliderMaxTime - sliderMinTime)) * 100;
        }

        function sliderValueToTime(value) {
            // Convert slider value (0-100) to timestamp based on current slider range
            return sliderMinTime + (sliderMaxTime - sliderMinTime) * (value / 100);
        }

        function timeToGlobalPercent(timestamp) {
            // Convert timestamp to percentage of global log range (for URLs)
            if (maxTime === minTime) return 100;
            return ((timestamp - minTime) / (maxTime - minTime)) * 100;
        }

        function globalPercentToTime(percent) {
            // Convert percentage of global log range to timestamp (for URLs)
            return minTime + (maxTime - minTime) * (percent / 100);
        }

        function updateSliderEndpoints() {
            // Update slider endpoints based on selected users' data range
            const range = getSelectedTimeRange();
            sliderMinTime = range.min;
            sliderMaxTime = range.max;

            // Update edge labels
            document.getElementById('label-start').textContent = formatTimeInTz(sliderMinTime);
            document.getElementById('label-end').textContent = formatTimeInTz(sliderMaxTime);

            // Convert current time selection to new slider percentages
            const startSlider = document.getElementById('start-slider');
            const endSlider = document.getElementById('end-slider');

            // Clamp rangeStartTime/rangeEndTime to new slider range
            let clampedStart = Math.max(sliderMinTime, Math.min(sliderMaxTime, rangeStartTime));
            let clampedEnd = Math.max(sliderMinTime, Math.min(sliderMaxTime, rangeEndTime));

            // Check if any selected user has visible data in the clamped range
            let hasVisibleData = false;
            if (clampedEnd > clampedStart) {
                for (const userId of selectedUsers) {
                    if (userData[userId]) {
                        const visiblePoints = userData[userId].filter(
                            e => e.ts >= clampedStart && e.ts <= clampedEnd
                        );
                        if (visiblePoints.length >= 2) {
                            hasVisibleData = true;
                            break;
                        }
                    }
                }
            }

            // If no visible data, reset to full range of selected users
            if (selectedUsers.size > 0 && !hasVisibleData) {
                clampedStart = sliderMinTime;
                clampedEnd = sliderMaxTime;
            }

            // Update rangeStartTime/rangeEndTime if they were clamped
            rangeStartTime = clampedStart;
            rangeEndTime = clampedEnd;

            // Update slider positions
            startSlider.value = timeToSliderValue(clampedStart);
            endSlider.value = timeToSliderValue(clampedEnd);

            // Update visual range indicator
            updateSliderRange();
        }

        // Options dropdown toggle
        document.getElementById('options-btn').addEventListener('click', (e) => {
            e.stopPropagation();
            document.getElementById('options-dropdown-content').classList.toggle('show');
            document.getElementById('graphs-dropdown-content').classList.remove('show');
            document.getElementById('export-dropdown-content').classList.remove('show');
        });

        // Graphs dropdown toggle
        document.getElementById('graphs-btn').addEventListener('click', (e) => {
            e.stopPropagation();
            document.getElementById('graphs-dropdown-content').classList.toggle('show');
            document.getElementById('options-dropdown-content').classList.remove('show');
            document.getElementById('export-dropdown-content').classList.remove('show');
        });

        // Export dropdown toggle
        document.getElementById('export-btn').addEventListener('click', (e) => {
            e.stopPropagation();
            document.getElementById('export-dropdown-content').classList.toggle('show');
            document.getElementById('options-dropdown-content').classList.remove('show');
            document.getElementById('graphs-dropdown-content').classList.remove('show');
        });

        // Close dropdowns when clicking outside
        document.addEventListener('click', (e) => {
            const graphsDropdown = document.getElementById('graphs-dropdown-content');
            const graphsBtn = document.getElementById('graphs-btn');
            const optionsDropdown = document.getElementById('options-dropdown-content');
            const optionsBtn = document.getElementById('options-btn');
            const exportDropdown = document.getElementById('export-dropdown-content');
            const exportBtn = document.getElementById('export-btn');

            if (!graphsDropdown.contains(e.target) && e.target !== graphsBtn) {
                graphsDropdown.classList.remove('show');
            }
            if (!optionsDropdown.contains(e.target) && e.target !== optionsBtn) {
                optionsDropdown.classList.remove('show');
            }
            if (!exportDropdown.contains(e.target) && e.target !== exportBtn) {
                exportDropdown.classList.remove('show');
            }
        });

        // About modal
        document.getElementById('about-btn').addEventListener('click', () => {
            document.getElementById('about-modal').classList.add('show');
        });

        document.getElementById('about-close-btn').addEventListener('click', () => {
            document.getElementById('about-modal').classList.remove('show');
        });

        // Reload tiles button - forces refresh of map tiles
        document.getElementById('reload-tiles-btn').addEventListener('click', () => {
            // Remove and re-add the current tile layer to force reload
            if (currentMapType === 'osm') {
                map.removeLayer(osmLayer);
                map.addLayer(osmLayer);
            } else if (googleLayers[currentMapType]) {
                map.removeLayer(googleLayers[currentMapType]);
                map.addLayer(googleLayers[currentMapType]);
            }
        });

        document.getElementById('about-modal').addEventListener('click', (e) => {
            if (e.target.id === 'about-modal') {
                document.getElementById('about-modal').classList.remove('show');
            }
        });

        document.getElementById('start-slider').addEventListener('input', (e) => {
            const startVal = parseFloat(e.target.value);
            const endVal = parseFloat(document.getElementById('end-slider').value);
            // Don't let start go past end
            if (startVal > endVal) {
                e.target.value = endVal;
            }
            // Update visual indicators immediately (cheap)
            updateSliderRange();
            updateTimeDisplay();
            // Reset playback when slider moves
            resetPlaybackPosition();
            // Debounce expensive redraws until slider stops moving
            debouncedRedrawAll();
        });

        document.getElementById('end-slider').addEventListener('input', (e) => {
            const endVal = parseFloat(e.target.value);
            const startVal = parseFloat(document.getElementById('start-slider').value);
            // Don't let end go before start
            if (endVal < startVal) {
                e.target.value = startVal;
            }
            // Update visual indicators immediately (cheap)
            updateSliderRange();
            updateTimeDisplay();
            // Reset playback when slider moves
            resetPlaybackPosition();
            // Debounce expensive redraws until slider stops moving
            debouncedRedrawAll();
        });

        document.getElementById('speed-color').addEventListener('change', () => {
            drawTracks();
        });

        document.getElementById('show-markers').addEventListener('change', () => {
            drawTracks();
        });

        document.getElementById('filter-outliers').addEventListener('change', () => {
            drawTracks();
        });

        document.getElementById('show-outliers').addEventListener('change', () => {
            drawTracks();
        });

        document.getElementById('show-course').addEventListener('change', (e) => {
            showCourse = e.target.checked;
            if (showCourse && currentCourseFile) {
                // Re-load and display course
                const courseFilename = currentCourseFile;
                currentCourseFile = null;  // Reset to force reload
                loadCourse(courseFilename);
            } else {
                clearCourseDisplay();
            }
        });

        document.getElementById('show-speed-graph').addEventListener('change', (e) => {
            updateGraphPositions();
            if (e.target.checked) {
                drawSpeedGraph();
            }
        });

        document.getElementById('show-battery-graph').addEventListener('change', (e) => {
            updateGraphPositions();
            if (e.target.checked) {
                drawBatteryGraph();
            }
        });

        document.getElementById('show-signal-graph').addEventListener('change', (e) => {
            updateGraphPositions();
            if (e.target.checked) {
                drawSignalGraph();
            }
        });

        document.getElementById('show-latency-graph').addEventListener('change', (e) => {
            updateGraphPositions();
            if (e.target.checked) {
                drawLatencyGraph();
            }
        });

        document.getElementById('show-heartrate-graph').addEventListener('change', (e) => {
            updateGraphPositions();
            if (e.target.checked) {
                drawHeartRateGraph();
            }
        });

        document.getElementById('show-accuracy-graph').addEventListener('change', (e) => {
            updateGraphPositions();
            if (e.target.checked) {
                drawAccuracyGraph();
            }
        });

        document.getElementById('show-distance-graph').addEventListener('change', (e) => {
            updateGraphPositions();
            if (e.target.checked) {
                drawDistanceGraph();
            }
        });

        document.getElementById('reset-range-btn').addEventListener('click', () => {
            document.getElementById('start-slider').value = 0;
            document.getElementById('end-slider').value = 100;
            updateSliderRange();
            updateTimeDisplay();
            resetPlaybackPosition();
            drawTracks();
            drawSpeedGraph();
            drawBatteryGraph();
            drawSignalGraph();
            drawLatencyGraph();
            drawHeartRateGraph();
            drawAccuracyGraph();
            drawDistanceGraph();
        });

        // Copy shareable link to clipboard
        document.getElementById('copy-link-btn').addEventListener('click', async () => {
            const url = buildShareableUrl();
            try {
                await navigator.clipboard.writeText(url);
                const btn = document.getElementById('copy-link-btn');
                const originalText = btn.textContent;
                btn.textContent = '‚úì Copied!';
                btn.style.background = '#27ae60';
                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.style.background = '#9b59b6';
                }, 2000);
            } catch (err) {
                // Fallback for browsers without clipboard API
                prompt('Copy this link:', url);
            }
        });

        // Playback controls - animate through the selected range
        let playbackCurrentTime = 0;
        let playbackPaused = false;  // true if paused (vs stopped/finished)
        let indicatorDragging = false;  // true while dragging the playback indicator

        function updatePlaybackIndicator() {
            const indicator = document.getElementById('playback-indicator');
            if (playbackCurrentTime <= rangeStartTime || playbackCurrentTime >= rangeEndTime) {
                indicator.style.display = 'none';
                return;
            }
            // Calculate position as percentage of slider range
            const pct = ((playbackCurrentTime - sliderMinTime) / (sliderMaxTime - sliderMinTime)) * 100;
            // Account for thumb width like the slider-range positioning
            indicator.style.left = `calc(10px + ${pct}% - ${pct * 0.2}px)`;
            indicator.style.display = 'block';
        }

        function resetPlaybackPosition() {
            playbackCurrentTime = rangeStartTime;
            playbackPaused = false;
            const indicator = document.getElementById('playback-indicator');
            indicator.style.display = 'none';
            indicator.classList.remove('draggable', 'dragging');
            if (playbackInterval) {
                clearInterval(playbackInterval);
                playbackInterval = null;
                document.getElementById('play-btn').textContent = '‚ñ∂ Play';
            }
        }

        document.getElementById('play-btn').addEventListener('click', function() {
            const indicator = document.getElementById('playback-indicator');
            if (playbackInterval) {
                // Currently playing - pause
                clearInterval(playbackInterval);
                playbackInterval = null;
                playbackPaused = true;
                indicator.classList.add('draggable');  // Enable dragging when paused
                this.textContent = '‚ñ∂ Play';
                // Keep showing current position, don't reset
            } else {
                if (selectedUsers.size === 0) {
                    alert('Select at least one user to play back');
                    return;
                }

                this.textContent = '‚è∏ Pause';

                // Resume from paused position, or start from beginning
                if (!playbackPaused || playbackCurrentTime >= rangeEndTime || playbackCurrentTime < rangeStartTime) {
                    playbackCurrentTime = rangeStartTime;
                }
                playbackPaused = false;
                indicator.classList.remove('draggable', 'dragging');  // Disable dragging when playing

                // Draw initial state
                drawTracksUpTo(playbackCurrentTime);
                updatePlaybackIndicator();

                playbackInterval = setInterval(() => {
                    // Advance time (playbackSpeed seconds per 100ms tick)
                    playbackCurrentTime += playbackSpeed;

                    if (playbackCurrentTime >= rangeEndTime) {
                        playbackCurrentTime = rangeEndTime;
                        clearInterval(playbackInterval);
                        playbackInterval = null;
                        playbackPaused = false;
                        document.getElementById('play-btn').textContent = '‚ñ∂ Play';
                        // Show full tracks when finished
                        drawTracks();
                        indicator.style.display = 'none';
                        indicator.classList.remove('draggable');
                        return;
                    }

                    // Draw tracks up to current playback time
                    drawTracksUpTo(playbackCurrentTime);
                    updatePlaybackIndicator();
                }, 100);
            }
        });

        // Playback indicator drag handling - allows scrubbing when paused
        (function setupIndicatorDrag() {
            const indicator = document.getElementById('playback-indicator');
            const container = document.querySelector('.time-slider-container');

            indicator.addEventListener('mousedown', (e) => {
                if (!playbackPaused) return;
                indicatorDragging = true;
                indicator.classList.add('dragging');
                e.preventDefault();
            });

            document.addEventListener('mousemove', (e) => {
                if (!indicatorDragging) return;

                const rect = container.getBoundingClientRect();
                const x = e.clientX - rect.left;
                // Account for thumb width adjustment (same formula as updateSliderRange)
                const pct = Math.max(0, Math.min(100, ((x - 10) / (rect.width - 20)) * 100));
                const time = sliderMinTime + (sliderMaxTime - sliderMinTime) * (pct / 100);

                // Clamp to selected range
                playbackCurrentTime = Math.max(rangeStartTime, Math.min(rangeEndTime, time));

                // Update display
                updatePlaybackIndicator();
                drawTracksUpTo(playbackCurrentTime);
            });

            document.addEventListener('mouseup', () => {
                if (indicatorDragging) {
                    indicatorDragging = false;
                    indicator.classList.remove('dragging');
                }
            });
        })();

        // Draw tracks up to a specific time (for playback animation)
        function drawTracksUpTo(upToTime) {
            // Clear existing layers
            for (const layer of Object.values(trackLayers)) {
                map.removeLayer(layer);
            }
            for (const layer of Object.values(markerLayers)) {
                map.removeLayer(layer);
            }
            for (const layer of Object.values(pointLayers)) {
                map.removeLayer(layer);
            }
            for (const layer of Object.values(outlierLayers)) {
                map.removeLayer(layer);
            }
            trackLayers = {};
            markerLayers = {};
            pointLayers = {};
            outlierLayers = {};

            const useSpeedColor = document.getElementById('speed-color').checked;
            const showMarkers = document.getElementById('show-markers').checked;
            const doFilterOutliers = document.getElementById('filter-outliers').checked;

            let colorIdx = 0;
            for (const [userId, entries] of Object.entries(userData)) {
                if (!selectedUsers.has(userId)) {
                    colorIdx++;
                    continue;
                }

                const userColor = userColors[colorIdx % userColors.length];
                colorIdx++;

                // Filter: start from rangeStartTime, end at upToTime
                let timeFiltered = entries.filter(e => e.ts >= rangeStartTime && e.ts <= upToTime);
                if (timeFiltered.length < 2) continue;

                // Apply outlier filtering if enabled
                let filtered = timeFiltered;
                if (doFilterOutliers) {
                    const result = filterOutliers(timeFiltered);
                    filtered = result.filtered;
                    // Fall back to unfiltered data if outlier filtering removed too many points
                    if (filtered.length < 2 && timeFiltered.length >= 2) {
                        filtered = timeFiltered;
                    }
                }

                if (filtered.length < 2) continue;

                if (useSpeedColor) {
                    const layerGroup = L.layerGroup();
                    for (let i = 1; i < filtered.length; i++) {
                        const prev = filtered[i-1];
                        const curr = filtered[i];
                        const color = speedToColor(curr.spd || 0);
                        const line = L.polyline(
                            [[prev.lat, prev.lon], [curr.lat, curr.lon]],
                            { color: color, weight: 3, opacity: 0.8 }
                        );
                        layerGroup.addLayer(line);
                    }
                    layerGroup.addTo(map);
                    trackLayers[userId] = layerGroup;
                } else {
                    const coords = filtered.map(e => [e.lat, e.lon]);
                    const polyline = L.polyline(coords, {
                        color: userColor,
                        weight: 3,
                        opacity: 0.8
                    }).addTo(map);
                    trackLayers[userId] = polyline;
                }

                // Add current position marker
                if (showMarkers && filtered.length > 0) {
                    const last = filtered[filtered.length - 1];
                    const marker = L.circleMarker([last.lat, last.lon], {
                        radius: 8,
                        fillColor: userColor,
                        color: '#fff',
                        weight: 2,
                        fillOpacity: 1
                    }).addTo(map);
                    markerLayers[userId] = marker;
                }
            }

            // Update time display during playback
            document.getElementById('time-display').innerHTML =
                `<span style="color:#2ecc71">Start: ${formatTimeInTz(rangeStartTime)}</span> &nbsp;|&nbsp;` +
                `<span style="color:#f39c12">Playing: ${formatTimeInTz(upToTime)}</span> &nbsp;|&nbsp;` +
                `<span style="color:#e74c3c">End: ${formatTimeInTz(rangeEndTime)}</span>`;
        }

        document.getElementById('speed-1x').addEventListener('click', () => playbackSpeed = 1);
        document.getElementById('speed-5x').addEventListener('click', () => playbackSpeed = 5);
        document.getElementById('speed-20x').addEventListener('click', () => playbackSpeed = 20);

        document.getElementById('show-all-btn').addEventListener('click', () => {
            selectedUsers = new Set(Object.keys(userData));
            document.querySelectorAll('.user-item').forEach(el => el.classList.add('selected'));
            resetPlaybackToSelection();
            fitMapToData();
        });

        document.getElementById('hide-all-btn').addEventListener('click', () => {
            selectedUsers.clear();
            document.querySelectorAll('.user-item').forEach(el => el.classList.remove('selected'));
            resetPlaybackToSelection();
        });

        // ===== Export Functions =====

        function downloadFile(content, filename, mimeType) {
            const blob = new Blob([content], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function getExportFilename(extension) {
            const date = document.getElementById('date-picker').value || 'tracks';
            const users = Array.from(selectedUsers).slice(0, 3).join('-') || 'all';
            const suffix = selectedUsers.size > 3 ? `-and${selectedUsers.size - 3}more` : '';
            return `${date}_${users}${suffix}.${extension}`;
        }

        function getFilteredExportData() {
            // Get data for selected users within current time range
            const exportData = [];
            for (const userId of selectedUsers) {
                if (!userData[userId]) continue;
                const filtered = userData[userId].filter(
                    e => e.ts >= rangeStartTime && e.ts <= rangeEndTime
                );
                if (filtered.length > 0) {
                    exportData.push({ userId, entries: filtered });
                }
            }
            return exportData;
        }

        function exportToGPX() {
            const data = getFilteredExportData();
            if (data.length === 0) {
                alert('No data to export. Please select at least one user.');
                return;
            }

            const now = new Date().toISOString();
            let gpx = `<?xml version="1.0" encoding="UTF-8"?>
<gpx version="1.1" creator="Windsurfer Tracker"
     xmlns="http://www.topografix.com/GPX/1/1"
     xmlns:gpxtpx="http://www.garmin.com/xmlschemas/TrackPointExtension/v2">
  <metadata>
    <name>Track Export</name>
    <time>${now}</time>
  </metadata>
`;

            for (const { userId, entries } of data) {
                const displayName = getDisplayName(userId);
                gpx += `  <trk>
    <name>${escapeXml(displayName)}</name>
    <trkseg>
`;
                for (const e of entries) {
                    const time = new Date(e.ts * 1000).toISOString();
                    const speedMs = (e.spd || 0) * 0.514444; // knots to m/s
                    gpx += `      <trkpt lat="${e.lat.toFixed(7)}" lon="${e.lon.toFixed(7)}">
        <time>${time}</time>
        <extensions>
          <gpxtpx:TrackPointExtension>
            <gpxtpx:speed>${speedMs.toFixed(2)}</gpxtpx:speed>
            <gpxtpx:course>${e.hdg || 0}</gpxtpx:course>
          </gpxtpx:TrackPointExtension>
        </extensions>
      </trkpt>
`;
                }
                gpx += `    </trkseg>
  </trk>
`;
            }

            gpx += `</gpx>`;

            downloadFile(gpx, getExportFilename('gpx'), 'application/gpx+xml');
            document.getElementById('export-dropdown-content').classList.remove('show');
        }

        function exportToCSV() {
            const data = getFilteredExportData();
            if (data.length === 0) {
                alert('No data to export. Please select at least one user.');
                return;
            }

            // CSV header
            let csv = 'timestamp,user_id,user_name,latitude,longitude,speed_kn,speed_ms,heading,battery,signal,accuracy,heart_rate\n';

            for (const { userId, entries } of data) {
                const displayName = getDisplayName(userId);
                for (const e of entries) {
                    const time = new Date(e.ts * 1000).toISOString();
                    const speedMs = (e.spd || 0) * 0.514444;
                    csv += `${time},${userId},"${displayName}",${e.lat.toFixed(7)},${e.lon.toFixed(7)},`;
                    csv += `${(e.spd || 0).toFixed(2)},${speedMs.toFixed(2)},${e.hdg || 0},`;
                    csv += `${e.bat !== undefined ? e.bat : ''},${e.sig !== undefined ? e.sig : ''},`;
                    csv += `${e.hac !== undefined ? e.hac.toFixed(1) : ''},${e.hr !== undefined ? e.hr : ''}\n`;
                }
            }

            downloadFile(csv, getExportFilename('csv'), 'text/csv');
            document.getElementById('export-dropdown-content').classList.remove('show');
        }

        function exportToGeoJSON() {
            const data = getFilteredExportData();
            if (data.length === 0) {
                alert('No data to export. Please select at least one user.');
                return;
            }

            const features = [];

            for (const { userId, entries } of data) {
                const displayName = getDisplayName(userId);
                const coordinates = entries.map(e => [e.lon, e.lat]); // GeoJSON uses [lon, lat]
                const timestamps = entries.map(e => new Date(e.ts * 1000).toISOString());
                const speeds = entries.map(e => e.spd || 0);

                features.push({
                    type: 'Feature',
                    properties: {
                        user_id: userId,
                        user_name: displayName,
                        start_time: timestamps[0],
                        end_time: timestamps[timestamps.length - 1],
                        point_count: entries.length,
                        avg_speed_kn: (speeds.reduce((a, b) => a + b, 0) / speeds.length).toFixed(2),
                        max_speed_kn: Math.max(...speeds).toFixed(2)
                    },
                    geometry: {
                        type: 'LineString',
                        coordinates: coordinates
                    }
                });
            }

            const geojson = {
                type: 'FeatureCollection',
                features: features
            };

            downloadFile(JSON.stringify(geojson, null, 2), getExportFilename('geojson'), 'application/geo+json');
            document.getElementById('export-dropdown-content').classList.remove('show');
        }

        function escapeXml(str) {
            return str.replace(/&/g, '&amp;')
                      .replace(/</g, '&lt;')
                      .replace(/>/g, '&gt;')
                      .replace(/"/g, '&quot;')
                      .replace(/'/g, '&apos;');
        }

        // ===== FIT File Encoder =====
        // Minimal FIT encoder for activity files with GPS, speed, and heart rate

        const FIT_EPOCH_OFFSET = 631065600; // Seconds from Unix epoch (1970) to FIT epoch (1989-12-31)

        function toFitTimestamp(unixSeconds) {
            return unixSeconds - FIT_EPOCH_OFFSET;
        }

        function toSemicircles(degrees) {
            // Convert degrees to semicircles (32-bit signed int range)
            return Math.round(degrees * (Math.pow(2, 31) / 180));
        }

        // CRC-16 for FIT files
        const crcTable = new Uint16Array(256);
        (function initCrcTable() {
            for (let i = 0; i < 256; i++) {
                let crc = i;
                for (let j = 0; j < 8; j++) {
                    crc = (crc & 1) ? ((crc >> 1) ^ 0xA001) : (crc >> 1);
                }
                crcTable[i] = crc;
            }
        })();

        function fitCrc(bytes, start = 0, end = bytes.length) {
            let crc = 0;
            for (let i = start; i < end; i++) {
                crc = ((crc >> 8) & 0xFF) ^ crcTable[(crc ^ bytes[i]) & 0xFF];
            }
            return crc;
        }

        class FitEncoder {
            constructor() {
                this.data = [];
                this.localMessageTypes = {};
                this.nextLocalType = 0;
            }

            writeByte(val) {
                this.data.push(val & 0xFF);
            }

            writeUint16(val) {
                this.data.push(val & 0xFF);
                this.data.push((val >> 8) & 0xFF);
            }

            writeUint32(val) {
                this.data.push(val & 0xFF);
                this.data.push((val >> 8) & 0xFF);
                this.data.push((val >> 16) & 0xFF);
                this.data.push((val >> 24) & 0xFF);
            }

            writeSint32(val) {
                // Handle signed 32-bit integers
                this.writeUint32(val >>> 0);
            }

            writeDefinition(localType, globalMesgNum, fields) {
                // Definition message header: bit 6 set for definition
                this.writeByte(0x40 | (localType & 0x0F));
                this.writeByte(0); // Reserved
                this.writeByte(0); // Architecture: 0 = little endian
                this.writeUint16(globalMesgNum);
                this.writeByte(fields.length);

                for (const field of fields) {
                    this.writeByte(field.num);
                    this.writeByte(field.size);
                    this.writeByte(field.baseType);
                }

                this.localMessageTypes[globalMesgNum] = { localType, fields };
            }

            writeData(globalMesgNum, values) {
                const msgType = this.localMessageTypes[globalMesgNum];
                if (!msgType) throw new Error(`No definition for message ${globalMesgNum}`);

                // Data message header
                this.writeByte(msgType.localType & 0x0F);

                for (let i = 0; i < msgType.fields.length; i++) {
                    const field = msgType.fields[i];
                    const val = values[i];

                    switch (field.baseType) {
                        case 0x00: // enum (1 byte)
                        case 0x02: // uint8
                            this.writeByte(val);
                            break;
                        case 0x84: // uint16
                            this.writeUint16(val);
                            break;
                        case 0x86: // uint32
                            this.writeUint32(val);
                            break;
                        case 0x85: // sint32
                            this.writeSint32(val);
                            break;
                        default:
                            // For unknown types, write bytes as-is
                            for (let j = 0; j < field.size; j++) {
                                this.writeByte((val >> (j * 8)) & 0xFF);
                            }
                    }
                }
            }

            getFile() {
                const dataBytes = new Uint8Array(this.data);
                const dataSize = dataBytes.length;

                // Create header (14 bytes for FIT 2.0)
                const header = new Uint8Array(14);
                header[0] = 14; // Header size
                header[1] = 0x20; // Protocol version 2.0
                header[2] = 0x08; // Profile version LSB (2088 = 8.24)
                header[3] = 0x08; // Profile version MSB
                header[4] = dataSize & 0xFF;
                header[5] = (dataSize >> 8) & 0xFF;
                header[6] = (dataSize >> 16) & 0xFF;
                header[7] = (dataSize >> 24) & 0xFF;
                header[8] = 0x2E; // '.'
                header[9] = 0x46; // 'F'
                header[10] = 0x49; // 'I'
                header[11] = 0x54; // 'T'

                // Header CRC (bytes 0-11)
                const headerCrc = fitCrc(header, 0, 12);
                header[12] = headerCrc & 0xFF;
                header[13] = (headerCrc >> 8) & 0xFF;

                // Combine header + data
                const combined = new Uint8Array(header.length + dataBytes.length + 2);
                combined.set(header, 0);
                combined.set(dataBytes, header.length);

                // File CRC (over header + data)
                const fileCrc = fitCrc(combined, 0, header.length + dataBytes.length);
                combined[combined.length - 2] = fileCrc & 0xFF;
                combined[combined.length - 1] = (fileCrc >> 8) & 0xFF;

                return combined;
            }
        }

        // FIT Message Numbers
        const FIT_MESG_FILE_ID = 0;
        const FIT_MESG_SESSION = 18;
        const FIT_MESG_LAP = 19;
        const FIT_MESG_RECORD = 20;
        const FIT_MESG_EVENT = 21;
        const FIT_MESG_ACTIVITY = 34;

        // FIT Base Types
        const FIT_UINT8 = 0x02;
        const FIT_UINT16 = 0x84;
        const FIT_UINT32 = 0x86;
        const FIT_SINT32 = 0x85;
        const FIT_ENUM = 0x00;

        function exportToFIT() {
            const data = getFilteredExportData();
            if (data.length === 0) {
                alert('No data to export. Please select at least one user.');
                return;
            }

            // FIT files are per-user, so if multiple selected, create one for the first
            // or we could zip them - for now just export first user
            if (data.length > 1) {
                alert('FIT format exports one user at a time. Exporting: ' + getDisplayName(data[0].userId));
            }

            const { userId, entries } = data[0];
            if (entries.length === 0) return;

            const encoder = new FitEncoder();

            // Get timestamps
            const startTime = entries[0].ts;
            const endTime = entries[entries.length - 1].ts;
            const startFitTime = toFitTimestamp(startTime);

            // Define file_id message
            // Fields: type(0), manufacturer(1), product(2), serial_number(3), time_created(4)
            encoder.writeDefinition(0, FIT_MESG_FILE_ID, [
                { num: 0, size: 1, baseType: FIT_ENUM },    // type
                { num: 1, size: 2, baseType: FIT_UINT16 },  // manufacturer
                { num: 2, size: 2, baseType: FIT_UINT16 },  // product
                { num: 3, size: 4, baseType: FIT_UINT32 },  // serial_number
                { num: 4, size: 4, baseType: FIT_UINT32 },  // time_created
            ]);

            // Write file_id: type=4 (activity), manufacturer=1 (garmin), product=1, serial=1234
            encoder.writeData(FIT_MESG_FILE_ID, [
                4,                  // type: activity
                255,                // manufacturer: development
                1,                  // product
                12345,              // serial_number
                startFitTime,       // time_created
            ]);

            // Define event message for start - fields in ascending order
            encoder.writeDefinition(1, FIT_MESG_EVENT, [
                { num: 0, size: 1, baseType: FIT_ENUM },     // event
                { num: 1, size: 1, baseType: FIT_ENUM },     // event_type
                { num: 253, size: 4, baseType: FIT_UINT32 }, // timestamp
            ]);

            // Write start event
            encoder.writeData(FIT_MESG_EVENT, [
                0,                  // event: timer
                0,                  // event_type: start
                startFitTime,       // timestamp
            ]);

            // Check if we have heart rate data
            const hasHeartRate = entries.some(e => e.hr !== undefined && e.hr > 0);

            // Calculate cumulative distance using haversine formula
            function haversineDistance(lat1, lon1, lat2, lon2) {
                const R = 6371000; // Earth radius in meters
                const dLat = (lat2 - lat1) * Math.PI / 180;
                const dLon = (lon2 - lon1) * Math.PI / 180;
                const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                          Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                          Math.sin(dLon/2) * Math.sin(dLon/2);
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
                return R * c;
            }

            // Pre-calculate cumulative distances
            const distances = [0];
            let totalDistance = 0;
            for (let i = 1; i < entries.length; i++) {
                const dist = haversineDistance(
                    entries[i-1].lat, entries[i-1].lon,
                    entries[i].lat, entries[i].lon
                );
                totalDistance += dist;
                distances.push(totalDistance);
            }

            // Define record message - fields MUST be in ascending order by field number
            // Fields: position_lat(0), position_long(1), heart_rate(3), distance(5), speed(6), timestamp(253)
            const recordFields = [
                { num: 0, size: 4, baseType: FIT_SINT32 },   // position_lat (semicircles)
                { num: 1, size: 4, baseType: FIT_SINT32 },   // position_long (semicircles)
            ];

            if (hasHeartRate) {
                recordFields.push({ num: 3, size: 1, baseType: FIT_UINT8 }); // heart_rate
            }

            recordFields.push({ num: 5, size: 4, baseType: FIT_UINT32 });   // distance (m * 100)
            recordFields.push({ num: 6, size: 2, baseType: FIT_UINT16 });   // speed (m/s * 1000)
            recordFields.push({ num: 253, size: 4, baseType: FIT_UINT32 }); // timestamp

            encoder.writeDefinition(2, FIT_MESG_RECORD, recordFields);

            // Write record messages
            for (let i = 0; i < entries.length; i++) {
                const e = entries[i];
                const fitTs = toFitTimestamp(e.ts);
                const lat = toSemicircles(e.lat);
                const lon = toSemicircles(e.lon);
                const speedMs = (e.spd || 0) * 0.514444; // knots to m/s
                const speedScaled = Math.round(speedMs * 1000); // FIT uses mm/s
                const distScaled = Math.round(distances[i] * 100); // FIT uses centimeters

                const recordValues = [
                    lat,
                    lon,
                ];

                if (hasHeartRate) {
                    recordValues.push(e.hr || 0xFF); // 0xFF = invalid
                }

                recordValues.push(distScaled);              // distance (cumulative, cm)
                recordValues.push(speedScaled & 0xFFFF);    // speed (16-bit, capped)
                recordValues.push(fitTs);                   // timestamp

                encoder.writeData(FIT_MESG_RECORD, recordValues);
            }

            // Total distance for session/lap (in centimeters for FIT)
            const totalDistanceScaled = Math.round(totalDistance * 100);

            // Write stop event (reuses event definition from above)
            const endFitTime = toFitTimestamp(endTime);
            encoder.writeData(FIT_MESG_EVENT, [
                0,                  // event: timer
                4,                  // event_type: stop_all
                endFitTime,         // timestamp
            ]);

            // Calculate summary stats
            const totalElapsedTime = (endTime - startTime) * 1000; // milliseconds
            const totalTimerTime = totalElapsedTime; // same for continuous activity

            // Define lap message - fields in ascending order
            encoder.writeDefinition(3, FIT_MESG_LAP, [
                { num: 0, size: 1, baseType: FIT_ENUM },     // event
                { num: 1, size: 1, baseType: FIT_ENUM },     // event_type
                { num: 2, size: 4, baseType: FIT_UINT32 },   // start_time
                { num: 7, size: 4, baseType: FIT_UINT32 },   // total_elapsed_time
                { num: 8, size: 4, baseType: FIT_UINT32 },   // total_timer_time
                { num: 9, size: 4, baseType: FIT_UINT32 },   // total_distance (m * 100)
                { num: 253, size: 4, baseType: FIT_UINT32 }, // timestamp
                { num: 254, size: 2, baseType: FIT_UINT16 }, // message_index
            ]);

            // Write lap
            encoder.writeData(FIT_MESG_LAP, [
                9,                  // event: lap
                1,                  // event_type: stop
                startFitTime,       // start_time
                totalElapsedTime,   // total_elapsed_time
                totalTimerTime,     // total_timer_time
                totalDistanceScaled, // total_distance
                endFitTime,         // timestamp
                0,                  // message_index
            ]);

            // Define session message - fields in ascending order
            encoder.writeDefinition(4, FIT_MESG_SESSION, [
                { num: 0, size: 1, baseType: FIT_ENUM },     // event
                { num: 1, size: 1, baseType: FIT_ENUM },     // event_type
                { num: 2, size: 4, baseType: FIT_UINT32 },   // start_time
                { num: 5, size: 1, baseType: FIT_ENUM },     // sport
                { num: 6, size: 1, baseType: FIT_ENUM },     // sub_sport
                { num: 7, size: 4, baseType: FIT_UINT32 },   // total_elapsed_time
                { num: 8, size: 4, baseType: FIT_UINT32 },   // total_timer_time
                { num: 9, size: 4, baseType: FIT_UINT32 },   // total_distance (m * 100)
                { num: 25, size: 2, baseType: FIT_UINT16 },  // first_lap_index
                { num: 26, size: 2, baseType: FIT_UINT16 },  // num_laps
                { num: 253, size: 4, baseType: FIT_UINT32 }, // timestamp
                { num: 254, size: 2, baseType: FIT_UINT16 }, // message_index
            ]);

            // Write session: sport=43 (windsurfing), sub_sport=0 (generic)
            encoder.writeData(FIT_MESG_SESSION, [
                8,                  // event: session
                1,                  // event_type: stop
                startFitTime,       // start_time
                43,                 // sport: windsurfing
                0,                  // sub_sport: generic
                totalElapsedTime,   // total_elapsed_time
                totalTimerTime,     // total_timer_time
                totalDistanceScaled, // total_distance
                0,                  // first_lap_index
                1,                  // num_laps
                endFitTime,         // timestamp
                0,                  // message_index
            ]);

            // Define activity message - fields in ascending order
            encoder.writeDefinition(5, FIT_MESG_ACTIVITY, [
                { num: 0, size: 4, baseType: FIT_UINT32 },   // total_timer_time
                { num: 1, size: 2, baseType: FIT_UINT16 },   // num_sessions
                { num: 2, size: 1, baseType: FIT_ENUM },     // type
                { num: 3, size: 1, baseType: FIT_ENUM },     // event
                { num: 4, size: 1, baseType: FIT_ENUM },     // event_type
                { num: 5, size: 4, baseType: FIT_UINT32 },   // local_timestamp
                { num: 253, size: 4, baseType: FIT_UINT32 }, // timestamp
            ]);

            // Write activity
            encoder.writeData(FIT_MESG_ACTIVITY, [
                totalTimerTime,     // total_timer_time
                1,                  // num_sessions
                0,                  // type: generic
                26,                 // event: activity
                1,                  // event_type: stop
                endFitTime,         // local_timestamp
                endFitTime,         // timestamp
            ]);

            const fitData = encoder.getFile();
            downloadFile(fitData, getExportFilename('fit').replace(userId, getDisplayName(userId).replace(/\s+/g, '_')), 'application/octet-stream');
            document.getElementById('export-dropdown-content').classList.remove('show');
        }

        // Export button handlers
        document.getElementById('export-fit').addEventListener('click', exportToFIT);
        document.getElementById('export-gpx').addEventListener('click', exportToGPX);
        document.getElementById('export-csv').addEventListener('click', exportToCSV);
        document.getElementById('export-geojson').addEventListener('click', exportToGeoJSON);

        // Update live tracking link to include event ID
        const liveLink = document.getElementById('live-link');
        if (liveLink) {
            liveLink.href = `event.html?eid=${EVENT_ID}`;
        }

        // Restore state from URL (map position, options, graphs)
        restoreStateFromUrl();

        // Load summary (will auto-select log if URL has log param)
        loadSummary();
    </script>
</body>
</html>
