<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <title>Track Review - Windsurfer Tracker</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="stylesheet" href="css/common.css" />
    <link rel="stylesheet" href="css/graphs.css" />
    <link rel="stylesheet" href="css/review.css" />
</head>
<body>
    <!-- Event description modal -->
    <div class="event-modal-overlay" id="eventModalOverlay" onclick="hideEventModal(event)">
        <div class="event-modal" onclick="event.stopPropagation()">
            <div class="event-modal-header">
                <h2 id="eventModalTitle"></h2>
                <button class="event-modal-close" onclick="hideEventModal()">&times;</button>
            </div>
            <div class="event-modal-body">
                <p id="eventModalDescription"></p>
            </div>
            <div class="event-modal-footer">
                <a href="index.html">‚Üê Back to Events List</a>
            </div>
        </div>
    </div>

    <div id="controls">
        <a id="live-link" href="event.html" style="color:white;text-decoration:none;padding:8px 12px;background:#27ae60;border-radius:4px;margin-right:10px;">‚Üê Live Tracking</a>
        <span class="event-header-name" id="eventHeaderName" onclick="showEventModal()" title="Click for event details"></span>
        <span class="date-display" onclick="document.getElementById('date-picker').showPicker()" style="cursor:pointer;position:relative;">
            <span id="date-display"></span>
            <input type="date" id="date-picker" style="position:absolute;left:0;top:100%;width:0;height:0;border:none;padding:0;margin:0;opacity:0;">
        </span>
        <div class="graphs-dropdown">
            <button id="options-btn">Options ‚ñº</button>
            <div id="options-dropdown-content" class="graphs-dropdown-content">
                <label><input type="checkbox" id="speed-color" checked> Color by speed</label>
                <label><input type="checkbox" id="show-markers" checked> Show markers</label>
                <label><input type="checkbox" id="filter-outliers" checked> Filter outliers</label>
                <label><input type="checkbox" id="show-outliers"> Show outliers (red)</label>
                <label><input type="checkbox" id="show-course" checked> Show course</label>
                <label title="During playback, show full track instead of 30s tail"><input type="checkbox" id="playback-full-track"> Playback full track</label>
                <div style="border-top:1px solid #3498db;margin:5px 0;padding-top:5px;">
                    <label style="font-size:11px;color:#aaa;margin-bottom:3px;display:block;">Map Type</label>
                    <label><input type="radio" name="map-type" value="osm" checked onchange="setMapType(this.value)"> OpenStreetMap</label>
                    <label style="display:none"><input type="radio" name="map-type" value="roads" onchange="setMapType(this.value)"> Google Roads</label>
                    <label style="display:none"><input type="radio" name="map-type" value="satellite" onchange="setMapType(this.value)"> Google Satellite</label>
                    <label style="display:none"><input type="radio" name="map-type" value="hybrid" onchange="setMapType(this.value)"> Google Hybrid</label>
                </div>
                <div style="border-top:1px solid #3498db;margin:5px 0;padding-top:5px;">
                    <label><input type="checkbox" id="admin-mode" onchange="toggleAdminMode(this.checked)"> Admin Mode</label>
                </div>
            </div>
        </div>
        <div class="graphs-dropdown">
            <button id="graphs-btn">Graphs ‚ñº</button>
            <div id="graphs-dropdown-content" class="graphs-dropdown-content">
                <label><input type="checkbox" id="show-speed-graph"> Speed</label>
                <label><input type="checkbox" id="show-distance-graph"> Distance</label>
                <label><input type="checkbox" id="show-battery-graph"> Battery</label>
                <label><input type="checkbox" id="show-signal-graph"> Signal</label>
                <label><input type="checkbox" id="show-latency-graph"> Latency</label>
                <label><input type="checkbox" id="show-heartrate-graph"> Heart Rate</label>
                <label><input type="checkbox" id="show-accuracy-graph"> Accuracy</label>
            </div>
        </div>
        <div class="graphs-dropdown">
            <button id="export-btn" style="background:#27ae60">Export ‚ñº</button>
            <div id="export-dropdown-content" class="graphs-dropdown-content">
                <label><button id="export-fit" class="export-format-btn">FIT (Garmin/Waterspeed)</button></label>
                <label><button id="export-gpx" class="export-format-btn">GPX (GPS Exchange)</button></label>
                <label><button id="export-csv" class="export-format-btn">CSV (Spreadsheet)</button></label>
                <label><button id="export-geojson" class="export-format-btn">GeoJSON (Mapping)</button></label>
            </div>
        </div>
        <button id="reload-tiles-btn" title="Reload map tiles">‚ü≥</button>
        <span id="status"></span>
    </div>

    <!-- About modal -->
    <div id="about-modal" class="about-modal">
        <div class="about-content">
            <h2>Windsurfer Tracker</h2>
            <p>GPS tracking system for windsurfing races</p>
            <p><a href="https://wstracker.org/install" target="_blank">Install App (Android/iPhone)</a></p>
            <p><a href="support.html" target="_blank">Support &amp; Help</a></p>
            <p><a href="https://github.com/tridge/windsurfer-tracker" target="_blank">Source Code on GitHub</a></p>
            <button id="about-close-btn">Close</button>
        </div>
    </div>

    <div id="map"></div>

    <div class="custom-scale" id="customScale">
        <div class="scale-bar" id="scaleBar"></div>
        <span class="scale-text" id="scaleText">100m</span>
    </div>

    <!-- Speed graph panel -->
    <div id="speed-graph-panel" class="graph-panel" data-type="speed">
        <div id="speed-graph-resize" class="graph-resize"></div>
        <div id="speed-graph-container" class="graph-container">
            <div class="graph-title">Speed (knots)</div>
            <div class="graph-y-axis" id="speed-y-labels">
                <span>40</span>
                <span>30</span>
                <span>20</span>
                <span>10</span>
                <span>0</span>
            </div>
            <canvas id="speed-graph" class="graph-canvas"></canvas>
            <div class="graph-range-overlay left"></div>
            <div class="graph-range-overlay right"></div>
            <div class="graph-x-axis">
                <span id="speed-time-start">--:--</span>
                <span id="speed-time-end">--:--</span>
            </div>
        </div>
    </div>

    <!-- Battery graph panel -->
    <div id="battery-graph-panel" class="graph-panel" data-type="battery">
        <div id="battery-graph-resize" class="graph-resize"></div>
        <div id="battery-graph-container" class="graph-container">
            <div class="graph-title">Battery Level (%)</div>
            <div class="graph-y-axis" id="battery-y-labels">
                <span>100</span>
                <span>75</span>
                <span>50</span>
                <span>25</span>
                <span>0</span>
            </div>
            <canvas id="battery-graph" class="graph-canvas"></canvas>
            <div class="graph-range-overlay left"></div>
            <div class="graph-range-overlay right"></div>
            <div class="graph-x-axis">
                <span id="battery-time-start">--:--</span>
                <span id="battery-time-end">--:--</span>
            </div>
        </div>
    </div>

    <!-- Signal graph panel -->
    <div id="signal-graph-panel" class="graph-panel" data-type="signal">
        <div id="signal-graph-resize" class="graph-resize"></div>
        <div id="signal-graph-container" class="graph-container">
            <div class="graph-title">Signal Strength</div>
            <div class="graph-y-axis">
                <span>4</span>
                <span>3</span>
                <span>2</span>
                <span>1</span>
                <span>0</span>
            </div>
            <canvas id="signal-graph" class="graph-canvas"></canvas>
            <div class="graph-range-overlay left"></div>
            <div class="graph-range-overlay right"></div>
            <div class="graph-x-axis">
                <span id="signal-time-start">--:--</span>
                <span id="signal-time-end">--:--</span>
            </div>
        </div>
    </div>

    <!-- Latency graph panel -->
    <div id="latency-graph-panel" class="graph-panel" data-type="latency">
        <div id="latency-graph-resize" class="graph-resize"></div>
        <div id="latency-graph-container" class="graph-container">
            <div class="graph-title">Network Latency (seconds)</div>
            <div class="graph-y-axis" id="latency-y-labels">
                <span>10</span>
                <span>7.5</span>
                <span>5</span>
                <span>2.5</span>
                <span>0</span>
            </div>
            <canvas id="latency-graph" class="graph-canvas"></canvas>
            <div class="graph-range-overlay left"></div>
            <div class="graph-range-overlay right"></div>
            <div class="graph-x-axis">
                <span id="latency-time-start">--:--</span>
                <span id="latency-time-end">--:--</span>
            </div>
        </div>
    </div>

    <!-- Heart rate graph panel -->
    <div id="heartrate-graph-panel" class="graph-panel" data-type="heartrate">
        <div id="heartrate-graph-resize" class="graph-resize"></div>
        <div id="heartrate-graph-container" class="graph-container">
            <div class="graph-title">Heart Rate (bpm)</div>
            <div class="graph-y-axis" id="heartrate-y-labels">
                <span>200</span>
                <span>150</span>
                <span>100</span>
                <span>50</span>
                <span>0</span>
            </div>
            <canvas id="heartrate-graph" class="graph-canvas"></canvas>
            <div class="graph-range-overlay left"></div>
            <div class="graph-range-overlay right"></div>
            <div class="graph-x-axis">
                <span id="heartrate-time-start">--:--</span>
                <span id="heartrate-time-end">--:--</span>
            </div>
        </div>
    </div>

    <!-- Accuracy graph panel -->
    <div id="accuracy-graph-panel" class="graph-panel" data-type="accuracy">
        <div id="accuracy-graph-resize" class="graph-resize"></div>
        <div id="accuracy-graph-container" class="graph-container">
            <div class="graph-title">GPS Accuracy (meters)</div>
            <div class="graph-y-axis" id="accuracy-y-labels">
                <span>100</span>
                <span>75</span>
                <span>50</span>
                <span>25</span>
                <span>0</span>
            </div>
            <canvas id="accuracy-graph" class="graph-canvas"></canvas>
            <div class="graph-range-overlay left"></div>
            <div class="graph-range-overlay right"></div>
            <div class="graph-x-axis">
                <span id="accuracy-time-start">--:--</span>
                <span id="accuracy-time-end">--:--</span>
            </div>
        </div>
    </div>

    <!-- Distance graph panel -->
    <div id="distance-graph-panel" class="graph-panel" data-type="distance">
        <div id="distance-graph-resize" class="graph-resize"></div>
        <div id="distance-graph-container" class="graph-container">
            <div class="graph-title">Distance (meters)</div>
            <div class="graph-y-axis" id="distance-y-labels">
                <span>10000</span>
                <span>7500</span>
                <span>5000</span>
                <span>2500</span>
                <span>0</span>
            </div>
            <canvas id="distance-graph" class="graph-canvas"></canvas>
            <div class="graph-range-overlay left"></div>
            <div class="graph-range-overlay right"></div>
            <div class="graph-x-axis">
                <span id="distance-time-start">--:--</span>
                <span id="distance-time-end">--:--</span>
            </div>
        </div>
    </div>

    <!-- Hamburger menu button (mobile only) -->
    <button id="sidebar-toggle" aria-label="Toggle sidebar">
        <span></span>
        <span></span>
        <span></span>
    </button>

    <!-- Overlay when drawer is open (mobile only) -->
    <div id="sidebar-overlay"></div>

    <div id="sidebar">
        <div id="timezone-display" style="display:none;background:#e8f4fd;border-radius:4px;padding:8px 12px;margin-bottom:12px;font-size:13px;color:#1e40af;">
            <strong>Timezone:</strong> <span id="event-timezone">-</span>
        </div>
        <div id="race-selector">
            <h3>Select Log</h3>
            <div id="race-list">
                <p style="color:#666">Select a date to see logs</p>
            </div>
        </div>
        <h3>Users</h3>
        <div style="margin-bottom:10px;">
            <button id="show-all-btn" style="padding:5px 10px;margin-right:5px;">Show All</button>
            <button id="hide-all-btn" style="padding:5px 10px;">Hide All</button>
        </div>
        <div id="user-list">
            <p style="color:#666">Select a log to see users</p>
        </div>
    </div>

    <div id="timeline">
        <div id="time-display">
            <span style="color:#2ecc71">Start: --:--:--</span> &nbsp;|&nbsp;
            <span style="color:#e74c3c">End: --:--:--</span> &nbsp;|&nbsp;
            Duration: --:--
        </div>
        <div class="time-slider-container">
            <div class="slider-track"></div>
            <div class="slider-range" id="slider-range"></div>
            <div class="playback-indicator" id="playback-indicator"></div>
            <input type="range" class="time-slider" id="start-slider" min="0" max="100" value="0" step="any">
            <input type="range" class="time-slider" id="end-slider" min="0" max="100" value="100" step="any">
        </div>
        <div class="time-labels">
            <span id="label-start">--:--:--</span>
            <span id="label-end">--:--:--</span>
        </div>
        <div id="playback-controls">
            <button id="play-btn">‚ñ∂ Play</button>
            <button id="speed-1x" class="speed-btn">1x</button>
            <button id="speed-5x" class="speed-btn">5x</button>
            <button id="speed-20x" class="speed-btn">20x</button>
            <button id="reset-range-btn" style="background:#95a5a6" title="Reset time range">‚ü≤</button>
            <button id="copy-link-btn" style="background:#9b59b6" title="Copy shareable link">üìã</button>
            <button id="about-btn" style="background:#7f8c8d" title="About">‚Ñπ</button>
        </div>
    </div>

    <div class="speed-legend">
        <h4>Speed (knots)</h4>
        <div class="speed-gradient"></div>
        <div class="speed-labels">
            <span>0</span>
            <span>7.5</span>
            <span>15</span>
        </div>
    </div>

    <div id="loading">Loading tracks...</div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet.gridlayer.googlemutant@0.14.1/dist/Leaflet.GoogleMutant.js"></script>
    <!-- Google Maps API key (optional - create config.js from config.js.example) -->
    <script>
        var GMAPS_API_KEY = null;
    </script>
    <script src="config.js" onerror=""></script>
    <script>
        // Load Google Maps API dynamically if API key is configured
        if (GMAPS_API_KEY && GMAPS_API_KEY !== 'YOUR_API_KEY_HERE') {
            var script = document.createElement('script');
            script.src = 'https://maps.googleapis.com/maps/api/js?key=' + GMAPS_API_KEY + '&loading=async';
            script.async = true;
            document.head.appendChild(script);
        }
    </script>
    <script src="js/utils.js"></script>
    <script src="js/modal.js"></script>
    <script src="js/map-utils.js"></script>
    <script src="js/export.js"></script>
    <script>
        // Event ID from URL parameter (default to 2)
        const urlParams = new URLSearchParams(window.location.search);
        const EVENT_ID = parseInt(urlParams.get('eid')) || 2;
        const DATA_BASE = `${EVENT_ID}/`;

        // Store event info for modal (used by modal.js)
        let currentEventInfo = null;

        // Event timezone (defaults to local, updated when event info is fetched)
        let eventTimezone = Intl.DateTimeFormat().resolvedOptions().timeZone;

        // Admin authentication state
        let isAdmin = false;
        let adminPassword = '';  // Loaded from localStorage after EVENT_ID is defined

        // Load per-event admin password
        adminPassword = localStorage.getItem(`adminPassword_${EVENT_ID}`) || '';

        async function toggleAdminMode(checked) {
            if (checked) {
                // Try cached password first
                if (adminPassword) {
                    try {
                        const response = await fetch(`/api/event/${EVENT_ID}/auth/check`, {
                            headers: { 'X-Admin-Password': adminPassword }
                        });
                        if (response.ok) {
                            isAdmin = true;
                            updateRaceList();
                            return;
                        }
                    } catch (e) {
                        // Fall through to prompt
                    }
                }
                // Prompt for password
                const password = prompt('Enter admin password:');
                if (!password) {
                    document.getElementById('admin-mode').checked = false;
                    return;
                }
                try {
                    const response = await fetch(`/api/event/${EVENT_ID}/auth/check`, {
                        headers: { 'X-Admin-Password': password }
                    });
                    if (response.ok) {
                        isAdmin = true;
                        adminPassword = password;
                        localStorage.setItem(`adminPassword_${EVENT_ID}`, password);
                        updateRaceList();
                    } else {
                        alert('Invalid admin password');
                        adminPassword = '';
                        localStorage.removeItem(`adminPassword_${EVENT_ID}`);
                        document.getElementById('admin-mode').checked = false;
                    }
                } catch (e) {
                    alert('Connection error');
                    document.getElementById('admin-mode').checked = false;
                }
            } else {
                isAdmin = false;
                adminPassword = '';
                localStorage.removeItem(`adminPassword_${EVENT_ID}`);
                updateRaceList();
            }
        }

        function getAdminPassword() {
            return adminPassword;
        }

        // Sublog (race marker) functions
        function promptAddSublog() {
            if (!currentLogFile) {
                alert('Please load a log first');
                return;
            }
            promptAddSublogForLog(currentLogFile);
        }

        function promptAddSublogForLog(logFile) {
            if (!currentLogFile || currentLogFile !== logFile) {
                alert('Please select this log first before adding a race marker');
                return;
            }
            const name = prompt('Enter race name (e.g., "Race 1"):');
            if (name && name.trim()) {
                addSublog(name.trim());
            }
        }

        async function addSublog(name) {
            // Get current slider positions and convert to timestamps
            const startPercent = parseFloat(document.getElementById('start-slider').value);
            const endPercent = parseFloat(document.getElementById('end-slider').value);
            const startTs = Math.round(sliderValueToTime(startPercent));
            const endTs = Math.round(sliderValueToTime(endPercent));

            if (startTs >= endTs) {
                alert('Invalid time range');
                return;
            }

            try {
                const response = await fetch(`/api/event/${EVENT_ID}/log/${currentLogFile}/sublog`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-Admin-Password': getAdminPassword()
                    },
                    body: JSON.stringify({ name, start_ts: startTs, end_ts: endTs })
                });

                if (response.ok) {
                    const summary = await response.json();
                    // Update the current summary data
                    currentSummary = summary;
                    updateRaceList();
                    alert(`Race "${name}" added successfully`);
                } else {
                    const error = await response.json();
                    alert(`Failed to add race: ${error.error || 'Unknown error'}`);
                }
            } catch (e) {
                alert(`Failed to add race: ${e.message}`);
            }
        }

        async function deleteSublog(logFile, sublogIndex) {
            if (!confirm('Delete this race marker?')) return;

            try {
                const response = await fetch(`/api/event/${EVENT_ID}/log/${logFile}/sublog/${sublogIndex}`, {
                    method: 'DELETE',
                    headers: { 'X-Admin-Password': getAdminPassword() }
                });

                if (response.ok) {
                    const summary = await response.json();
                    // Update the current summary data
                    currentSummary = summary;
                    updateRaceList();
                } else {
                    const error = await response.json();
                    alert(`Failed to delete race: ${error.error || 'Unknown error'}`);
                }
            } catch (e) {
                alert(`Failed to delete race: ${e.message}`);
            }
        }

        function selectSublog(logIndex, sublogIndex) {
            // Get the log entry and sublog
            if (!currentSummary || !currentSummary.logs || !currentSummary.logs[logIndex]) return;

            const logEntry = currentSummary.logs[logIndex];
            const sublog = logEntry.sublogs && logEntry.sublogs[sublogIndex];
            if (!sublog) return;

            // If a different log is loaded, load it first then apply sublog range
            if (currentLogFile !== logEntry.file) {
                loadRace(logEntry).then(() => applySublogTimeRange(logEntry, sublog));
            } else {
                applySublogTimeRange(logEntry, sublog);
            }
        }

        function applySublogTimeRange(logEntry, sublog) {
            // Store selected sublog for reset functionality
            selectedSublog = sublog;

            // Convert sublog timestamps to slider percentages
            // Note: sliderMinTime/sliderMaxTime should already be set from the loaded log
            const range = sliderMaxTime - sliderMinTime;
            if (range <= 0) return;

            const startPercent = Math.max(0, Math.min(100, ((sublog.start_ts - sliderMinTime) / range) * 100));
            const endPercent = Math.max(0, Math.min(100, ((sublog.end_ts - sliderMinTime) / range) * 100));

            document.getElementById('start-slider').value = startPercent;
            document.getElementById('end-slider').value = endPercent;

            updateSliderRange();
            updateTimeDisplay();
            resetPlaybackPosition();
            redrawAll();
        }

        // Get today's date in event timezone (for date picker)
        function getTodayInEventTz() {
            // Get current date parts in event timezone
            const parts = new Date().toLocaleDateString('en-CA', { timeZone: eventTimezone });
            return parts; // Format: YYYY-MM-DD (en-CA gives ISO format)
        }

        // Format date as "DD Mon YYYY" for consistent display across platforms
        const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
        function formatDateDisplay(dateStr) {
            // Input: YYYY-MM-DD or YYYY_MM_DD
            const normalized = dateStr.replace(/_/g, '-');
            const parts = normalized.split('-');
            if (parts.length !== 3) return dateStr;
            const year = parts[0];
            const month = parseInt(parts[1], 10) - 1;
            const day = parseInt(parts[2], 10);
            return `${day} ${monthNames[month]} ${year}`;
        }

        // Format time in event timezone
        function formatTimeInTz(ts) {
            return new Date(ts * 1000).toLocaleTimeString([], {
                timeZone: eventTimezone,
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit'
            });
        }

        function formatTimeShortInTz(ts) {
            return new Date(ts * 1000).toLocaleTimeString([], {
                timeZone: eventTimezone,
                hour: '2-digit',
                minute: '2-digit'
            });
        }

        // Build shareable URL with current view state
        function buildShareableUrl() {
            const params = new URLSearchParams();

            // Event ID
            params.set('eid', EVENT_ID);

            // Map state
            const center = map.getCenter();
            params.set('lat', center.lat.toFixed(6));
            params.set('lon', center.lng.toFixed(6));
            params.set('z', map.getZoom());

            // Date
            const dateStr = document.getElementById('date-picker').value;
            if (dateStr) params.set('date', dateStr);

            // Selected log (by start timestamp for stability across rotations)
            if (currentLogStartTs) params.set('logts', currentLogStartTs);

            // Selected users
            if (selectedUsers.size > 0) {
                params.set('users', Array.from(selectedUsers).join(','));
            }

            // Time range (as percentages of global log range for stable URLs)
            const startPercent = timeToGlobalPercent(rangeStartTime);
            const endPercent = timeToGlobalPercent(rangeEndTime);
            if (startPercent > 0.01 || endPercent < 99.99) {
                params.set('start', startPercent.toFixed(2));
                params.set('end', endPercent.toFixed(2));
            }

            // Options
            if (!document.getElementById('speed-color').checked) params.set('nospeedcolor', '1');
            if (!document.getElementById('show-markers').checked) params.set('nomarkers', '1');
            if (!document.getElementById('filter-outliers').checked) params.set('nofilter', '1');
            if (document.getElementById('show-outliers').checked) params.set('showoutliers', '1');
            if (!document.getElementById('show-course').checked) params.set('nocourse', '1');

            // Graphs
            const graphs = [];
            if (document.getElementById('show-speed-graph').checked) graphs.push('speed');
            if (document.getElementById('show-distance-graph').checked) graphs.push('distance');
            if (document.getElementById('show-battery-graph').checked) graphs.push('battery');
            if (document.getElementById('show-signal-graph').checked) graphs.push('signal');
            if (document.getElementById('show-latency-graph').checked) graphs.push('latency');
            if (document.getElementById('show-heartrate-graph').checked) graphs.push('heartrate');
            if (document.getElementById('show-accuracy-graph').checked) graphs.push('accuracy');
            if (graphs.length > 0) params.set('graphs', graphs.join(','));

            // Build URL
            const url = new URL(window.location.href);
            url.search = params.toString();
            return url.toString();
        }

        // Parse URL params and restore state (called after data loads)
        function restoreStateFromUrl() {
            const params = new URLSearchParams(window.location.search);

            // Map position
            const lat = parseFloat(params.get('lat'));
            const lon = parseFloat(params.get('lon'));
            const zoom = parseInt(params.get('z'));
            if (!isNaN(lat) && !isNaN(lon) && !isNaN(zoom)) {
                map.setView([lat, lon], zoom);
            }

            // Options (apply before loading data)
            if (params.has('nospeedcolor')) document.getElementById('speed-color').checked = false;
            if (params.has('nomarkers')) document.getElementById('show-markers').checked = false;
            if (params.has('nofilter')) document.getElementById('filter-outliers').checked = false;
            if (params.has('showoutliers')) document.getElementById('show-outliers').checked = true;
            if (params.has('nocourse')) document.getElementById('show-course').checked = false;

            // Graphs
            if (params.has('graphs')) {
                const graphs = params.get('graphs').split(',');
                if (graphs.includes('speed')) document.getElementById('show-speed-graph').checked = true;
                if (graphs.includes('distance')) document.getElementById('show-distance-graph').checked = true;
                if (graphs.includes('battery')) document.getElementById('show-battery-graph').checked = true;
                if (graphs.includes('signal')) document.getElementById('show-signal-graph').checked = true;
                if (graphs.includes('latency')) document.getElementById('show-latency-graph').checked = true;
                if (graphs.includes('heartrate')) document.getElementById('show-heartrate-graph').checked = true;
                if (graphs.includes('accuracy')) document.getElementById('show-accuracy-graph').checked = true;
                updateGraphPositions();
            }

            return params;
        }

        // Restore state that depends on loaded data
        function restoreDataDependentState(params) {
            // First restore selected users (affects slider range)
            if (params.has('users')) {
                const users = params.get('users').split(',');
                for (const userId of users) {
                    if (userData[userId]) {
                        selectedUsers.add(userId);
                        // Update UI to show selection
                        const userDiv = document.querySelector(`.user-item[data-user-id="${userId}"]`);
                        if (userDiv) {
                            userDiv.classList.add('selected');
                        }
                    }
                }
            }

            // Update slider endpoints based on selected users
            updateSliderEndpoints();

            // Time range (URL stores percentages of global log range)
            if (params.has('start') || params.has('end')) {
                const startPercent = parseFloat(params.get('start') || '0');
                const endPercent = parseFloat(params.get('end') || '100');

                // Convert global percentages to timestamps
                rangeStartTime = globalPercentToTime(startPercent);
                rangeEndTime = globalPercentToTime(endPercent);

                // Update slider positions (will use current sliderMinTime/sliderMaxTime)
                const startSlider = document.getElementById('start-slider');
                const endSlider = document.getElementById('end-slider');

                // Clamp to slider range and convert to slider percentage
                const clampedStart = Math.max(sliderMinTime, Math.min(sliderMaxTime, rangeStartTime));
                const clampedEnd = Math.max(sliderMinTime, Math.min(sliderMaxTime, rangeEndTime));
                rangeStartTime = clampedStart;
                rangeEndTime = clampedEnd;

                startSlider.value = timeToSliderValue(clampedStart);
                endSlider.value = timeToSliderValue(clampedEnd);

                updateSliderRange();
                updateTimeDisplay();
            }
        }

        // Fetch event name and update page title + header
        (async function() {
            try {
                const response = await fetch('/api/events');
                if (response.ok) {
                    const data = await response.json();
                    const event = data.events.find(e => e.eid === EVENT_ID);
                    if (event && event.name) {
                        currentEventInfo = event;
                        document.title = `${event.name} - Track Review`;
                        const headerEl = document.getElementById('eventHeaderName');
                        headerEl.textContent = event.name;
                        headerEl.style.display = 'inline-block';

                        // Display and use event timezone
                        if (event.timezone) {
                            eventTimezone = event.timezone;
                            document.getElementById('event-timezone').textContent = event.timezone;
                            document.getElementById('timezone-display').style.display = 'block';
                            // Update date picker to use event timezone (only if no URL date param)
                            const urlDateParams = new URLSearchParams(window.location.search);
                            if (!urlDateParams.has('date')) {
                                document.getElementById('date-picker').value = getTodayInEventTz();
                                updateDateDisplay();
                            }
                        }

                        // Center map on event home location if available (only if URL doesn't specify position)
                        const urlPosParams = new URLSearchParams(window.location.search);
                        if (event.home_lat && event.home_lon && !urlPosParams.has('lat')) {
                            map.setView([event.home_lat, event.home_lon], 13);
                        }
                    }
                }
            } catch (e) {
                console.error('Failed to fetch event name:', e);
            }
        })();

        // Initialize map with fractional zoom for finer scroll wheel control
        const map = L.map('map', {
            zoomSnap: 0.25,      // Allow fractional zoom levels (0.25 increments)
            zoomDelta: 0.5,      // Smaller zoom steps per scroll event
            wheelPxPerZoomLevel: 120  // Pixels of scrolling per zoom level
        }).setView([-36.85, 174.88], 13);

        // Map layers
        const osmLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; OpenStreetMap contributors',
            maxZoom: 19
        });
        let googleLayers = {};
        let currentMapType = localStorage.getItem('mapType') || 'osm';
        let currentLayer = null;

        // Initialize map layers after Google Maps API loads
        function initMapLayers() {
            if (GMAPS_API_KEY && GMAPS_API_KEY !== 'YOUR_API_KEY_HERE' && typeof google !== 'undefined') {
                // Enable Google Maps radio options
                document.querySelectorAll('input[name="map-type"][value="roads"], input[name="map-type"][value="satellite"], input[name="map-type"][value="hybrid"]').forEach(el => {
                    el.parentElement.style.display = '';
                });

                // Create Google layers for each type
                googleLayers.roads = L.gridLayer.googleMutant({ type: 'roadmap', maxZoom: 21 });
                googleLayers.satellite = L.gridLayer.googleMutant({ type: 'satellite', maxZoom: 21 });
                googleLayers.hybrid = L.gridLayer.googleMutant({ type: 'hybrid', maxZoom: 21 });

                // Apply saved map type
                setMapType(currentMapType);
            } else {
                // No Google Maps available, use OSM only
                osmLayer.addTo(map);
                currentLayer = osmLayer;
                currentMapType = 'osm';
            }
        }

        function setMapType(mapType) {
            // Remove current layer
            if (currentLayer) {
                map.removeLayer(currentLayer);
            }

            // Add new layer
            if (mapType === 'osm') {
                currentLayer = osmLayer;
            } else if (googleLayers[mapType]) {
                currentLayer = googleLayers[mapType];
            } else {
                // Fallback to OSM
                currentLayer = osmLayer;
                mapType = 'osm';
            }
            currentLayer.addTo(map);
            currentMapType = mapType;
            localStorage.setItem('mapType', mapType);

            // Update radio button selection
            const radio = document.querySelector(`input[name="map-type"][value="${mapType}"]`);
            if (radio) radio.checked = true;
        }

        // Initialize layers - wait for Google Maps to load if configured
        if (GMAPS_API_KEY && GMAPS_API_KEY !== 'YOUR_API_KEY_HERE') {
            // Wait for Google Maps to load
            const checkGoogle = setInterval(() => {
                if (typeof google !== 'undefined') {
                    clearInterval(checkGoogle);
                    initMapLayers();
                }
            }, 100);
            // Timeout fallback - use OSM if Google doesn't load
            setTimeout(() => {
                clearInterval(checkGoogle);
                if (!currentLayer) {
                    osmLayer.addTo(map);
                    currentLayer = osmLayer;
                }
            }, 5000);
        } else {
            osmLayer.addTo(map);
            currentLayer = osmLayer;
        }

        // Update scale on zoom/move (using map-utils.js)
        map.on('zoomend', () => updateScale(map));
        map.on('moveend', () => updateScale(map));
        updateScale(map);  // Initial update

        // State
        let allData = [];
        let userData = {};
        let userOverrides = {};  // Name mappings from users.json
        let trackLayers = {};
        let markerLayers = {};
        let pointLayers = {};
        let outlierLayers = {};  // Outlier markers per user
        let cachedDistanceData = {};  // Cached distance calculations for hover display
        let trackHoverPopup = null;  // Popup shown when hovering over track
        let selectedUsers = new Set();
        let playbackInterval = null;
        let playbackSpeed = 1;
        let minTime = 0;
        let maxTime = 0;
        let rangeStartTime = 0;  // User-selected start time
        let rangeEndTime = 0;    // User-selected end time
        let sliderMinTime = 0;   // Current slider min (selected users' min or global)
        let sliderMaxTime = 0;   // Current slider max (selected users' max or global)
        let currentSummary = null;  // Summary data for selected date
        let currentLogFile = null;  // Currently loaded log file
        let currentLogStartTs = null;  // Start timestamp of current log (for stable URLs)
        let selectedSublog = null;  // Currently selected sublog {start_ts, end_ts, name}
        let sliderDebounceTimer = null;  // Debounce timer for slider redraw
        let courseMarkers = [];  // Course marker layers
        let courseLines = [];    // Course line layers
        let showCourse = true;   // Whether to display course
        let currentCourseFile = null;  // Currently loaded course filename

        // Expand log entry - handles both old format (lat/lon direct) and new format (pos array)
        function expandEntry(entry) {
            if (entry.pos && Array.isArray(entry.pos)) {
                // Compact format: pos array [[ts, lat, lon], ...] or [[ts, lat, lon, spd], ...]
                // Expand into individual entries, each inheriting all metadata
                return entry.pos.map(p => ({
                    id: entry.id,
                    ts: p[0],
                    lat: p[1],
                    lon: p[2],
                    spd: p.length >= 4 ? p[3] : entry.spd,  // Use per-point speed if available
                    hdg: entry.hdg,
                    bat: entry.bat,
                    sig: entry.sig,
                    hr: entry.hr,
                    hac: entry.hac,
                    role: entry.role,
                    ver: entry.ver,
                    flg: entry.flg,
                    ast: entry.ast,
                    bdr: entry.bdr,
                    os: entry.os,
                    recv_ts: entry.recv_ts
                }));
            }
            // Old format: single position with lat/lon directly
            return [entry];
        }

        // Course display functions
        function clearCourseDisplay() {
            courseMarkers.forEach(m => map.removeLayer(m));
            courseMarkers = [];
            courseLines.forEach(l => map.removeLayer(l));
            courseLines = [];
        }

        function displayCourse(course) {
            clearCourseDisplay();
            if (!showCourse) return;

            const points = [];

            // Start marker
            if (course.start) {
                const marker = L.marker([course.start.lat, course.start.lon], {
                    icon: createStartIcon()
                }).addTo(map);
                marker.bindPopup('<strong>Start</strong>');
                courseMarkers.push(marker);
                points.push([course.start.lat, course.start.lon]);
            }

            // Mark markers
            if (course.marks) {
                course.marks.forEach((mark, idx) => {
                    const color = mark.color || '#f97316';
                    const label = mark.comment || null;
                    const marker = L.marker([mark.lat, mark.lon], {
                        icon: createMarkIcon(idx + 1, color, label)
                    }).addTo(map);

                    // Build popup with mark info
                    let popupContent = `<strong>Mark ${idx + 1}</strong>`;
                    if (mark.comment) {
                        popupContent += `<br><em>${mark.comment}</em>`;
                    }
                    marker.bindPopup(popupContent);

                    courseMarkers.push(marker);
                    points.push([mark.lat, mark.lon]);
                });
            }

            // Finish marker
            if (course.finish) {
                const marker = L.marker([course.finish.lat, course.finish.lon], {
                    icon: createFinishIcon()
                }).addTo(map);
                marker.bindPopup('<strong>Finish</strong>');
                courseMarkers.push(marker);
                points.push([course.finish.lat, course.finish.lon]);
            }

            // Course line
            if (points.length >= 2) {
                const line = L.polyline(points, {
                    color: '#ff6600',
                    weight: 3,
                    opacity: 0.7,
                    dashArray: '10, 5'
                }).addTo(map);
                courseLines.push(line);
            }
        }

        // Course marker icons
        function createStartIcon() {
            const svg = `
                <svg width="32" height="32" viewBox="-16 -16 32 32" xmlns="http://www.w3.org/2000/svg">
                    <circle cx="0" cy="0" r="12" fill="#22c55e" stroke="#166534" stroke-width="2"/>
                    <text x="0" y="5" text-anchor="middle" fill="white" font-size="12" font-weight="bold">S</text>
                </svg>
            `;
            return L.divIcon({
                html: svg,
                className: 'course-marker',
                iconSize: [32, 32],
                iconAnchor: [16, 16]
            });
        }

        // Darken a hex color by reducing RGB values ~30%
        function darkenColor(hex) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            const darken = (v) => Math.max(0, Math.floor(v * 0.7)).toString(16).padStart(2, '0');
            return `#${darken(r)}${darken(g)}${darken(b)}`;
        }

        function createMarkIcon(number, color = '#f97316', label = null) {
            const strokeColor = darkenColor(color);
            const svg = `
                <svg width="32" height="32" viewBox="-16 -16 32 32" xmlns="http://www.w3.org/2000/svg">
                    <circle cx="0" cy="0" r="12" fill="${color}" stroke="${strokeColor}" stroke-width="2"/>
                    <text x="0" y="5" text-anchor="middle" fill="white" font-size="11" font-weight="bold">${number}</text>
                </svg>
            `;
            const labelHtml = label ? `<div class="marker-label">${label}</div>` : '';
            return L.divIcon({
                html: `<div style="position:relative">${svg}${labelHtml}</div>`,
                className: 'course-marker',
                iconSize: [32, 32 + (label ? 20 : 0)],
                iconAnchor: [16, 16]
            });
        }

        function createFinishIcon() {
            const svg = `
                <svg width="32" height="32" viewBox="-16 -16 32 32" xmlns="http://www.w3.org/2000/svg">
                    <!-- Checkered flag pattern -->
                    <rect x="-12" y="-12" width="24" height="24" fill="white" stroke="#333" stroke-width="2" rx="3"/>
                    <rect x="-12" y="-12" width="6" height="6" fill="#333"/>
                    <rect x="0" y="-12" width="6" height="6" fill="#333"/>
                    <rect x="-6" y="-6" width="6" height="6" fill="#333"/>
                    <rect x="6" y="-6" width="6" height="6" fill="#333"/>
                    <rect x="-12" y="0" width="6" height="6" fill="#333"/>
                    <rect x="0" y="0" width="6" height="6" fill="#333"/>
                    <rect x="-6" y="6" width="6" height="6" fill="#333"/>
                    <rect x="6" y="6" width="6" height="6" fill="#333"/>
                </svg>
            `;
            return L.divIcon({
                html: svg,
                className: 'course-marker',
                iconSize: [32, 32],
                iconAnchor: [16, 16]
            });
        }

        async function loadCourse(courseFilename) {
            if (!courseFilename || courseFilename === currentCourseFile) {
                return;
            }
            try {
                const courseUrl = `${DATA_BASE}${courseFilename}`;
                const response = await fetch(courseUrl);
                if (response.ok) {
                    const courseData = await response.json();
                    currentCourseFile = courseFilename;
                    displayCourse(courseData);
                } else {
                    clearCourseDisplay();
                    currentCourseFile = null;
                }
            } catch (e) {
                console.log('Error loading course:', e);
                clearCourseDisplay();
                currentCourseFile = null;
            }
        }

        // Mobile drawer toggle
        const sidebarToggle = document.getElementById('sidebar-toggle');
        const sidebar = document.getElementById('sidebar');
        const sidebarOverlay = document.getElementById('sidebar-overlay');

        function toggleSidebar() {
            sidebar.classList.toggle('open');
            sidebarToggle.classList.toggle('open');
            sidebarOverlay.classList.toggle('visible');
        }

        function closeSidebarIfMobile() {
            if (window.innerWidth <= 768) {
                sidebar.classList.remove('open');
                sidebarToggle.classList.remove('open');
                sidebarOverlay.classList.remove('visible');
            }
        }

        sidebarToggle.addEventListener('click', toggleSidebar);
        sidebarOverlay.addEventListener('click', toggleSidebar);

        // Calculate distance between two points using Haversine formula (returns km)
        function haversineDistance(lat1, lon1, lat2, lon2) {
            const R = 6371; // Earth's radius in km
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                      Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                      Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }

        // Filter outliers from track positions using physics-based detection
        function filterOutliers(positions) {
            const SPEED_MARGIN_KNOTS = 20;
            const filtered = [];
            const outliers = [];

            for (let i = 0; i < positions.length; i++) {
                const pos = positions[i];

                if (i === 0) {
                    filtered.push(pos);
                    continue;
                }

                const prev = positions[i - 1];
                const timeDelta = pos.ts - prev.ts;

                if (timeDelta > 0) {
                    const distanceKm = haversineDistance(prev.lat, prev.lon, pos.lat, pos.lon);
                    const distanceM = distanceKm * 1000;
                    const impliedSpeedMs = distanceM / timeDelta;
                    const impliedSpeedKnots = impliedSpeedMs * 1.94384;
                    const prevSpeedKnots = (prev.spd || 0);  // spd is already in knots
                    const currSpeedKnots = (pos.spd || 0);   // spd is already in knots
                    const maxAllowed = Math.max(prevSpeedKnots, currSpeedKnots) + SPEED_MARGIN_KNOTS;

                    if (impliedSpeedKnots > maxAllowed) {
                        outliers.push(pos);
                        continue;
                    }
                }

                filtered.push(pos);
            }

            return { filtered, outliers };
        }

        // Load user overrides (name mappings)
        async function loadUserOverrides() {
            try {
                const response = await fetch(`${DATA_BASE}users.json?` + Date.now());
                if (response.ok) {
                    const data = await response.json();
                    userOverrides = data.users || {};
                }
            } catch (e) {
                console.log('No users.json found');
            }
        }

        // Get display name for a user ID
        function getDisplayName(userId) {
            if (userOverrides[userId] && userOverrides[userId].name) {
                return userOverrides[userId].name;
            }
            return userId;
        }

        // Load user overrides on startup
        loadUserOverrides();

        // User colors
        const userColors = [
            '#e74c3c', '#3498db', '#2ecc71', '#9b59b6', '#f39c12',
            '#1abc9c', '#e91e63', '#00bcd4', '#ff5722', '#795548'
        ];

        // Speed scale max (updated dynamically based on data)
        let speedScaleMax = 15;

        // Speed to color (0 to speedScaleMax knots)
        function speedToColor(speedKnots) {
            const knots = speedKnots;  // spd is already in knots
            const ratio = Math.min(knots / speedScaleMax, 1);

            if (ratio < 0.33) {
                // Blue to green
                const t = ratio / 0.33;
                return interpolateColor('#3498db', '#2ecc71', t);
            } else if (ratio < 0.66) {
                // Green to yellow
                const t = (ratio - 0.33) / 0.33;
                return interpolateColor('#2ecc71', '#f1c40f', t);
            } else {
                // Yellow to red
                const t = (ratio - 0.66) / 0.34;
                return interpolateColor('#f1c40f', '#e74c3c', t);
            }
        }

        function interpolateColor(c1, c2, t) {
            const r1 = parseInt(c1.slice(1,3), 16);
            const g1 = parseInt(c1.slice(3,5), 16);
            const b1 = parseInt(c1.slice(5,7), 16);
            const r2 = parseInt(c2.slice(1,3), 16);
            const g2 = parseInt(c2.slice(3,5), 16);
            const b2 = parseInt(c2.slice(5,7), 16);

            const r = Math.round(r1 + (r2 - r1) * t);
            const g = Math.round(g1 + (g2 - g1) * t);
            const b = Math.round(b1 + (b2 - b1) * t);

            return `rgb(${r},${g},${b})`;
        }

        // Open date picker (with fallback for browsers without showPicker)
        function openDatePicker() {
            const picker = document.getElementById('date-picker');
            if (picker.showPicker) {
                picker.showPicker();
            } else {
                picker.focus();
                picker.click();
            }
        }

        // Update date display when picker changes
        function updateDateDisplay() {
            const dateStr = document.getElementById('date-picker').value;
            document.getElementById('date-display').textContent = dateStr ? formatDateDisplay(dateStr) : 'Select date';
        }
        document.getElementById('date-picker').addEventListener('change', () => {
            updateDateDisplay();
            loadSummary();  // Auto-load when date changes
        });

        // Set date: use URL param if provided, otherwise today in event timezone
        const initDateParams = new URLSearchParams(window.location.search);
        if (initDateParams.has('date')) {
            document.getElementById('date-picker').value = initDateParams.get('date');
        } else {
            document.getElementById('date-picker').value = getTodayInEventTz();
        }
        updateDateDisplay();  // Initialize display

        // Load summary for a date (phase 1)
        async function loadSummary() {
            const dateStr = document.getElementById('date-picker').value;
            if (!dateStr) return;

            document.getElementById('loading').style.display = 'block';
            document.getElementById('status').textContent = 'Loading summary...';

            const dateParts = dateStr.split('-');
            const logDate = `${dateParts[0]}_${dateParts[1]}_${dateParts[2]}`;

            // Clear previous state
            currentSummary = null;
            currentLogFile = null;
            currentLogStartTs = null;
            allData = [];
            userData = {};
            selectedUsers = new Set();
            document.getElementById('user-list').innerHTML = '<p style="color:#666">Select a log to see users</p>';

            try {
                // Try to fetch summary file
                const summaryUrl = `${DATA_BASE}logs/${logDate}_summary.json?${Date.now()}`;
                const response = await fetch(summaryUrl);

                if (response.ok) {
                    currentSummary = await response.json();
                    updateRaceList();
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('status').textContent = `Found ${currentSummary.logs.length} log(s) for this date`;
                } else {
                    // No summary file - fall back to direct loading
                    document.getElementById('race-list').innerHTML = '<p style="color:#666">No summary available - loading all data...</p>';
                    await loadTracksLegacy(logDate);
                }
            } catch (e) {
                console.error('Error loading summary:', e);
                document.getElementById('loading').style.display = 'none';
                document.getElementById('status').textContent = 'Error loading data';
                document.getElementById('race-list').innerHTML = '<p style="color:#666">Error loading logs</p>';
            }
        }

        // Update race list UI
        function updateRaceList() {
            const container = document.getElementById('race-list');
            container.innerHTML = '';

            if (!currentSummary || !currentSummary.logs || currentSummary.logs.length === 0) {
                container.innerHTML = '<p style="color:#666">No logs found</p>';
                return;
            }

            // Logs are already sorted by start_ts descending in the summary
            currentSummary.logs.forEach((log, index) => {
                const div = document.createElement('div');
                div.className = 'race-item';
                div.dataset.index = index;

                const startTime = formatTimeInTz(log.start_ts);
                const endTime = formatTimeInTz(log.end_ts);
                const duration = Math.round((log.end_ts - log.start_ts) / 60);
                const sailorCount = Object.keys(log.sailors).length;

                // Add "+" button for admin to add a sublog
                const addBtn = isAdmin ?
                    `<button class="sublog-add" onclick="event.stopPropagation(); promptAddSublogForLog('${log.file}')" title="Add race marker">+</button>` : '';

                div.innerHTML = `
                    <div class="race-time">Log ${currentSummary.logs.length - index}: ${startTime} - ${endTime}${addBtn}</div>
                    <div class="race-stats">
                        Duration: ${duration} min | ${sailorCount} sailors | ${log.point_count.toLocaleString()} points
                    </div>
                `;

                div.addEventListener('click', () => {
                    // Clear previous selection
                    container.querySelectorAll('.race-item').forEach(el => el.classList.remove('selected'));
                    container.querySelectorAll('.sublog-item').forEach(el => el.classList.remove('selected'));
                    div.classList.add('selected');
                    selectedSublog = null;  // Clear sublog selection when selecting a main log
                    loadRace(log);
                    closeSidebarIfMobile();
                });

                container.appendChild(div);

                // Add sublogs if present
                if (log.sublogs && log.sublogs.length > 0) {
                    log.sublogs.forEach((sublog, subIndex) => {
                        const subDiv = document.createElement('div');
                        subDiv.className = 'sublog-item';
                        subDiv.dataset.logIndex = index;
                        subDiv.dataset.sublogIndex = subIndex;

                        const subStartTime = formatTimeShortInTz(sublog.start_ts);
                        const subEndTime = formatTimeShortInTz(sublog.end_ts);
                        const subDuration = Math.round((sublog.end_ts - sublog.start_ts) / 60);

                        const deleteBtn = isAdmin ?
                            `<button class="sublog-delete" onclick="event.stopPropagation(); deleteSublog('${log.file}', ${subIndex})" title="Delete race">‚àí</button>` : '';

                        subDiv.innerHTML = `
                            <div class="sublog-name">${escapeHtml(sublog.name)}</div>
                            <div class="sublog-time">${subStartTime} - ${subEndTime} (${subDuration}m)</div>
                            ${deleteBtn}
                        `;

                        subDiv.addEventListener('click', () => {
                            // Clear previous selection
                            container.querySelectorAll('.race-item').forEach(el => el.classList.remove('selected'));
                            container.querySelectorAll('.sublog-item').forEach(el => el.classList.remove('selected'));
                            subDiv.classList.add('selected');
                            selectSublog(index, subIndex);
                            closeSidebarIfMobile();
                        });

                        container.appendChild(subDiv);
                    });
                }
            });

            // Auto-select log from URL params if present
            const urlParams = new URLSearchParams(window.location.search);
            let matchingLog = null;

            // Prefer logts (timestamp) over log (filename) for stability across rotations
            if (urlParams.has('logts')) {
                const targetTs = parseInt(urlParams.get('logts'));
                matchingLog = currentSummary.logs.find(log => log.start_ts === targetTs);
            } else if (urlParams.has('log')) {
                // Legacy: match by filename
                const targetLog = urlParams.get('log');
                matchingLog = currentSummary.logs.find(log => log.file === targetLog);
            }

            if (matchingLog) {
                const index = currentSummary.logs.indexOf(matchingLog);
                const logDiv = container.querySelector(`[data-index="${index}"]`);
                if (logDiv) {
                    logDiv.classList.add('selected');
                    loadRace(matchingLog).then(() => {
                        restoreDataDependentState(urlParams);
                        redrawAll();
                    });
                }
            }
        }

        // Helper to fetch and decompress a file (tries .gz first, falls back to uncompressed)
        async function fetchLogFile(url) {
            const canDecompress = typeof DecompressionStream !== 'undefined';

            // Try compressed version first
            if (canDecompress) {
                try {
                    const gzUrl = url + '.gz';
                    const response = await fetch(gzUrl);
                    if (response.ok) {
                        const ds = new DecompressionStream('gzip');
                        const decompressed = response.body.pipeThrough(ds);
                        return await new Response(decompressed).text();
                    }
                } catch (e) {
                    // Fall through to uncompressed
                }
            }

            // Try uncompressed
            const response = await fetch(url);
            if (response.ok) {
                return await response.text();
            }
            return null;
        }

        // Load a specific race/log file (phase 2)
        async function loadRace(logEntry) {
            document.getElementById('loading').style.display = 'block';
            document.getElementById('status').textContent = `Loading ${logEntry.file}...`;

            currentLogFile = logEntry.file;
            currentLogStartTs = logEntry.start_ts;
            allData = [];
            userData = {};
            const previousSelectedUsers = new Set(selectedUsers);  // Preserve selection
            selectedUsers = new Set();

            try {
                const text = await fetchLogFile(`${DATA_BASE}logs/${logEntry.file}`);
                if (!text) throw new Error('Failed to load');

                const lines = text.trim().split('\n');

                for (const line of lines) {
                    try {
                        const entry = JSON.parse(line);
                        // Expand pos array entries (new format) or use directly (old format)
                        const expanded = expandEntry(entry);
                        for (const e of expanded) {
                            if (e.lat && e.lon && e.ts) {
                                allData.push(e);
                            }
                        }
                    } catch (e) {}
                }

                if (allData.length === 0) {
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('status').textContent = 'No data found in this log';
                    return;
                }

                // Sort by timestamp
                allData.sort((a, b) => a.ts - b.ts);

                // Group by user
                for (const entry of allData) {
                    const id = entry.id;
                    if (!userData[id]) {
                        userData[id] = [];
                    }
                    userData[id].push(entry);
                }

                // Calculate time range
                minTime = allData[0].ts;
                maxTime = allData[allData.length - 1].ts;
                sliderMinTime = minTime;  // Initialize slider range to full log
                sliderMaxTime = maxTime;
                rangeStartTime = minTime;
                rangeEndTime = maxTime;

                document.getElementById('start-slider').value = 0;
                document.getElementById('end-slider').value = 100;
                updateSliderRange();
                updateTimeDisplay();

                // Restore previous user selection for users that exist in new data
                for (const userId of previousSelectedUsers) {
                    if (userData[userId]) {
                        selectedUsers.add(userId);
                    }
                }
                // If no previous selection preserved, select all by default
                if (selectedUsers.size === 0 && previousSelectedUsers.size === 0) {
                    selectedUsers = new Set(Object.keys(userData));
                }

                // Update user list
                updateUserList();

                // Draw tracks
                drawTracks();

                // Fit map to data
                fitMapToData();

                // Load course if available in log entry
                if (logEntry.course) {
                    await loadCourse(logEntry.course);
                } else {
                    clearCourseDisplay();
                    currentCourseFile = null;
                }

                document.getElementById('loading').style.display = 'none';
                document.getElementById('status').textContent = `Loaded ${allData.length} points from ${Object.keys(userData).length} users`;

            } catch (e) {
                console.error('Error loading log:', e);
                document.getElementById('loading').style.display = 'none';
                document.getElementById('status').textContent = 'Failed to load log';
            }
        }

        // Legacy function for when no summary exists
        async function loadTracksLegacy(logDate) {
            allData = [];
            userData = {};

            // Try to load main file and rotated files
            const baseUrl = `${DATA_BASE}logs/${logDate}.jsonl`;

            // Load base file first
            try {
                const text = await fetchLogFile(baseUrl);
                if (text) {
                    const lines = text.trim().split('\n');
                    for (const line of lines) {
                        try {
                            const entry = JSON.parse(line);
                            const expanded = expandEntry(entry);
                            for (const e of expanded) {
                                if (e.lat && e.lon && e.ts) {
                                    allData.push(e);
                                }
                            }
                        } catch (e) {}
                    }
                    document.getElementById('status').textContent = `Loaded ${baseUrl}...`;
                }
            } catch (e) {}

            // Try numbered rotations - stop on first missing file
            for (let i = 1; i <= 10; i++) {
                const file = `${baseUrl}.${i}`;
                try {
                    const text = await fetchLogFile(file);
                    if (!text) break;  // If file N doesn't exist, N+1 won't either

                    const lines = text.trim().split('\n');
                    for (const line of lines) {
                        try {
                            const entry = JSON.parse(line);
                            const expanded = expandEntry(entry);
                            for (const e of expanded) {
                                if (e.lat && e.lon && e.ts) {
                                    allData.push(e);
                                }
                            }
                        } catch (e) {}
                    }
                    document.getElementById('status').textContent = `Loaded ${file}...`;
                } catch (e) {
                    break;  // Stop on error too
                }
            }

            if (allData.length === 0) {
                document.getElementById('loading').style.display = 'none';
                document.getElementById('status').textContent = 'No data found for this date';
                document.getElementById('race-list').innerHTML = '<p style="color:#666">No logs found</p>';
                return;
            }

            // Sort by timestamp
            allData.sort((a, b) => a.ts - b.ts);

            // Group by user
            for (const entry of allData) {
                const id = entry.id;
                if (!userData[id]) {
                    userData[id] = [];
                }
                userData[id].push(entry);
            }

            // Calculate time range
            minTime = allData[0].ts;
            maxTime = allData[allData.length - 1].ts;
            sliderMinTime = minTime;  // Initialize slider range to full log
            sliderMaxTime = maxTime;
            rangeStartTime = minTime;
            rangeEndTime = maxTime;

            document.getElementById('start-slider').value = 0;
            document.getElementById('end-slider').value = 100;
            updateSliderRange();
            updateTimeDisplay();

            // Update user list
            updateUserList();

            // Show a single "all data" entry in log list
            document.getElementById('race-list').innerHTML = `
                <div class="race-item selected">
                    <div class="race-time">All Data (Legacy Mode)</div>
                    <div class="race-stats">
                        ${Object.keys(userData).length} sailors | ${allData.length.toLocaleString()} points
                    </div>
                </div>
            `;

            // Start with no users selected by default
            selectedUsers = new Set();

            // Draw tracks
            drawTracks();

            // Fit map to data
            fitMapToData();

            // Try to load current course (legacy mode has no course info in summary)
            await loadCourse('course.json');

            document.getElementById('loading').style.display = 'none';
            document.getElementById('status').textContent = `Loaded ${allData.length} points from ${Object.keys(userData).length} users`;
        }

        function updateUserList() {
            const container = document.getElementById('user-list');
            container.innerHTML = '';

            let colorIdx = 0;
            for (const [userId, entries] of Object.entries(userData)) {
                const speeds = entries.map(e => e.spd || 0);
                const maxSpeed = Math.max(...speeds);
                const avgSpeed = speeds.reduce((a,b) => a+b, 0) / speeds.length;
                const points = entries.length;

                const div = document.createElement('div');
                div.className = 'user-item';
                div.dataset.userId = userId;

                const color = userColors[colorIdx % userColors.length];
                colorIdx++;

                div.innerHTML = `
                    <div class="user-color" style="background:${color}"></div>
                    <div class="user-info">
                        <div class="user-name">${getDisplayName(userId)}</div>
                        <div class="user-stats">
                            ${points} pts | Max: ${maxSpeed.toFixed(1)} kts | Avg: ${avgSpeed.toFixed(1)} kts
                        </div>
                    </div>
                `;

                div.addEventListener('click', () => toggleUser(userId, div));
                div.addEventListener('dblclick', (e) => {
                    e.stopPropagation();
                    zoomToUser(userId);
                });
                container.appendChild(div);
            }
        }

        function toggleUser(userId, element) {
            if (selectedUsers.has(userId)) {
                selectedUsers.delete(userId);
                element.classList.remove('selected');
            } else {
                selectedUsers.add(userId);
                element.classList.add('selected');
            }

            // Update slider endpoints based on newly selected users
            updateSliderEndpoints();

            resetPlaybackToSelection();

            // Auto-fit map to show all selected tracks
            if (selectedUsers.size > 0) {
                fitMapToData();
            }
        }

        function resetPlaybackToSelection() {
            // Stop any active playback
            if (playbackInterval) {
                clearInterval(playbackInterval);
                playbackInterval = null;
                document.getElementById('play-btn').textContent = '‚ñ∂ Play';
            }

            updateTimeDisplay();
            drawTracks();
            drawSpeedGraph();
            drawSpeedGraph();
            drawBatteryGraph();
            drawSignalGraph();
            drawLatencyGraph();
            drawHeartRateGraph();
            drawAccuracyGraph();
            drawDistanceGraph();
        }

        function updateSliderRange() {
            const startSlider = document.getElementById('start-slider');
            const endSlider = document.getElementById('end-slider');
            const sliderRange = document.getElementById('slider-range');

            const startVal = parseFloat(startSlider.value);
            const endVal = parseFloat(endSlider.value);

            // Update the visual range indicator
            // Account for 20px thumb width - thumb center is at 10px + (value/100)*(100%-20px)
            sliderRange.style.left = `calc(10px + ${startVal}% - ${startVal * 0.2}px)`;
            sliderRange.style.width = `calc(${endVal - startVal}% - ${(endVal - startVal) * 0.2}px)`;

            // Update times from slider values (using dynamic slider range)
            rangeStartTime = sliderMinTime + (sliderMaxTime - sliderMinTime) * (startVal / 100);
            rangeEndTime = sliderMinTime + (sliderMaxTime - sliderMinTime) * (endVal / 100);

            // Update the edge labels
            document.getElementById('label-start').textContent = formatTimeInTz(sliderMinTime);
            document.getElementById('label-end').textContent = formatTimeInTz(sliderMaxTime);
        }

        function updateTimeDisplay() {
            const durationSec = rangeEndTime - rangeStartTime;
            const durationMin = Math.floor(durationSec / 60);
            const durationRemSec = Math.floor(durationSec % 60);
            const durationStr = `${durationMin}:${String(durationRemSec).padStart(2, '0')}`;

            document.getElementById('time-display').innerHTML =
                `<span style="color:#2ecc71">Start: ${formatTimeInTz(rangeStartTime)}</span> &nbsp;|&nbsp;` +
                `<span style="color:#e74c3c">End: ${formatTimeInTz(rangeEndTime)}</span> &nbsp;|&nbsp;` +
                `Duration: ${durationStr}`;
        }

        // Rubber-band selection state for graphs
        let rubberBandState = null;

        // Set up rubber-band selection on a graph canvas
        function setupGraphRubberBand(canvas) {
            const getX = (e) => {
                const rect = canvas.getBoundingClientRect();
                if (e.touches) {
                    return e.touches[0].clientX - rect.left;
                }
                return e.clientX - rect.left;
            };

            const startSelection = (e) => {
                e.preventDefault();
                const x = getX(e);
                rubberBandState = {
                    canvas: canvas,
                    startX: x,
                    currentX: x
                };
            };

            const updateSelection = (e) => {
                if (!rubberBandState || rubberBandState.canvas !== canvas) return;
                e.preventDefault();
                rubberBandState.currentX = getX(e);
                drawRubberBand();
            };

            const endSelection = (e) => {
                if (!rubberBandState || rubberBandState.canvas !== canvas) return;
                e.preventDefault();

                const startX = Math.min(rubberBandState.startX, rubberBandState.currentX);
                const endX = Math.max(rubberBandState.startX, rubberBandState.currentX);
                const width = canvas.offsetWidth;

                // Only apply if selection is meaningful (> 5px)
                if (endX - startX > 5) {
                    // Convert pixel positions to slider percentages
                    const startPercent = Math.max(0, Math.min(100, (startX / width) * 100));
                    const endPercent = Math.max(0, Math.min(100, (endX / width) * 100));

                    // Update sliders
                    document.getElementById('start-slider').value = startPercent;
                    document.getElementById('end-slider').value = endPercent;

                    // Trigger updates
                    updateSliderRange();
                    updateTimeDisplay();
                    resetPlaybackPosition();
                    redrawAll();
                }

                rubberBandState = null;
                clearRubberBand();
            };

            // Mouse events
            canvas.addEventListener('mousedown', startSelection);
            canvas.addEventListener('mousemove', updateSelection);
            canvas.addEventListener('mouseup', endSelection);
            canvas.addEventListener('mouseleave', () => {
                if (rubberBandState && rubberBandState.canvas === canvas) {
                    rubberBandState = null;
                    clearRubberBand();
                }
            });

            // Touch events for mobile
            canvas.addEventListener('touchstart', startSelection, { passive: false });
            canvas.addEventListener('touchmove', updateSelection, { passive: false });
            canvas.addEventListener('touchend', endSelection, { passive: false });
        }

        // Draw rubber-band selection overlay on all visible graphs
        function drawRubberBand() {
            if (!rubberBandState) return;

            const allPanels = document.querySelectorAll('.graph-panel');
            const panels = Array.from(allPanels).filter(p => p.style.display === 'block');

            panels.forEach(panel => {
                const canvas = panel.querySelector('.graph-canvas');
                const leftOverlay = panel.querySelector('.graph-range-overlay.left');
                const rightOverlay = panel.querySelector('.graph-range-overlay.right');
                if (!canvas || !leftOverlay || !rightOverlay) return;

                const width = canvas.offsetWidth;
                const startX = Math.min(rubberBandState.startX, rubberBandState.currentX);
                const endX = Math.max(rubberBandState.startX, rubberBandState.currentX);

                // Show grey overlay outside the selection
                // Left overlay covers 0 to startX
                if (startX > 0) {
                    leftOverlay.style.width = startX + 'px';
                    leftOverlay.classList.add('visible');
                } else {
                    leftOverlay.classList.remove('visible');
                }

                // Right overlay covers endX to width
                if (endX < width) {
                    rightOverlay.style.width = (width - endX) + 'px';
                    rightOverlay.classList.add('visible');
                } else {
                    rightOverlay.classList.remove('visible');
                }
            });
        }

        // Clear rubber-band overlay from all graphs
        function clearRubberBand() {
            document.querySelectorAll('.graph-range-overlay').forEach(overlay => {
                overlay.classList.remove('visible');
            });
        }

        // Redraw all tracks and graphs (expensive operation)
        function redrawAll() {
            drawTracks();
            drawSpeedGraph();
            drawBatteryGraph();
            drawSignalGraph();
            drawLatencyGraph();
            drawHeartRateGraph();
            drawAccuracyGraph();
            drawDistanceGraph();
        }

        // Debounced version - waits for slider to stop moving before redrawing
        function debouncedRedrawAll(delay = 500) {
            if (sliderDebounceTimer) {
                clearTimeout(sliderDebounceTimer);
            }
            sliderDebounceTimer = setTimeout(() => {
                redrawAll();
                sliderDebounceTimer = null;
            }, delay);
        }

        function drawTracks() {
            // Calculate max speed from visible data and update scale
            const useSpeedColorForScale = document.getElementById('speed-color').checked;
            if (useSpeedColorForScale) {
                let maxSpeedInData = 0;
                for (const [userId, entries] of Object.entries(userData)) {
                    if (!selectedUsers.has(userId)) continue;
                    for (const entry of entries) {
                        if (entry.ts < rangeStartTime || entry.ts > rangeEndTime) continue;
                        if (entry.spd !== undefined && entry.spd !== null && entry.spd > 0) {
                            maxSpeedInData = Math.max(maxSpeedInData, entry.spd);
                        }
                    }
                }
                // Round up to nearest 5 knots, minimum 5
                speedScaleMax = Math.max(5, Math.ceil(maxSpeedInData / 5) * 5);
                // Update legend labels
                const mid = speedScaleMax / 2;
                document.querySelector('.speed-labels').innerHTML = `
                    <span>0</span>
                    <span>${mid}</span>
                    <span>${speedScaleMax}</span>
                `;
            }

            // Clear existing layers
            for (const layer of Object.values(trackLayers)) {
                map.removeLayer(layer);
            }
            for (const layer of Object.values(markerLayers)) {
                map.removeLayer(layer);
            }
            for (const layer of Object.values(pointLayers)) {
                map.removeLayer(layer);
            }
            for (const layer of Object.values(outlierLayers)) {
                map.removeLayer(layer);
            }
            trackLayers = {};
            markerLayers = {};
            pointLayers = {};
            outlierLayers = {};

            const useSpeedColor = document.getElementById('speed-color').checked;
            const showMarkers = document.getElementById('show-markers').checked;
            const doFilterOutliers = document.getElementById('filter-outliers').checked;
            const showOutliersMarkers = document.getElementById('show-outliers').checked;

            let colorIdx = 0;
            for (const [userId, entries] of Object.entries(userData)) {
                if (!selectedUsers.has(userId)) {
                    colorIdx++;
                    continue;
                }

                const userColor = userColors[colorIdx % userColors.length];
                colorIdx++;

                // Filter entries within the selected time range
                let timeFiltered = entries.filter(e => e.ts >= rangeStartTime && e.ts <= rangeEndTime);
                if (timeFiltered.length < 2) continue;

                // Apply outlier filtering if enabled
                let filtered = timeFiltered;
                let outliers = [];
                if (doFilterOutliers) {
                    const result = filterOutliers(timeFiltered);
                    filtered = result.filtered;
                    outliers = result.outliers;
                    // Fall back to unfiltered data if outlier filtering removed too many points
                    if (filtered.length < 2 && timeFiltered.length >= 2) {
                        filtered = timeFiltered;
                        outliers = [];
                    }
                }

                if (filtered.length < 2) continue;

                // Draw outlier markers if enabled
                if (showOutliersMarkers && outliers.length > 0) {
                    const outlierGroup = L.layerGroup();
                    for (const point of outliers) {
                        const time = formatTimeInTz(point.ts);
                        const speedKnots = (point.spd || 0).toFixed(1);

                        const marker = L.circleMarker([point.lat, point.lon], {
                            radius: 6,
                            fillColor: '#ff0000',
                            color: '#ff0000',
                            fillOpacity: 0.7,
                            weight: 2
                        });

                        let tooltipText = `Outlier: ${time}<br>Speed: ${speedKnots} kn`;
                        if (point.ast) {
                            tooltipText += '<br><span style="color:#ff0000">üÜò ASSIST REQUESTED</span>';
                            // Add larger assist circle
                            const assistMarker = L.circleMarker([point.lat, point.lon], {
                                radius: 12,
                                fillColor: 'transparent',
                                color: '#ff0000',
                                weight: 3,
                                fillOpacity: 0,
                                opacity: 0.9
                            });
                            outlierGroup.addLayer(assistMarker);
                        }
                        marker.bindTooltip(tooltipText, { permanent: false });

                        outlierGroup.addLayer(marker);
                    }
                    outlierGroup.addTo(map);
                    outlierLayers[userId] = outlierGroup;
                }

                // Create coords array for both cases
                const coords = filtered.map(e => [e.lat, e.lon]);

                if (useSpeedColor) {
                    // Draw segments colored by speed
                    const layerGroup = L.layerGroup();

                    for (let i = 1; i < filtered.length; i++) {
                        const prev = filtered[i-1];
                        const curr = filtered[i];
                        const color = speedToColor(curr.spd || 0);

                        const line = L.polyline(
                            [[prev.lat, prev.lon], [curr.lat, curr.lon]],
                            { color: color, weight: 3, opacity: 0.8 }
                        );
                        layerGroup.addLayer(line);
                    }

                    // Add invisible wider polyline for hover detection
                    const hitArea = L.polyline(coords, {
                        color: 'transparent',
                        weight: 15,
                        opacity: 0
                    });
                    layerGroup.addLayer(hitArea);

                    layerGroup.addTo(map);
                    trackLayers[userId] = layerGroup;
                    trackLayers[userId].hitArea = hitArea;
                } else {
                    // Draw single color track with invisible hit area for hover
                    const layerGroup = L.layerGroup();
                    const polyline = L.polyline(coords, {
                        color: userColor,
                        weight: 3,
                        opacity: 0.8
                    });
                    layerGroup.addLayer(polyline);

                    // Add invisible wider polyline for hover detection
                    const hitArea = L.polyline(coords, {
                        color: 'transparent',
                        weight: 15,
                        opacity: 0
                    });
                    layerGroup.addLayer(hitArea);

                    layerGroup.addTo(map);
                    trackLayers[userId] = layerGroup;
                    trackLayers[userId].hitArea = hitArea;
                }

                // Store filtered data for hover lookup (no individual markers for performance)
                trackLayers[userId].trackData = filtered;
                trackLayers[userId].trackUserId = userId;

                // Add hover/click handler to show closest point info
                const hoverTarget = trackLayers[userId].hitArea || trackLayers[userId];

                // Function to show popup at closest point to given latlng
                const showTrackPopup = (latlng, withCloseButton = false) => {
                    const data = trackLayers[userId].trackData;
                    if (!data || data.length === 0) return;

                    // Find closest point
                    let closest = data[0];
                    let closestDist = Infinity;
                    for (const point of data) {
                        const dist = Math.pow(point.lat - latlng.lat, 2) + Math.pow(point.lon - latlng.lng, 2);
                        if (dist < closestDist) {
                            closestDist = dist;
                            closest = point;
                        }
                    }

                    // Build popup content
                    const speedKnots = (closest.spd || 0).toFixed(1);
                    const time = formatTimeInTz(closest.ts);
                    let content = `<b>${getDisplayName(userId)}</b><br>
                        Time: ${time}<br>
                        Speed: ${speedKnots} kts<br>
                        Heading: ${closest.hdg || 0}¬∞<br>
                        Battery: ${closest.bat || '?'}%`;
                    if (closest.hac !== undefined) {
                        content += `<br>Accuracy: ${closest.hac.toFixed(1)}m`;
                    }
                    if (closest.hr !== undefined && closest.hr > 0) {
                        content += `<br>Heart Rate: <span style="color:#e91e63">${closest.hr} bpm</span>`;
                    }
                    if (closest.ast) {
                        content += '<br><span style="color:#ff0000">üÜò ASSIST REQUESTED</span>';
                    }

                    // Show or update popup
                    if (trackHoverPopup && !withCloseButton) {
                        trackHoverPopup.setLatLng([closest.lat, closest.lon]).setContent(content);
                    } else {
                        if (trackHoverPopup) {
                            map.closePopup(trackHoverPopup);
                        }
                        trackHoverPopup = L.popup({ closeButton: withCloseButton, offset: [0, -5] })
                            .setLatLng([closest.lat, closest.lon])
                            .setContent(content)
                            .openOn(map);
                    }
                };

                // Desktop: mousemove for live tracking
                hoverTarget.on('mousemove', (e) => showTrackPopup(e.latlng, false));

                // Mobile: click/tap to show popup with close button
                hoverTarget.on('click', (e) => {
                    showTrackPopup(e.latlng, true);
                    L.DomEvent.stopPropagation(e);
                });

                hoverTarget.on('mouseout', () => {
                    if (trackHoverPopup) {
                        map.closePopup(trackHoverPopup);
                        trackHoverPopup = null;
                    }
                });

                // Add current position marker
                if (showMarkers && filtered.length > 0) {
                    const last = filtered[filtered.length - 1];
                    const speedKnots = (last.spd || 0).toFixed(1);

                    // Build warnings for battery issues
                    let markerWarnings = '';
                    if (last.flg) {
                        if (last.flg.ps) {
                            markerWarnings += '<br><span style="color:#e74c3c">‚ö†Ô∏è Battery Saver ON</span>';
                        }
                        if (last.flg.bo === false) {
                            markerWarnings += '<br><span style="color:#f39c12">‚ö†Ô∏è Battery Optimization ON</span>';
                        }
                    }

                    let markerHrText = '';
                    if (last.hr !== undefined && last.hr > 0) {
                        markerHrText = `<br>Heart Rate: <span style="color:#e91e63">${last.hr} bpm</span>`;
                    }

                    let markerHacText = '';
                    if (last.hac !== undefined) {
                        markerHacText = `<br>Accuracy: ${last.hac.toFixed(1)}m`;
                    }

                    const marker = L.circleMarker([last.lat, last.lon], {
                        radius: 8,
                        fillColor: userColor,
                        color: '#fff',
                        weight: 2,
                        fillOpacity: 1
                    }).bindPopup(`
                        <b>${getDisplayName(userId)}</b><br>
                        Speed: ${speedKnots} kts<br>
                        Heading: ${last.hdg || 0}¬∞<br>
                        Battery: ${last.bat || '?'}%${markerHacText}${markerHrText}${markerWarnings}
                    `).addTo(map);
                    markerLayers[userId] = marker;
                }
            }
        }

        function fitMapToData() {
            const allCoords = [];
            for (const userId of selectedUsers) {
                if (userData[userId]) {
                    for (const entry of userData[userId]) {
                        allCoords.push([entry.lat, entry.lon]);
                    }
                }
            }
            if (allCoords.length > 0) {
                map.fitBounds(allCoords, { padding: [50, 50] });
            }
        }

        function drawSpeedGraph() {
            // Only draw if speed graph is visible
            if (!document.getElementById('show-speed-graph').checked) return;

            const canvas = document.getElementById('speed-graph');
            const ctx = canvas.getContext('2d');

            // Set canvas size to match display size (for sharp rendering)
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * window.devicePixelRatio;
            canvas.height = rect.height * window.devicePixelRatio;
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);

            const width = rect.width;
            const height = rect.height;

            // Clear canvas
            ctx.clearRect(0, 0, width, height);

            // Update time axis labels
            document.getElementById('speed-time-start').textContent = formatTimeShortInTz(rangeStartTime);
            document.getElementById('speed-time-end').textContent = formatTimeShortInTz(rangeEndTime);

            // Calculate speed range for Y axis scaling (only from visible time range)
            let maxSpeed = 0;
            let minSpeed = Infinity;
            let hasSpeedData = false;
            for (const [userId, entries] of Object.entries(userData)) {
                if (!selectedUsers.has(userId)) continue;
                for (const entry of entries) {
                    if (entry.ts < rangeStartTime || entry.ts > rangeEndTime) continue;
                    if (entry.spd !== undefined && entry.spd !== null && entry.spd >= 0) {
                        maxSpeed = Math.max(maxSpeed, entry.spd);
                        minSpeed = Math.min(minSpeed, entry.spd);
                        hasSpeedData = true;
                    }
                }
            }

            // Set sensible defaults and add padding
            if (!hasSpeedData || maxSpeed === 0) {
                maxSpeed = 20;
                minSpeed = 0;
            } else {
                // Add 10% padding above max
                maxSpeed = Math.ceil((maxSpeed * 1.1) / 2) * 2;  // Round to nearest 2 knots
                // Round min down, but keep at 0 for speed (negative speed doesn't make sense)
                minSpeed = 0;
                // Ensure at least 5 knot range for readability
                if (maxSpeed - minSpeed < 5) {
                    maxSpeed = minSpeed + 5;
                }
            }
            const speedRange = maxSpeed - minSpeed;

            // Update Y axis labels
            const yLabels = document.getElementById('speed-y-labels');
            yLabels.innerHTML = `
                <span>${maxSpeed}</span>
                <span>${(minSpeed + speedRange * 0.75).toFixed(0)}</span>
                <span>${(minSpeed + speedRange * 0.5).toFixed(0)}</span>
                <span>${(minSpeed + speedRange * 0.25).toFixed(0)}</span>
                <span>${minSpeed}</span>
            `;

            // Draw grid lines
            ctx.strokeStyle = '#34495e';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 4; i++) {
                const y = (i / 4) * height;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }

            // No users selected
            if (selectedUsers.size === 0) {
                ctx.fillStyle = '#7f8c8d';
                ctx.font = '14px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Select a user to see speed graph', width / 2, height / 2);
                return;
            }

            // Draw speed line for each selected user
            let colorIdx = 0;
            for (const [userId, entries] of Object.entries(userData)) {
                const userColor = userColors[colorIdx % userColors.length];
                colorIdx++;

                if (!selectedUsers.has(userId)) continue;

                // Filter entries by time range
                const filtered = entries.filter(e => e.ts >= rangeStartTime && e.ts <= rangeEndTime);
                if (filtered.length < 2) continue;

                // Draw the speed line
                ctx.strokeStyle = userColor;
                ctx.lineWidth = 2;
                ctx.beginPath();

                let started = false;
                for (const entry of filtered) {
                    if (entry.spd === undefined || entry.spd === null) continue;

                    const x = ((entry.ts - rangeStartTime) / (rangeEndTime - rangeStartTime)) * width;
                    const y = height - ((entry.spd - minSpeed) / speedRange) * height;

                    if (!started) {
                        ctx.moveTo(x, y);
                        started = true;
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();

                // Draw user label at the end of the line
                if (filtered.length > 0) {
                    const last = filtered[filtered.length - 1];
                    if (last.spd !== undefined && last.spd !== null) {
                        const x = ((last.ts - rangeStartTime) / (rangeEndTime - rangeStartTime)) * width;
                        const y = height - ((last.spd - minSpeed) / speedRange) * height;
                        ctx.fillStyle = userColor;
                        ctx.font = 'bold 10px sans-serif';
                        ctx.textAlign = 'right';
                        ctx.fillText(`${getDisplayName(userId)}: ${last.spd.toFixed(1)} kts`, Math.min(x, width - 5), y - 5);
                    }
                }
            }
        }

        function drawBatteryGraph() {
            // Only draw if battery graph is visible
            if (!document.getElementById('show-battery-graph').checked) return;

            const canvas = document.getElementById('battery-graph');
            const ctx = canvas.getContext('2d');

            // Set canvas size to match display size (for sharp rendering)
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * window.devicePixelRatio;
            canvas.height = rect.height * window.devicePixelRatio;
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);

            const width = rect.width;
            const height = rect.height;

            // Clear canvas
            ctx.clearRect(0, 0, width, height);

            // Update time axis labels
            document.getElementById('battery-time-start').textContent = formatTimeShortInTz(rangeStartTime);
            document.getElementById('battery-time-end').textContent = formatTimeShortInTz(rangeEndTime);

            // Calculate battery range for Y axis scaling (only from visible time range)
            let maxBat = 0;
            let minBat = 100;
            let hasBatData = false;
            for (const [userId, entries] of Object.entries(userData)) {
                if (!selectedUsers.has(userId)) continue;
                for (const entry of entries) {
                    if (entry.ts < rangeStartTime || entry.ts > rangeEndTime) continue;
                    if (entry.bat !== undefined && entry.bat !== null && entry.bat >= 0) {
                        maxBat = Math.max(maxBat, entry.bat);
                        minBat = Math.min(minBat, entry.bat);
                        hasBatData = true;
                    }
                }
            }

            // Set sensible defaults and add padding
            if (!hasBatData) {
                maxBat = 100;
                minBat = 0;
            } else {
                // Keep max at 100 if close, otherwise add padding
                maxBat = maxBat > 95 ? 100 : Math.ceil((maxBat + 5) / 5) * 5;
                // Round min down to nearest 5%
                minBat = Math.floor(minBat / 5) * 5;
                // Ensure at least 10% range for readability
                if (maxBat - minBat < 10) {
                    if (maxBat < 100) maxBat = Math.min(100, minBat + 10);
                    else minBat = Math.max(0, maxBat - 10);
                }
            }
            // Ensure batRange is never 0 (prevents division by zero)
            const batRange = Math.max(10, maxBat - minBat);

            // Update Y axis labels
            const yLabels = document.getElementById('battery-y-labels');
            yLabels.innerHTML = `
                <span>${maxBat}</span>
                <span>${Math.round(minBat + batRange * 0.75)}</span>
                <span>${Math.round(minBat + batRange * 0.5)}</span>
                <span>${Math.round(minBat + batRange * 0.25)}</span>
                <span>${minBat}</span>
            `;

            // Draw grid lines
            ctx.strokeStyle = '#34495e';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 4; i++) {
                const y = (i / 4) * height;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }

            // No users selected
            if (selectedUsers.size === 0) {
                ctx.fillStyle = '#7f8c8d';
                ctx.font = '14px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Select a user to see battery graph', width / 2, height / 2);
                return;
            }

            // No battery data available
            if (!hasBatData) {
                ctx.fillStyle = '#7f8c8d';
                ctx.font = '14px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('No battery data available', width / 2, height / 2);
                return;
            }

            // Draw battery line for each selected user
            let colorIdx = 0;
            for (const [userId, entries] of Object.entries(userData)) {
                const userColor = userColors[colorIdx % userColors.length];
                colorIdx++;

                if (!selectedUsers.has(userId)) continue;

                // Filter entries by time range
                const filtered = entries.filter(e => e.ts >= rangeStartTime && e.ts <= rangeEndTime);
                if (filtered.length < 2) continue;

                // Draw the battery line
                ctx.strokeStyle = userColor;
                ctx.lineWidth = 2;
                ctx.beginPath();

                let started = false;
                for (const entry of filtered) {
                    if (entry.bat === undefined || entry.bat === null || entry.bat < 0) continue;

                    const x = ((entry.ts - rangeStartTime) / (rangeEndTime - rangeStartTime)) * width;
                    const y = height - ((entry.bat - minBat) / batRange) * height;

                    if (!started) {
                        ctx.moveTo(x, y);
                        started = true;
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();

                // Draw user label at the end of the line
                if (filtered.length > 0) {
                    const last = filtered[filtered.length - 1];
                    if (last.bat !== undefined && last.bat !== null && last.bat >= 0) {
                        const x = ((last.ts - rangeStartTime) / (rangeEndTime - rangeStartTime)) * width;
                        const y = height - ((last.bat - minBat) / batRange) * height;
                        ctx.fillStyle = userColor;
                        ctx.font = 'bold 10px sans-serif';
                        ctx.textAlign = 'right';
                        ctx.fillText(`${getDisplayName(userId)}: ${last.bat}%`, Math.min(x, width - 5), y - 5);
                    }
                }
            }
        }

        function drawSignalGraph() {
            // Only draw if signal graph is visible
            if (!document.getElementById('show-signal-graph').checked) return;

            const canvas = document.getElementById('signal-graph');
            const ctx = canvas.getContext('2d');

            // Set canvas size to match display size (for sharp rendering)
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * window.devicePixelRatio;
            canvas.height = rect.height * window.devicePixelRatio;
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);

            const width = rect.width;
            const height = rect.height;

            // Clear canvas
            ctx.clearRect(0, 0, width, height);

            // Update time axis labels
            document.getElementById('signal-time-start').textContent = formatTimeShortInTz(rangeStartTime);
            document.getElementById('signal-time-end').textContent = formatTimeShortInTz(rangeEndTime);

            // Draw grid lines
            ctx.strokeStyle = '#34495e';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 4; i++) {
                const y = (i / 4) * height;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }

            // No users selected
            if (selectedUsers.size === 0) {
                ctx.fillStyle = '#7f8c8d';
                ctx.font = '14px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Select a user to see signal graph', width / 2, height / 2);
                return;
            }

            // Draw signal line for each selected user
            let colorIdx = 0;
            for (const [userId, entries] of Object.entries(userData)) {
                const userColor = userColors[colorIdx % userColors.length];
                colorIdx++;

                if (!selectedUsers.has(userId)) continue;

                // Filter entries by time range
                const filtered = entries.filter(e => e.ts >= rangeStartTime && e.ts <= rangeEndTime);
                if (filtered.length < 2) continue;

                // Draw the signal line
                ctx.strokeStyle = userColor;
                ctx.lineWidth = 2;
                ctx.beginPath();

                let started = false;
                for (const entry of filtered) {
                    if (entry.sig === undefined || entry.sig === null) continue;

                    const x = ((entry.ts - rangeStartTime) / (rangeEndTime - rangeStartTime)) * width;
                    const y = height - (entry.sig / 4) * height;

                    if (!started) {
                        ctx.moveTo(x, y);
                        started = true;
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();

                // Draw user label at the end of the line
                if (filtered.length > 0) {
                    const last = filtered[filtered.length - 1];
                    if (last.sig !== undefined && last.sig !== null) {
                        const x = ((last.ts - rangeStartTime) / (rangeEndTime - rangeStartTime)) * width;
                        const y = height - (last.sig / 4) * height;
                        const sigBars = '‚ñÇ‚ñÑ‚ñÜ‚ñà'.slice(0, Math.max(1, Math.min(4, last.sig)));
                        ctx.fillStyle = userColor;
                        ctx.font = 'bold 10px sans-serif';
                        ctx.textAlign = 'right';
                        ctx.fillText(`${getDisplayName(userId)}: ${sigBars}`, Math.min(x, width - 5), y - 5);
                    }
                }
            }
        }

        // Calculate network latency for an entry
        // For 1Hz batched positions, use batch_ts (when batch was sent) instead of ts
        function getNetworkLatency(entry) {
            if (entry.recv_ts === undefined) return null;
            // Use batch_ts if available (for batched 1Hz positions), otherwise use ts
            const sendTime = entry.batch_ts !== undefined ? entry.batch_ts : entry.ts;
            return entry.recv_ts - sendTime;
        }

        function drawLatencyGraph() {
            // Only draw if latency graph is visible
            if (!document.getElementById('show-latency-graph').checked) return;

            const canvas = document.getElementById('latency-graph');
            const ctx = canvas.getContext('2d');

            // Set canvas size to match display size (for sharp rendering)
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * window.devicePixelRatio;
            canvas.height = rect.height * window.devicePixelRatio;
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);

            const width = rect.width;
            const height = rect.height;

            // Clear canvas
            ctx.clearRect(0, 0, width, height);

            // Update time axis labels
            document.getElementById('latency-time-start').textContent = formatTimeShortInTz(rangeStartTime);
            document.getElementById('latency-time-end').textContent = formatTimeShortInTz(rangeEndTime);

            // Calculate max latency for Y axis scaling (only from visible time range)
            let maxLatency = 0;
            let hasLatencyValues = false;
            for (const [userId, entries] of Object.entries(userData)) {
                if (!selectedUsers.has(userId)) continue;
                for (const entry of entries) {
                    if (entry.ts < rangeStartTime || entry.ts > rangeEndTime) continue;
                    const latency = getNetworkLatency(entry);
                    if (latency !== null && Math.abs(latency) < 300) {
                        maxLatency = Math.max(maxLatency, Math.abs(latency));
                        hasLatencyValues = true;
                    }
                }
            }

            // Set sensible defaults and add padding
            if (!hasLatencyValues || maxLatency === 0) {
                maxLatency = 10;
            } else {
                // Add 10% padding above max
                maxLatency = maxLatency * 1.1;
                // Round to nice number based on magnitude
                if (maxLatency < 2) {
                    maxLatency = Math.ceil(maxLatency * 4) / 4;  // Round to 0.25s
                    if (maxLatency < 0.5) maxLatency = 0.5;
                } else if (maxLatency < 5) {
                    maxLatency = Math.ceil(maxLatency);  // Round to 1s
                } else {
                    maxLatency = Math.ceil(maxLatency / 2) * 2;  // Round to 2s
                }
            }

            // Update Y axis labels
            const yLabels = document.getElementById('latency-y-labels');
            yLabels.innerHTML = `
                <span>${maxLatency.toFixed(maxLatency < 2 ? 2 : 0)}</span>
                <span>${(maxLatency * 0.75).toFixed(maxLatency < 2 ? 2 : 1)}</span>
                <span>${(maxLatency * 0.5).toFixed(maxLatency < 2 ? 2 : 1)}</span>
                <span>${(maxLatency * 0.25).toFixed(maxLatency < 2 ? 2 : 1)}</span>
                <span>0</span>
            `;

            // Draw grid lines
            ctx.strokeStyle = '#34495e';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 4; i++) {
                const y = (i / 4) * height;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }

            // No users selected
            if (selectedUsers.size === 0) {
                ctx.fillStyle = '#7f8c8d';
                ctx.font = '14px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Select a user to see latency graph', width / 2, height / 2);
                return;
            }

            // Check if any data has recv_ts
            let hasLatencyData = false;
            for (const [userId, entries] of Object.entries(userData)) {
                if (!selectedUsers.has(userId)) continue;
                if (entries.some(e => e.recv_ts !== undefined)) {
                    hasLatencyData = true;
                    break;
                }
            }

            if (!hasLatencyData) {
                ctx.fillStyle = '#7f8c8d';
                ctx.font = '14px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('No latency data (requires server update)', width / 2, height / 2);
                return;
            }

            // Draw latency line for each selected user
            let colorIdx = 0;
            for (const [userId, entries] of Object.entries(userData)) {
                const userColor = userColors[colorIdx % userColors.length];
                colorIdx++;

                if (!selectedUsers.has(userId)) continue;

                // Filter entries by time range
                const filtered = entries.filter(e => e.ts >= rangeStartTime && e.ts <= rangeEndTime);
                if (filtered.length < 2) continue;

                // Draw the latency line (use absolute value, dashed for negative)
                ctx.strokeStyle = userColor;
                ctx.lineWidth = 2;

                let started = false;
                let lastWasNegative = false;
                for (const entry of filtered) {
                    const rawLatency = getNetworkLatency(entry);
                    if (rawLatency === null) continue;
                    const latency = Math.abs(rawLatency);
                    if (latency > 300) continue; // Skip extreme values

                    const isNegative = rawLatency < 0;
                    const x = ((entry.ts - rangeStartTime) / (rangeEndTime - rangeStartTime)) * width;
                    const y = height - (latency / maxLatency) * height;

                    // Switch line style when sign changes
                    if (started && isNegative !== lastWasNegative) {
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(x, y);
                    }

                    // Use dashed line for negative latencies (clock ahead)
                    ctx.setLineDash(isNegative ? [4, 2] : []);

                    if (!started) {
                        ctx.beginPath();
                        ctx.moveTo(x, y);
                        started = true;
                    } else {
                        ctx.lineTo(x, y);
                    }
                    lastWasNegative = isNegative;
                }
                ctx.stroke();
                ctx.setLineDash([]);

                // Draw user label at the end of the line
                if (filtered.length > 0) {
                    const last = filtered[filtered.length - 1];
                    const rawLatency = getNetworkLatency(last);
                    if (rawLatency !== null) {
                        const latency = Math.abs(rawLatency);
                        if (latency <= 300) {
                            const x = ((last.ts - rangeStartTime) / (rangeEndTime - rangeStartTime)) * width;
                            const y = height - (latency / maxLatency) * height;
                            ctx.fillStyle = userColor;
                            ctx.font = 'bold 10px sans-serif';
                            ctx.textAlign = 'right';
                            const sign = rawLatency < 0 ? '-' : '';
                            ctx.fillText(`${getDisplayName(userId)}: ${sign}${latency.toFixed(1)}s`, Math.min(x, width - 5), y - 5);
                        }
                    }
                }
            }
        }

        function drawHeartRateGraph() {
            // Only draw if heart rate graph is visible
            if (!document.getElementById('show-heartrate-graph').checked) return;

            const canvas = document.getElementById('heartrate-graph');
            const ctx = canvas.getContext('2d');

            // Set canvas size to match display size (for sharp rendering)
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * window.devicePixelRatio;
            canvas.height = rect.height * window.devicePixelRatio;
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);

            const width = rect.width;
            const height = rect.height;

            // Clear canvas
            ctx.clearRect(0, 0, width, height);

            // Update time axis labels
            document.getElementById('heartrate-time-start').textContent = formatTimeShortInTz(rangeStartTime);
            document.getElementById('heartrate-time-end').textContent = formatTimeShortInTz(rangeEndTime);

            // Calculate heart rate range for Y axis scaling (only from visible time range)
            let maxHR = 0;
            let minHR = Infinity;
            let hasHRData = false;
            for (const [userId, entries] of Object.entries(userData)) {
                if (!selectedUsers.has(userId)) continue;
                for (const entry of entries) {
                    if (entry.ts < rangeStartTime || entry.ts > rangeEndTime) continue;
                    if (entry.hr !== undefined && entry.hr > 0) {
                        maxHR = Math.max(maxHR, entry.hr);
                        minHR = Math.min(minHR, entry.hr);
                        hasHRData = true;
                    }
                }
            }

            // Set sensible defaults and add padding
            if (!hasHRData || maxHR === 0) {
                maxHR = 200;
                minHR = 0;
            } else {
                // Add 10% padding above max
                maxHR = Math.ceil((maxHR * 1.1) / 10) * 10;
                // Round min down to nearest 10, with some padding below
                minHR = Math.max(0, Math.floor((minHR * 0.9) / 10) * 10);
                // Ensure at least 40 bpm range for readability
                if (maxHR - minHR < 40) {
                    const mid = (maxHR + minHR) / 2;
                    maxHR = Math.ceil((mid + 20) / 10) * 10;
                    minHR = Math.max(0, Math.floor((mid - 20) / 10) * 10);
                }
            }

            // Update Y axis labels
            const yLabels = document.getElementById('heartrate-y-labels');
            const range = maxHR - minHR;
            yLabels.innerHTML = `
                <span>${maxHR}</span>
                <span>${Math.round(minHR + range * 0.75)}</span>
                <span>${Math.round(minHR + range * 0.5)}</span>
                <span>${Math.round(minHR + range * 0.25)}</span>
                <span>${minHR}</span>
            `;

            // Draw grid lines
            ctx.strokeStyle = '#34495e';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 4; i++) {
                const y = (i / 4) * height;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }

            // No users selected
            if (selectedUsers.size === 0) {
                ctx.fillStyle = '#7f8c8d';
                ctx.font = '14px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Select a user to see heart rate graph', width / 2, height / 2);
                return;
            }

            if (!hasHRData) {
                ctx.fillStyle = '#7f8c8d';
                ctx.font = '14px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('No heart rate data available', width / 2, height / 2);
                return;
            }

            // Draw heart rate line for each selected user
            let colorIdx = 0;
            for (const [userId, entries] of Object.entries(userData)) {
                const userColor = userColors[colorIdx % userColors.length];
                colorIdx++;

                if (!selectedUsers.has(userId)) continue;

                // Filter entries by time range and having HR data
                const filtered = entries.filter(e => e.ts >= rangeStartTime && e.ts <= rangeEndTime && e.hr !== undefined && e.hr > 0);
                if (filtered.length < 2) continue;

                // Draw the heart rate line
                ctx.strokeStyle = '#e91e63'; // Pink color for heart rate
                ctx.lineWidth = 2;
                ctx.beginPath();

                let started = false;
                for (const entry of filtered) {
                    const x = ((entry.ts - rangeStartTime) / (rangeEndTime - rangeStartTime)) * width;
                    const y = height - ((entry.hr - minHR) / range) * height;

                    if (!started) {
                        ctx.moveTo(x, y);
                        started = true;
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();

                // Draw user label at the end of the line
                if (filtered.length > 0) {
                    const last = filtered[filtered.length - 1];
                    const x = ((last.ts - rangeStartTime) / (rangeEndTime - rangeStartTime)) * width;
                    const y = height - ((last.hr - minHR) / range) * height;
                    ctx.fillStyle = '#e91e63';
                    ctx.font = 'bold 10px sans-serif';
                    ctx.textAlign = 'right';
                    ctx.fillText(`${getDisplayName(userId)}: ${last.hr} bpm`, Math.min(x, width - 5), y - 5);
                }
            }
        }

        function drawAccuracyGraph() {
            // Only draw if accuracy graph is visible
            if (!document.getElementById('show-accuracy-graph').checked) return;

            const canvas = document.getElementById('accuracy-graph');
            const ctx = canvas.getContext('2d');

            // Set canvas size to match display size (for sharp rendering)
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * window.devicePixelRatio;
            canvas.height = rect.height * window.devicePixelRatio;
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);

            const width = rect.width;
            const height = rect.height;

            // Clear canvas
            ctx.clearRect(0, 0, width, height);

            // Update time axis labels
            document.getElementById('accuracy-time-start').textContent = formatTimeShortInTz(rangeStartTime);
            document.getElementById('accuracy-time-end').textContent = formatTimeShortInTz(rangeEndTime);

            // Calculate accuracy range for Y axis scaling (only from visible time range)
            let maxAcc = 0;
            let hasAccData = false;
            for (const [userId, entries] of Object.entries(userData)) {
                if (!selectedUsers.has(userId)) continue;
                for (const entry of entries) {
                    if (entry.ts < rangeStartTime || entry.ts > rangeEndTime) continue;
                    if (entry.hac !== undefined && entry.hac > 0) {
                        maxAcc = Math.max(maxAcc, entry.hac);
                        hasAccData = true;
                    }
                }
            }

            // Set sensible defaults and add padding
            if (!hasAccData || maxAcc === 0) {
                maxAcc = 100;
            } else {
                // Add 10% padding above max, round to nice number
                maxAcc = Math.ceil((maxAcc * 1.1) / 10) * 10;
                maxAcc = Math.max(maxAcc, 10); // At least 10m range
            }

            // Update Y axis labels
            const yLabels = document.getElementById('accuracy-y-labels');
            yLabels.innerHTML = `
                <span>${maxAcc}</span>
                <span>${Math.round(maxAcc * 0.75)}</span>
                <span>${Math.round(maxAcc * 0.5)}</span>
                <span>${Math.round(maxAcc * 0.25)}</span>
                <span>0</span>
            `;

            // Draw grid lines
            ctx.strokeStyle = '#34495e';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 4; i++) {
                const y = (i / 4) * height;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }

            // No users selected
            if (selectedUsers.size === 0) {
                ctx.fillStyle = '#7f8c8d';
                ctx.font = '14px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Select a user to see accuracy graph', width / 2, height / 2);
                return;
            }

            if (!hasAccData) {
                ctx.fillStyle = '#7f8c8d';
                ctx.font = '14px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('No accuracy data available', width / 2, height / 2);
                return;
            }

            // Draw accuracy line for each selected user
            let colorIdx = 0;
            for (const [userId, entries] of Object.entries(userData)) {
                const userColor = userColors[colorIdx % userColors.length];
                colorIdx++;

                if (!selectedUsers.has(userId)) continue;

                // Filter entries by time range and having accuracy data
                const filtered = entries.filter(e => e.ts >= rangeStartTime && e.ts <= rangeEndTime && e.hac !== undefined && e.hac > 0);
                if (filtered.length < 2) continue;

                // Draw the accuracy line
                ctx.strokeStyle = '#9b59b6'; // Purple color for accuracy
                ctx.lineWidth = 2;
                ctx.beginPath();

                let started = false;
                for (const entry of filtered) {
                    const x = ((entry.ts - rangeStartTime) / (rangeEndTime - rangeStartTime)) * width;
                    const y = height - (entry.hac / maxAcc) * height;

                    if (!started) {
                        ctx.moveTo(x, y);
                        started = true;
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();

                // Draw user label at the end of the line
                if (filtered.length > 0) {
                    const last = filtered[filtered.length - 1];
                    const x = ((last.ts - rangeStartTime) / (rangeEndTime - rangeStartTime)) * width;
                    const y = height - (last.hac / maxAcc) * height;
                    ctx.fillStyle = '#9b59b6';
                    ctx.font = 'bold 10px sans-serif';
                    ctx.textAlign = 'right';
                    ctx.fillText(`${getDisplayName(userId)}: ${last.hac.toFixed(1)}m`, Math.min(x, width - 5), y - 5);
                }
            }
        }

        function drawDistanceGraph() {
            // Only draw if distance graph is visible
            if (!document.getElementById('show-distance-graph').checked) return;

            const canvas = document.getElementById('distance-graph');
            const ctx = canvas.getContext('2d');

            // Set canvas size to match display size (for sharp rendering)
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * window.devicePixelRatio;
            canvas.height = rect.height * window.devicePixelRatio;
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);

            const width = rect.width;
            const height = rect.height;

            // Clear canvas
            ctx.clearRect(0, 0, width, height);

            // Update time axis labels
            document.getElementById('distance-time-start').textContent = formatTimeShortInTz(rangeStartTime);
            document.getElementById('distance-time-end').textContent = formatTimeShortInTz(rangeEndTime);

            // Calculate cumulative distance for each user (only 10s points for CPU efficiency)
            let maxDist = 0;
            let hasDistData = false;
            const userDistances = {};
            cachedDistanceData = {};  // Reset cache

            for (const [userId, entries] of Object.entries(userData)) {
                if (!selectedUsers.has(userId)) continue;

                // Filter to only 10s points (skip 1s high-frequency points)
                // 10s points have gaps >= 5 seconds from the previous point
                const filtered = [];
                let lastTs = -Infinity;
                for (const entry of entries) {
                    if (entry.ts < rangeStartTime || entry.ts > rangeEndTime) continue;
                    // Only include points that are at least 5 seconds apart (to catch 10s points)
                    if (entry.ts - lastTs >= 5) {
                        filtered.push(entry);
                        lastTs = entry.ts;
                    }
                }

                if (filtered.length < 2) continue;

                // Calculate cumulative distance
                const distances = [{ts: filtered[0].ts, dist: 0}];
                let cumDist = 0;
                for (let i = 1; i < filtered.length; i++) {
                    const prev = filtered[i - 1];
                    const curr = filtered[i];
                    const d = haversineDistance(prev.lat, prev.lon, curr.lat, curr.lon) * 1000; // km to meters
                    cumDist += d;
                    distances.push({ts: curr.ts, dist: cumDist});
                }

                if (distances.length > 1) {
                    userDistances[userId] = distances;
                    maxDist = Math.max(maxDist, cumDist);
                    hasDistData = true;
                }
            }

            // Cache for hover display
            cachedDistanceData = userDistances;

            // Set sensible defaults and add padding
            if (!hasDistData || maxDist === 0) {
                maxDist = 10000;
            } else {
                // Add 10% padding above max, round to nice number
                maxDist = Math.ceil((maxDist * 1.1) / 1000) * 1000;
                maxDist = Math.max(maxDist, 1000); // At least 1km range
            }

            // Update Y axis labels (show in km if over 10km, otherwise meters)
            const yLabels = document.getElementById('distance-y-labels');
            if (maxDist >= 10000) {
                yLabels.innerHTML = `
                    <span>${(maxDist / 1000).toFixed(1)}km</span>
                    <span>${(maxDist * 0.75 / 1000).toFixed(1)}km</span>
                    <span>${(maxDist * 0.5 / 1000).toFixed(1)}km</span>
                    <span>${(maxDist * 0.25 / 1000).toFixed(1)}km</span>
                    <span>0</span>
                `;
            } else {
                yLabels.innerHTML = `
                    <span>${Math.round(maxDist)}m</span>
                    <span>${Math.round(maxDist * 0.75)}m</span>
                    <span>${Math.round(maxDist * 0.5)}m</span>
                    <span>${Math.round(maxDist * 0.25)}m</span>
                    <span>0</span>
                `;
            }

            // Draw grid lines
            ctx.strokeStyle = '#34495e';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 4; i++) {
                const y = (i / 4) * height;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }

            // No users selected
            if (selectedUsers.size === 0) {
                ctx.fillStyle = '#7f8c8d';
                ctx.font = '14px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Select a user to see distance graph', width / 2, height / 2);
                return;
            }

            if (!hasDistData) {
                ctx.fillStyle = '#7f8c8d';
                ctx.font = '14px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Not enough data for distance calculation', width / 2, height / 2);
                return;
            }

            // Draw distance line for each selected user
            let colorIdx = 0;
            for (const [userId, distances] of Object.entries(userDistances)) {
                const userColor = userColors[colorIdx % userColors.length];
                colorIdx++;

                if (distances.length < 2) continue;

                // Draw the distance line
                ctx.strokeStyle = '#27ae60'; // Green color for distance
                ctx.lineWidth = 2;
                ctx.beginPath();

                let started = false;
                for (const point of distances) {
                    const x = ((point.ts - rangeStartTime) / (rangeEndTime - rangeStartTime)) * width;
                    const y = height - (point.dist / maxDist) * height;

                    if (!started) {
                        ctx.moveTo(x, y);
                        started = true;
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();

                // Draw user label at the end of the line
                if (distances.length > 0) {
                    const last = distances[distances.length - 1];
                    const x = ((last.ts - rangeStartTime) / (rangeEndTime - rangeStartTime)) * width;
                    const y = height - (last.dist / maxDist) * height;
                    ctx.fillStyle = '#27ae60';
                    ctx.font = 'bold 10px sans-serif';
                    ctx.textAlign = 'right';
                    const distLabel = last.dist >= 1000 ? `${(last.dist / 1000).toFixed(2)}km` : `${Math.round(last.dist)}m`;
                    ctx.fillText(`${getDisplayName(userId)}: ${distLabel}`, Math.min(x, width - 5), y - 5);
                }
            }
        }

        // Graph hover highlighting (shared between battery, signal, and latency graphs)
        let graphHighlightMarkers = [];
        let pendingHighlightUpdate = null;

        function clearGraphHighlight() {
            // Cancel any pending highlight update
            if (pendingHighlightUpdate) {
                cancelAnimationFrame(pendingHighlightUpdate);
                pendingHighlightUpdate = null;
            }

            // Remove highlight markers from map (explicitly remove tooltips to prevent orphans)
            for (const marker of graphHighlightMarkers) {
                const tooltip = marker.getTooltip();
                marker.closeTooltip();
                if (tooltip && map.hasLayer(tooltip)) {
                    map.removeLayer(tooltip);
                }
                marker.unbindTooltip();
                map.removeLayer(marker);
            }
            graphHighlightMarkers = [];

            // Redraw graphs without highlight
            if (document.getElementById('show-speed-graph').checked) {
                drawSpeedGraph();
            }
            if (document.getElementById('show-battery-graph').checked) {
                drawBatteryGraph();
            }
            if (document.getElementById('show-signal-graph').checked) {
                drawSignalGraph();
            }
            if (document.getElementById('show-latency-graph').checked) {
                drawLatencyGraph();
            }
            if (document.getElementById('show-heartrate-graph').checked) {
                drawHeartRateGraph();
            }
            if (document.getElementById('show-accuracy-graph').checked) {
                drawAccuracyGraph();
            }
            if (document.getElementById('show-distance-graph').checked) {
                drawDistanceGraph();
            }
        }

        function showGraphHighlight(mouseX, sourceGraph) {
            // Cancel any pending update to prevent race conditions
            if (pendingHighlightUpdate) {
                cancelAnimationFrame(pendingHighlightUpdate);
            }

            // Debounce with requestAnimationFrame for smooth updates
            pendingHighlightUpdate = requestAnimationFrame(() => {
                pendingHighlightUpdate = null;
                showGraphHighlightImmediate(mouseX, sourceGraph);
            });
        }

        function showGraphHighlightImmediate(mouseX, sourceGraph) {
            const canvas = document.getElementById(sourceGraph);
            const rect = canvas.getBoundingClientRect();
            const width = rect.width;

            // Calculate timestamp from mouse X position
            const ratio = Math.max(0, Math.min(1, mouseX / width));
            const timestamp = rangeStartTime + ratio * (rangeEndTime - rangeStartTime);

            // Clear previous highlight markers (explicitly remove tooltips to prevent orphans)
            for (const marker of graphHighlightMarkers) {
                const tooltip = marker.getTooltip();
                marker.closeTooltip();
                if (tooltip && map.hasLayer(tooltip)) {
                    map.removeLayer(tooltip);
                }
                marker.unbindTooltip();
                map.removeLayer(marker);
            }
            graphHighlightMarkers = [];

            // Find and highlight position for each selected user
            let colorIdx = 0;
            for (const [userId, entries] of Object.entries(userData)) {
                const userColor = userColors[colorIdx % userColors.length];
                colorIdx++;

                if (!selectedUsers.has(userId)) continue;

                // Filter entries by time range
                const filtered = entries.filter(e => e.ts >= rangeStartTime && e.ts <= rangeEndTime);
                if (filtered.length === 0) continue;

                // Find closest entry to timestamp
                let closest = filtered[0];
                let closestDist = Math.abs(filtered[0].ts - timestamp);
                for (const entry of filtered) {
                    const dist = Math.abs(entry.ts - timestamp);
                    if (dist < closestDist) {
                        closestDist = dist;
                        closest = entry;
                    }
                }

                // Create highlight marker on map
                const marker = L.circleMarker([closest.lat, closest.lon], {
                    radius: 12,
                    fillColor: userColor,
                    color: '#fff',
                    weight: 3,
                    fillOpacity: 0.9,
                    opacity: 1
                });

                // Add tooltip with info
                const time = formatTimeInTz(closest.ts);
                let tooltipHtml = `
                    <b>${getDisplayName(userId)}</b><br>
                    Time: ${time}<br>
                    Battery: ${closest.bat !== undefined ? closest.bat + '%' : 'N/A'}<br>
                    Speed: ${(closest.spd || 0).toFixed(1)} kts`;

                // Add accuracy if available
                if (closest.hac !== undefined) {
                    const hacColor = closest.hac > 50 ? '#e74c3c' : closest.hac > 20 ? '#f39c12' : '#2ecc71';
                    tooltipHtml += `<br>Accuracy: <span style="color:${hacColor}">${closest.hac.toFixed(1)}m</span>`;
                }

                // Add signal strength if available
                if (closest.sig !== undefined && closest.sig !== null) {
                    const sigBars = '‚ñÇ‚ñÑ‚ñÜ‚ñà'.slice(0, Math.max(1, Math.min(4, closest.sig)));
                    tooltipHtml += `<br>Signal: ${sigBars} (${closest.sig})`;
                }

                // Add latency if available
                const latency = getNetworkLatency(closest);
                if (latency !== null && Math.abs(latency) < 300) {
                    let latencyColor, latencyText;
                    if (latency < 0) {
                        // Negative = phone clock ahead of server
                        latencyColor = '#9b59b6'; // Purple for clock ahead
                        latencyText = `${latency.toFixed(1)}s (clock ahead)`;
                    } else {
                        latencyColor = latency > 5 ? '#e74c3c' : latency > 2 ? '#f39c12' : '#2ecc71';
                        latencyText = `${latency.toFixed(1)}s`;
                    }
                    tooltipHtml += `<br>Latency: <span style="color:${latencyColor}">${latencyText}</span>`;
                }

                // Add heart rate if available (search nearby entries since HR only sent every ~10 samples)
                let hrValue = closest.hr;
                if (hrValue === undefined || hrValue <= 0) {
                    // Search nearby entries for HR data (within 15 seconds)
                    for (const entry of filtered) {
                        if (Math.abs(entry.ts - closest.ts) <= 15 && entry.hr !== undefined && entry.hr > 0) {
                            hrValue = entry.hr;
                            break;
                        }
                    }
                }
                if (hrValue !== undefined && hrValue > 0) {
                    tooltipHtml += `<br>Heart Rate: <span style="color:#e91e63">${hrValue} bpm</span>`;
                }

                // Add battery saver warning if active
                if (closest.flg) {
                    if (closest.flg.ps) {
                        tooltipHtml += `<br><span style="color:#e74c3c">‚ö†Ô∏è Battery Saver ON</span>`;
                    }
                    if (closest.flg.bo === false) {
                        tooltipHtml += `<br><span style="color:#f39c12">‚ö†Ô∏è Battery Opt OFF</span>`;
                    }
                }

                marker.bindTooltip(tooltipHtml, { permanent: true, direction: 'top', offset: [0, -10] });

                marker.addTo(map);
                graphHighlightMarkers.push(marker);
            }

            // Redraw graphs with highlight line
            drawGraphsWithHighlight(mouseX, ratio);
        }

        function drawGraphsWithHighlight(highlightX, ratio) {
            const timestamp = rangeStartTime + ratio * (rangeEndTime - rangeStartTime);

            // Draw speed graph with highlight if visible
            if (document.getElementById('show-speed-graph').checked) {
                drawSpeedGraph();
                // Calculate speed range for proper scaling (only from visible time range)
                let maxSpeed = 0;
                let hasSpeedData = false;
                for (const [userId, entries] of Object.entries(userData)) {
                    if (!selectedUsers.has(userId)) continue;
                    for (const entry of entries) {
                        if (entry.ts < rangeStartTime || entry.ts > rangeEndTime) continue;
                        if (entry.spd !== undefined && entry.spd !== null && entry.spd >= 0) {
                            maxSpeed = Math.max(maxSpeed, entry.spd);
                            hasSpeedData = true;
                        }
                    }
                }
                if (!hasSpeedData || maxSpeed === 0) {
                    maxSpeed = 20;
                } else {
                    maxSpeed = Math.ceil((maxSpeed * 1.1) / 2) * 2;
                    if (maxSpeed < 5) maxSpeed = 5;
                }
                drawHighlightOnGraph('speed-graph', highlightX, ratio, timestamp, 'spd', maxSpeed, 0);
            }

            // Draw battery graph with highlight if visible
            if (document.getElementById('show-battery-graph').checked) {
                drawBatteryGraph();
                // Calculate battery range for proper scaling
                let maxBat = 0;
                let minBat = 100;
                let hasBatData = false;
                for (const [userId, entries] of Object.entries(userData)) {
                    if (!selectedUsers.has(userId)) continue;
                    for (const entry of entries) {
                        if (entry.ts < rangeStartTime || entry.ts > rangeEndTime) continue;
                        if (entry.bat !== undefined && entry.bat !== null && entry.bat >= 0) {
                            maxBat = Math.max(maxBat, entry.bat);
                            minBat = Math.min(minBat, entry.bat);
                            hasBatData = true;
                        }
                    }
                }
                if (!hasBatData) {
                    maxBat = 100;
                    minBat = 0;
                } else {
                    maxBat = maxBat > 95 ? 100 : Math.ceil((maxBat + 5) / 5) * 5;
                    minBat = Math.floor(minBat / 5) * 5;
                    if (maxBat - minBat < 10) {
                        if (maxBat < 100) maxBat = Math.min(100, minBat + 10);
                        else minBat = Math.max(0, maxBat - 10);
                    }
                }
                drawHighlightOnGraph('battery-graph', highlightX, ratio, timestamp, 'bat', maxBat, minBat);
            }

            // Draw signal graph with highlight if visible
            if (document.getElementById('show-signal-graph').checked) {
                drawSignalGraph();
                drawHighlightOnGraph('signal-graph', highlightX, ratio, timestamp, 'sig', 4);
            }

            // Draw latency graph with highlight if visible
            if (document.getElementById('show-latency-graph').checked) {
                drawLatencyGraph();
                // Calculate current max latency for proper scaling (only from visible time range)
                let maxLatency = 0;
                let hasLatencyValues = false;
                for (const [userId, entries] of Object.entries(userData)) {
                    if (!selectedUsers.has(userId)) continue;
                    for (const entry of entries) {
                        if (entry.ts < rangeStartTime || entry.ts > rangeEndTime) continue;
                        const latency = getNetworkLatency(entry);
                        if (latency !== null && Math.abs(latency) < 300) {
                            maxLatency = Math.max(maxLatency, Math.abs(latency));
                            hasLatencyValues = true;
                        }
                    }
                }
                if (!hasLatencyValues || maxLatency === 0) {
                    maxLatency = 10;
                } else {
                    maxLatency = maxLatency * 1.1;
                    if (maxLatency < 2) {
                        maxLatency = Math.ceil(maxLatency * 4) / 4;
                        if (maxLatency < 0.5) maxLatency = 0.5;
                    } else if (maxLatency < 5) {
                        maxLatency = Math.ceil(maxLatency);
                    } else {
                        maxLatency = Math.ceil(maxLatency / 2) * 2;
                    }
                }
                drawLatencyHighlightOnGraph('latency-graph', highlightX, ratio, timestamp, maxLatency);
            }

            // Draw heart rate graph with highlight if visible
            if (document.getElementById('show-heartrate-graph').checked) {
                drawHeartRateGraph();
                // Calculate heart rate range for proper scaling (only from visible time range)
                let maxHR = 0;
                let minHR = Infinity;
                let hasHRData = false;
                for (const [userId, entries] of Object.entries(userData)) {
                    if (!selectedUsers.has(userId)) continue;
                    for (const entry of entries) {
                        if (entry.ts < rangeStartTime || entry.ts > rangeEndTime) continue;
                        if (entry.hr !== undefined && entry.hr > 0) {
                            maxHR = Math.max(maxHR, entry.hr);
                            minHR = Math.min(minHR, entry.hr);
                            hasHRData = true;
                        }
                    }
                }
                if (!hasHRData || maxHR === 0) {
                    maxHR = 200;
                    minHR = 0;
                } else {
                    maxHR = Math.ceil((maxHR * 1.1) / 10) * 10;
                    minHR = Math.max(0, Math.floor((minHR * 0.9) / 10) * 10);
                    if (maxHR - minHR < 40) {
                        const mid = (maxHR + minHR) / 2;
                        maxHR = Math.ceil((mid + 20) / 10) * 10;
                        minHR = Math.max(0, Math.floor((mid - 20) / 10) * 10);
                    }
                }
                drawHighlightOnGraph('heartrate-graph', highlightX, ratio, timestamp, 'hr', maxHR, minHR);
            }

            // Draw accuracy graph with highlight if visible
            if (document.getElementById('show-accuracy-graph').checked) {
                drawAccuracyGraph();
                // Calculate accuracy range for proper scaling (only from visible time range)
                let maxAcc = 0;
                let hasAccData = false;
                for (const [userId, entries] of Object.entries(userData)) {
                    if (!selectedUsers.has(userId)) continue;
                    for (const entry of entries) {
                        if (entry.ts < rangeStartTime || entry.ts > rangeEndTime) continue;
                        if (entry.hac !== undefined && entry.hac > 0) {
                            maxAcc = Math.max(maxAcc, entry.hac);
                            hasAccData = true;
                        }
                    }
                }
                if (!hasAccData || maxAcc === 0) {
                    maxAcc = 100;
                } else {
                    maxAcc = Math.ceil((maxAcc * 1.1) / 10) * 10;
                    maxAcc = Math.max(maxAcc, 10);
                }
                drawHighlightOnGraph('accuracy-graph', highlightX, ratio, timestamp, 'hac', maxAcc, 0);
            }
        }

        function drawLatencyHighlightOnGraph(canvasId, highlightX, ratio, timestamp, maxLatency) {
            const canvas = document.getElementById(canvasId);
            const ctx = canvas.getContext('2d');
            const rect = canvas.getBoundingClientRect();
            const height = rect.height;

            // Draw vertical highlight line
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 3]);
            ctx.beginPath();
            ctx.moveTo(highlightX * window.devicePixelRatio, 0);
            ctx.lineTo(highlightX * window.devicePixelRatio, height * window.devicePixelRatio);
            ctx.stroke();
            ctx.setLineDash([]);

            // Draw dots at intersection points
            let colorIdx = 0;
            for (const [userId, entries] of Object.entries(userData)) {
                const userColor = userColors[colorIdx % userColors.length];
                colorIdx++;

                if (!selectedUsers.has(userId)) continue;

                const filtered = entries.filter(e => e.ts >= rangeStartTime && e.ts <= rangeEndTime);
                if (filtered.length === 0) continue;

                // Find closest entry
                let closest = filtered[0];
                let closestDist = Math.abs(filtered[0].ts - timestamp);
                for (const entry of filtered) {
                    const dist = Math.abs(entry.ts - timestamp);
                    if (dist < closestDist) {
                        closestDist = dist;
                        closest = entry;
                    }
                }

                const rawLatency = getNetworkLatency(closest);
                if (rawLatency !== null) {
                    const latency = Math.abs(rawLatency);
                    if (latency < 300) {
                        const x = ((closest.ts - rangeStartTime) / (rangeEndTime - rangeStartTime)) * rect.width;
                        const y = height - (latency / maxLatency) * height;

                        ctx.beginPath();
                        ctx.arc(x * window.devicePixelRatio, y * window.devicePixelRatio, 6 * window.devicePixelRatio, 0, Math.PI * 2);
                        ctx.fillStyle = userColor;
                        ctx.fill();
                        ctx.strokeStyle = '#fff';
                        ctx.lineWidth = 2 * window.devicePixelRatio;
                        ctx.stroke();
                    }
                }
            }
        }

        function drawHighlightOnGraph(canvasId, highlightX, ratio, timestamp, dataField, maxValue, minValue = 0) {
            const canvas = document.getElementById(canvasId);
            const ctx = canvas.getContext('2d');
            const rect = canvas.getBoundingClientRect();
            const height = rect.height;
            const valueRange = maxValue - minValue;

            // Draw vertical highlight line
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 3]);
            ctx.beginPath();
            ctx.moveTo(highlightX * window.devicePixelRatio, 0);
            ctx.lineTo(highlightX * window.devicePixelRatio, height * window.devicePixelRatio);
            ctx.stroke();
            ctx.setLineDash([]);

            // Draw dots at intersection points
            let colorIdx = 0;
            for (const [userId, entries] of Object.entries(userData)) {
                const userColor = userColors[colorIdx % userColors.length];
                colorIdx++;

                if (!selectedUsers.has(userId)) continue;

                const filtered = entries.filter(e => e.ts >= rangeStartTime && e.ts <= rangeEndTime);
                if (filtered.length === 0) continue;

                // Find closest entry
                let closest = filtered[0];
                let closestDist = Math.abs(filtered[0].ts - timestamp);
                for (const entry of filtered) {
                    const dist = Math.abs(entry.ts - timestamp);
                    if (dist < closestDist) {
                        closestDist = dist;
                        closest = entry;
                    }
                }

                const value = closest[dataField];
                if (value !== undefined && value !== null) {
                    const x = ((closest.ts - rangeStartTime) / (rangeEndTime - rangeStartTime)) * rect.width;
                    const y = height - ((value - minValue) / valueRange) * height;

                    ctx.beginPath();
                    ctx.arc(x * window.devicePixelRatio, y * window.devicePixelRatio, 6 * window.devicePixelRatio, 0, Math.PI * 2);
                    ctx.fillStyle = userColor;
                    ctx.fill();
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2 * window.devicePixelRatio;
                    ctx.stroke();
                }
            }
        }

        // Set up graph mouse events
        document.getElementById('speed-graph').addEventListener('mousemove', (e) => {
            const rect = e.target.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            showGraphHighlight(mouseX, 'speed-graph');
        });

        document.getElementById('speed-graph').addEventListener('mouseleave', () => {
            clearGraphHighlight();
        });

        document.getElementById('battery-graph').addEventListener('mousemove', (e) => {
            const rect = e.target.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            showGraphHighlight(mouseX, 'battery-graph');
        });

        document.getElementById('battery-graph').addEventListener('mouseleave', () => {
            clearGraphHighlight();
        });

        document.getElementById('signal-graph').addEventListener('mousemove', (e) => {
            const rect = e.target.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            showGraphHighlight(mouseX, 'signal-graph');
        });

        document.getElementById('signal-graph').addEventListener('mouseleave', () => {
            clearGraphHighlight();
        });

        document.getElementById('latency-graph').addEventListener('mousemove', (e) => {
            const rect = e.target.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            showGraphHighlight(mouseX, 'latency-graph');
        });

        document.getElementById('latency-graph').addEventListener('mouseleave', () => {
            clearGraphHighlight();
        });

        document.getElementById('heartrate-graph').addEventListener('mousemove', (e) => {
            const rect = e.target.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            showGraphHighlight(mouseX, 'heartrate-graph');
        });

        document.getElementById('heartrate-graph').addEventListener('mouseleave', () => {
            clearGraphHighlight();
        });

        document.getElementById('accuracy-graph').addEventListener('mousemove', (e) => {
            const rect = e.target.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            showGraphHighlight(mouseX, 'accuracy-graph');
        });

        document.getElementById('accuracy-graph').addEventListener('mouseleave', () => {
            clearGraphHighlight();
        });

        document.getElementById('distance-graph').addEventListener('mousemove', (e) => {
            const rect = e.target.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            showGraphHighlight(mouseX, 'distance-graph');

            // Update title with distance at cursor position
            const ratio = Math.max(0, Math.min(1, mouseX / rect.width));
            const timestamp = rangeStartTime + ratio * (rangeEndTime - rangeStartTime);

            // Find the distance at this timestamp (use first selected user's data)
            let distAtCursor = null;
            for (const [userId, distances] of Object.entries(cachedDistanceData)) {
                if (distances.length === 0) continue;
                // Find closest point before or at timestamp
                let closest = distances[0];
                for (const point of distances) {
                    if (point.ts <= timestamp) {
                        closest = point;
                    } else {
                        break;
                    }
                }
                distAtCursor = closest.dist;
                break;  // Just use first user for now
            }

            const titleEl = document.querySelector('#distance-graph-panel .graph-title');
            if (distAtCursor !== null) {
                const label = distAtCursor >= 1000 ? `${(distAtCursor / 1000).toFixed(2)}km` : `${Math.round(distAtCursor)}m`;
                titleEl.textContent = `Distance: ${label}`;
            } else {
                titleEl.textContent = 'Distance (meters)';
            }
        });

        document.getElementById('distance-graph').addEventListener('mouseleave', () => {
            clearGraphHighlight();
            // Reset title
            document.querySelector('#distance-graph-panel .graph-title').textContent = 'Distance (meters)';
        });

        // Set up rubber-band selection on all graph canvases
        ['speed-graph', 'battery-graph', 'signal-graph', 'latency-graph',
         'heartrate-graph', 'accuracy-graph', 'distance-graph'].forEach(id => {
            const canvas = document.getElementById(id);
            if (canvas) {
                setupGraphRubberBand(canvas);
                // Double-click to reset to full time range (or sublog range if selected)
                canvas.addEventListener('dblclick', () => {
                    if (selectedSublog) {
                        // Reset to selected sublog's time range
                        const range = sliderMaxTime - sliderMinTime;
                        if (range > 0) {
                            const startPercent = Math.max(0, Math.min(100, ((selectedSublog.start_ts - sliderMinTime) / range) * 100));
                            const endPercent = Math.max(0, Math.min(100, ((selectedSublog.end_ts - sliderMinTime) / range) * 100));
                            document.getElementById('start-slider').value = startPercent;
                            document.getElementById('end-slider').value = endPercent;
                        }
                    } else {
                        // Reset to full log range
                        document.getElementById('start-slider').value = 0;
                        document.getElementById('end-slider').value = 100;
                    }
                    updateSliderRange();
                    updateTimeDisplay();
                    resetPlaybackPosition();
                    redrawAll();
                });
            }
        });

        // Graph resize functionality
        let speedGraphHeight = parseInt(localStorage.getItem('speedGraphHeight')) || 150;
        let batteryGraphHeight = parseInt(localStorage.getItem('batteryGraphHeight')) || 150;
        let signalGraphHeight = parseInt(localStorage.getItem('signalGraphHeight')) || 150;
        let latencyGraphHeight = parseInt(localStorage.getItem('latencyGraphHeight')) || 150;
        let heartrateGraphHeight = parseInt(localStorage.getItem('heartrateGraphHeight')) || 150;
        let accuracyGraphHeight = parseInt(localStorage.getItem('accuracyGraphHeight')) || 150;
        let distanceGraphHeight = parseInt(localStorage.getItem('distanceGraphHeight')) || 150;
        const speedPanel = document.getElementById('speed-graph-panel');
        const batteryPanel = document.getElementById('battery-graph-panel');
        const signalPanel = document.getElementById('signal-graph-panel');
        const latencyPanel = document.getElementById('latency-graph-panel');
        const heartratePanel = document.getElementById('heartrate-graph-panel');
        const accuracyPanel = document.getElementById('accuracy-graph-panel');
        const distancePanel = document.getElementById('distance-graph-panel');
        const speedResizeHandle = document.getElementById('speed-graph-resize');
        const batteryResizeHandle = document.getElementById('battery-graph-resize');
        const signalResizeHandle = document.getElementById('signal-graph-resize');
        const latencyResizeHandle = document.getElementById('latency-graph-resize');
        const heartrateResizeHandle = document.getElementById('heartrate-graph-resize');
        const accuracyResizeHandle = document.getElementById('accuracy-graph-resize');
        const distanceResizeHandle = document.getElementById('distance-graph-resize');
        let isResizing = false;
        let resizingPanel = null;
        let startY = 0;
        let startHeight = 0;

        // Apply saved heights
        speedPanel.style.height = speedGraphHeight + 'px';
        batteryPanel.style.height = batteryGraphHeight + 'px';
        signalPanel.style.height = signalGraphHeight + 'px';
        latencyPanel.style.height = latencyGraphHeight + 'px';
        heartratePanel.style.height = heartrateGraphHeight + 'px';
        accuracyPanel.style.height = accuracyGraphHeight + 'px';
        distancePanel.style.height = distanceGraphHeight + 'px';

        function updateGraphPositions() {
            const mapEl = document.getElementById('map');
            const speedVisible = document.getElementById('show-speed-graph').checked;
            const batteryVisible = document.getElementById('show-battery-graph').checked;
            const signalVisible = document.getElementById('show-signal-graph').checked;
            const latencyVisible = document.getElementById('show-latency-graph').checked;
            const heartrateVisible = document.getElementById('show-heartrate-graph').checked;
            const accuracyVisible = document.getElementById('show-accuracy-graph').checked;
            const distanceVisible = document.getElementById('show-distance-graph').checked;

            // Get actual timeline height (different on mobile vs desktop)
            const timelineHeight = document.getElementById('timeline').offsetHeight;
            let totalHeight = timelineHeight;
            let currentBottom = timelineHeight;

            // Stack from bottom: distance, accuracy, heartrate, latency, signal, battery, speed
            if (distanceVisible) {
                distancePanel.style.display = 'block';
                distancePanel.style.bottom = currentBottom + 'px';
                currentBottom += distanceGraphHeight;
                totalHeight += distanceGraphHeight;
            } else {
                distancePanel.style.display = 'none';
            }

            if (accuracyVisible) {
                accuracyPanel.style.display = 'block';
                accuracyPanel.style.bottom = currentBottom + 'px';
                currentBottom += accuracyGraphHeight;
                totalHeight += accuracyGraphHeight;
            } else {
                accuracyPanel.style.display = 'none';
            }

            if (heartrateVisible) {
                heartratePanel.style.display = 'block';
                heartratePanel.style.bottom = currentBottom + 'px';
                currentBottom += heartrateGraphHeight;
                totalHeight += heartrateGraphHeight;
            } else {
                heartratePanel.style.display = 'none';
            }

            if (latencyVisible) {
                latencyPanel.style.display = 'block';
                latencyPanel.style.bottom = currentBottom + 'px';
                currentBottom += latencyGraphHeight;
                totalHeight += latencyGraphHeight;
            } else {
                latencyPanel.style.display = 'none';
            }

            if (signalVisible) {
                signalPanel.style.display = 'block';
                signalPanel.style.bottom = currentBottom + 'px';
                currentBottom += signalGraphHeight;
                totalHeight += signalGraphHeight;
            } else {
                signalPanel.style.display = 'none';
            }

            if (batteryVisible) {
                batteryPanel.style.display = 'block';
                batteryPanel.style.bottom = currentBottom + 'px';
                currentBottom += batteryGraphHeight;
                totalHeight += batteryGraphHeight;
            } else {
                batteryPanel.style.display = 'none';
            }

            if (speedVisible) {
                speedPanel.style.display = 'block';
                speedPanel.style.bottom = currentBottom + 'px';
                totalHeight += speedGraphHeight;
            } else {
                speedPanel.style.display = 'none';
            }

            mapEl.style.bottom = totalHeight + 'px';
            map.invalidateSize();

            // Update speed legend and scale positions to stay above graphs
            document.querySelector('.speed-legend').style.bottom = (totalHeight + 20) + 'px';
            document.getElementById('customScale').style.bottom = (totalHeight + 95) + 'px';
        }

        speedResizeHandle.addEventListener('mousedown', (e) => {
            isResizing = true;
            resizingPanel = 'speed';
            startY = e.clientY;
            startHeight = speedGraphHeight;
            speedResizeHandle.classList.add('dragging');
            document.body.style.cursor = 'ns-resize';
            document.body.style.userSelect = 'none';
            e.preventDefault();
        });

        batteryResizeHandle.addEventListener('mousedown', (e) => {
            isResizing = true;
            resizingPanel = 'battery';
            startY = e.clientY;
            startHeight = batteryPanel.offsetHeight;
            batteryResizeHandle.classList.add('dragging');
            document.body.style.cursor = 'ns-resize';
            document.body.style.userSelect = 'none';
            e.preventDefault();
        });

        signalResizeHandle.addEventListener('mousedown', (e) => {
            isResizing = true;
            resizingPanel = 'signal';
            startY = e.clientY;
            startHeight = signalPanel.offsetHeight;
            signalResizeHandle.classList.add('dragging');
            document.body.style.cursor = 'ns-resize';
            document.body.style.userSelect = 'none';
            e.preventDefault();
        });

        latencyResizeHandle.addEventListener('mousedown', (e) => {
            isResizing = true;
            resizingPanel = 'latency';
            startY = e.clientY;
            startHeight = latencyPanel.offsetHeight;
            latencyResizeHandle.classList.add('dragging');
            document.body.style.cursor = 'ns-resize';
            document.body.style.userSelect = 'none';
            e.preventDefault();
        });

        heartrateResizeHandle.addEventListener('mousedown', (e) => {
            isResizing = true;
            resizingPanel = 'heartrate';
            startY = e.clientY;
            startHeight = heartratePanel.offsetHeight;
            heartrateResizeHandle.classList.add('dragging');
            document.body.style.cursor = 'ns-resize';
            document.body.style.userSelect = 'none';
            e.preventDefault();
        });

        accuracyResizeHandle.addEventListener('mousedown', (e) => {
            isResizing = true;
            resizingPanel = 'accuracy';
            startY = e.clientY;
            startHeight = accuracyPanel.offsetHeight;
            accuracyResizeHandle.classList.add('dragging');
            document.body.style.cursor = 'ns-resize';
            document.body.style.userSelect = 'none';
            e.preventDefault();
        });

        distanceResizeHandle.addEventListener('mousedown', (e) => {
            isResizing = true;
            resizingPanel = 'distance';
            startY = e.clientY;
            startHeight = distancePanel.offsetHeight;
            distanceResizeHandle.classList.add('dragging');
            document.body.style.cursor = 'ns-resize';
            document.body.style.userSelect = 'none';
            e.preventDefault();
        });

        document.addEventListener('mousemove', (e) => {
            if (!isResizing) return;

            const deltaY = startY - e.clientY;
            const newHeight = Math.max(80, Math.min(400, startHeight + deltaY));

            if (resizingPanel === 'speed') {
                speedPanel.style.height = newHeight + 'px';
                speedGraphHeight = newHeight;
            } else if (resizingPanel === 'battery') {
                batteryPanel.style.height = newHeight + 'px';
                batteryGraphHeight = newHeight;
            } else if (resizingPanel === 'signal') {
                signalPanel.style.height = newHeight + 'px';
                signalGraphHeight = newHeight;
            } else if (resizingPanel === 'latency') {
                latencyPanel.style.height = newHeight + 'px';
                latencyGraphHeight = newHeight;
            } else if (resizingPanel === 'heartrate') {
                heartratePanel.style.height = newHeight + 'px';
                heartrateGraphHeight = newHeight;
            } else if (resizingPanel === 'accuracy') {
                accuracyPanel.style.height = newHeight + 'px';
                accuracyGraphHeight = newHeight;
            } else if (resizingPanel === 'distance') {
                distancePanel.style.height = newHeight + 'px';
                distanceGraphHeight = newHeight;
            }

            updateGraphPositions();

            // Redraw graphs at new size
            drawSpeedGraph();
            drawSpeedGraph();
            drawBatteryGraph();
            drawSignalGraph();
            drawLatencyGraph();
            drawHeartRateGraph();
            drawAccuracyGraph();
            drawDistanceGraph();
        });

        document.addEventListener('mouseup', () => {
            if (isResizing) {
                isResizing = false;
                speedResizeHandle.classList.remove('dragging');
                batteryResizeHandle.classList.remove('dragging');
                signalResizeHandle.classList.remove('dragging');
                latencyResizeHandle.classList.remove('dragging');
                heartrateResizeHandle.classList.remove('dragging');
                accuracyResizeHandle.classList.remove('dragging');
                distanceResizeHandle.classList.remove('dragging');
                document.body.style.cursor = '';
                document.body.style.userSelect = '';
                localStorage.setItem('speedGraphHeight', speedGraphHeight);
                localStorage.setItem('batteryGraphHeight', batteryGraphHeight);
                localStorage.setItem('signalGraphHeight', signalGraphHeight);
                localStorage.setItem('latencyGraphHeight', latencyGraphHeight);
                localStorage.setItem('heartrateGraphHeight', heartrateGraphHeight);
                localStorage.setItem('accuracyGraphHeight', accuracyGraphHeight);
                localStorage.setItem('distanceGraphHeight', distanceGraphHeight);
                resizingPanel = null;
            }
        });

        function zoomToUser(userId) {
            if (!userData[userId]) return;

            const entries = userData[userId];
            if (entries.length === 0) return;

            // Select only this user
            selectedUsers.clear();
            document.querySelectorAll('.user-item').forEach(el => el.classList.remove('selected'));

            selectedUsers.add(userId);
            const element = document.querySelector(`.user-item[data-user-id="${userId}"]`);
            if (element) element.classList.add('selected');

            // Reset playback to show all of this user's data
            resetPlaybackToSelection();

            // Zoom to all of user's points
            const coords = entries.map(e => [e.lat, e.lon]);
            map.fitBounds(coords, { padding: [50, 50] });
        }

        function getSelectedTimeRange() {
            // Get time range for selected users only
            let selMinTime = Infinity;
            let selMaxTime = -Infinity;

            for (const userId of selectedUsers) {
                if (userData[userId] && userData[userId].length > 0) {
                    const entries = userData[userId];
                    selMinTime = Math.min(selMinTime, entries[0].ts);
                    selMaxTime = Math.max(selMaxTime, entries[entries.length - 1].ts);
                }
            }

            // Fall back to global range if no users selected
            if (selMinTime === Infinity) {
                return { min: minTime, max: maxTime };
            }

            return { min: selMinTime, max: selMaxTime };
        }

        function timeToSliderValue(timestamp) {
            // Convert timestamp to slider value (0-100) based on current slider range
            if (sliderMaxTime === sliderMinTime) return 100;
            return ((timestamp - sliderMinTime) / (sliderMaxTime - sliderMinTime)) * 100;
        }

        function sliderValueToTime(value) {
            // Convert slider value (0-100) to timestamp based on current slider range
            return sliderMinTime + (sliderMaxTime - sliderMinTime) * (value / 100);
        }

        function timeToGlobalPercent(timestamp) {
            // Convert timestamp to percentage of global log range (for URLs)
            if (maxTime === minTime) return 100;
            return ((timestamp - minTime) / (maxTime - minTime)) * 100;
        }

        function globalPercentToTime(percent) {
            // Convert percentage of global log range to timestamp (for URLs)
            return minTime + (maxTime - minTime) * (percent / 100);
        }

        function updateSliderEndpoints() {
            // Update slider endpoints based on selected users' data range
            const range = getSelectedTimeRange();
            sliderMinTime = range.min;
            sliderMaxTime = range.max;

            // Update edge labels
            document.getElementById('label-start').textContent = formatTimeInTz(sliderMinTime);
            document.getElementById('label-end').textContent = formatTimeInTz(sliderMaxTime);

            // Convert current time selection to new slider percentages
            const startSlider = document.getElementById('start-slider');
            const endSlider = document.getElementById('end-slider');

            // Clamp rangeStartTime/rangeEndTime to new slider range
            let clampedStart = Math.max(sliderMinTime, Math.min(sliderMaxTime, rangeStartTime));
            let clampedEnd = Math.max(sliderMinTime, Math.min(sliderMaxTime, rangeEndTime));

            // Check if any selected user has visible data in the clamped range
            let hasVisibleData = false;
            if (clampedEnd > clampedStart) {
                for (const userId of selectedUsers) {
                    if (userData[userId]) {
                        const visiblePoints = userData[userId].filter(
                            e => e.ts >= clampedStart && e.ts <= clampedEnd
                        );
                        if (visiblePoints.length >= 2) {
                            hasVisibleData = true;
                            break;
                        }
                    }
                }
            }

            // If no visible data, reset to full range of selected users
            if (selectedUsers.size > 0 && !hasVisibleData) {
                clampedStart = sliderMinTime;
                clampedEnd = sliderMaxTime;
            }

            // Update rangeStartTime/rangeEndTime if they were clamped
            rangeStartTime = clampedStart;
            rangeEndTime = clampedEnd;

            // Update slider positions
            startSlider.value = timeToSliderValue(clampedStart);
            endSlider.value = timeToSliderValue(clampedEnd);

            // Update visual range indicator
            updateSliderRange();
        }

        // Options dropdown toggle
        document.getElementById('options-btn').addEventListener('click', (e) => {
            e.stopPropagation();
            document.getElementById('options-dropdown-content').classList.toggle('show');
            document.getElementById('graphs-dropdown-content').classList.remove('show');
            document.getElementById('export-dropdown-content').classList.remove('show');
        });

        // Graphs dropdown toggle
        document.getElementById('graphs-btn').addEventListener('click', (e) => {
            e.stopPropagation();
            document.getElementById('graphs-dropdown-content').classList.toggle('show');
            document.getElementById('options-dropdown-content').classList.remove('show');
            document.getElementById('export-dropdown-content').classList.remove('show');
        });

        // Export dropdown toggle
        document.getElementById('export-btn').addEventListener('click', (e) => {
            e.stopPropagation();
            document.getElementById('export-dropdown-content').classList.toggle('show');
            document.getElementById('options-dropdown-content').classList.remove('show');
            document.getElementById('graphs-dropdown-content').classList.remove('show');
        });

        // Close dropdowns when clicking outside
        document.addEventListener('click', (e) => {
            const graphsDropdown = document.getElementById('graphs-dropdown-content');
            const graphsBtn = document.getElementById('graphs-btn');
            const optionsDropdown = document.getElementById('options-dropdown-content');
            const optionsBtn = document.getElementById('options-btn');
            const exportDropdown = document.getElementById('export-dropdown-content');
            const exportBtn = document.getElementById('export-btn');

            if (!graphsDropdown.contains(e.target) && e.target !== graphsBtn) {
                graphsDropdown.classList.remove('show');
            }
            if (!optionsDropdown.contains(e.target) && e.target !== optionsBtn) {
                optionsDropdown.classList.remove('show');
            }
            if (!exportDropdown.contains(e.target) && e.target !== exportBtn) {
                exportDropdown.classList.remove('show');
            }
        });

        // About modal
        document.getElementById('about-btn').addEventListener('click', () => {
            document.getElementById('about-modal').classList.add('show');
        });

        document.getElementById('about-close-btn').addEventListener('click', () => {
            document.getElementById('about-modal').classList.remove('show');
        });

        // Reload tiles button - forces refresh of map tiles
        document.getElementById('reload-tiles-btn').addEventListener('click', () => {
            // Remove and re-add the current tile layer to force reload
            if (currentMapType === 'osm') {
                map.removeLayer(osmLayer);
                map.addLayer(osmLayer);
            } else if (googleLayers[currentMapType]) {
                map.removeLayer(googleLayers[currentMapType]);
                map.addLayer(googleLayers[currentMapType]);
            }
        });

        document.getElementById('about-modal').addEventListener('click', (e) => {
            if (e.target.id === 'about-modal') {
                document.getElementById('about-modal').classList.remove('show');
            }
        });

        document.getElementById('start-slider').addEventListener('input', (e) => {
            const startVal = parseFloat(e.target.value);
            const endVal = parseFloat(document.getElementById('end-slider').value);
            // Don't let start go past end
            if (startVal > endVal) {
                e.target.value = endVal;
            }
            // Update visual indicators immediately (cheap)
            updateSliderRange();
            updateTimeDisplay();
            // Reset playback when slider moves
            resetPlaybackPosition();
            // Debounce expensive redraws until slider stops moving
            debouncedRedrawAll();
        });

        document.getElementById('end-slider').addEventListener('input', (e) => {
            const endVal = parseFloat(e.target.value);
            const startVal = parseFloat(document.getElementById('start-slider').value);
            // Don't let end go before start
            if (endVal < startVal) {
                e.target.value = startVal;
            }
            // Update visual indicators immediately (cheap)
            updateSliderRange();
            updateTimeDisplay();
            // Reset playback when slider moves
            resetPlaybackPosition();
            // Debounce expensive redraws until slider stops moving
            debouncedRedrawAll();
        });

        document.getElementById('speed-color').addEventListener('change', () => {
            drawTracks();
        });

        document.getElementById('show-markers').addEventListener('change', () => {
            drawTracks();
        });

        document.getElementById('filter-outliers').addEventListener('change', () => {
            drawTracks();
        });

        document.getElementById('show-outliers').addEventListener('change', () => {
            drawTracks();
        });

        document.getElementById('show-course').addEventListener('change', (e) => {
            showCourse = e.target.checked;
            if (showCourse && currentCourseFile) {
                // Re-load and display course
                const courseFilename = currentCourseFile;
                currentCourseFile = null;  // Reset to force reload
                loadCourse(courseFilename);
            } else {
                clearCourseDisplay();
            }
        });

        document.getElementById('show-speed-graph').addEventListener('change', (e) => {
            updateGraphPositions();
            if (e.target.checked) {
                drawSpeedGraph();
            }
        });

        document.getElementById('show-battery-graph').addEventListener('change', (e) => {
            updateGraphPositions();
            if (e.target.checked) {
                drawBatteryGraph();
            }
        });

        document.getElementById('show-signal-graph').addEventListener('change', (e) => {
            updateGraphPositions();
            if (e.target.checked) {
                drawSignalGraph();
            }
        });

        document.getElementById('show-latency-graph').addEventListener('change', (e) => {
            updateGraphPositions();
            if (e.target.checked) {
                drawLatencyGraph();
            }
        });

        document.getElementById('show-heartrate-graph').addEventListener('change', (e) => {
            updateGraphPositions();
            if (e.target.checked) {
                drawHeartRateGraph();
            }
        });

        document.getElementById('show-accuracy-graph').addEventListener('change', (e) => {
            updateGraphPositions();
            if (e.target.checked) {
                drawAccuracyGraph();
            }
        });

        document.getElementById('show-distance-graph').addEventListener('change', (e) => {
            updateGraphPositions();
            if (e.target.checked) {
                drawDistanceGraph();
            }
        });

        document.getElementById('reset-range-btn').addEventListener('click', () => {
            document.getElementById('start-slider').value = 0;
            document.getElementById('end-slider').value = 100;
            updateSliderRange();
            updateTimeDisplay();
            resetPlaybackPosition();
            drawTracks();
            drawSpeedGraph();
            drawBatteryGraph();
            drawSignalGraph();
            drawLatencyGraph();
            drawHeartRateGraph();
            drawAccuracyGraph();
            drawDistanceGraph();
        });

        // Copy shareable link to clipboard
        document.getElementById('copy-link-btn').addEventListener('click', async () => {
            const url = buildShareableUrl();
            try {
                await navigator.clipboard.writeText(url);
                const btn = document.getElementById('copy-link-btn');
                const originalText = btn.textContent;
                btn.textContent = '‚úì Copied!';
                btn.style.background = '#27ae60';
                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.style.background = '#9b59b6';
                }, 2000);
            } catch (err) {
                // Fallback for browsers without clipboard API
                prompt('Copy this link:', url);
            }
        });

        // Playback controls - animate through the selected range
        let playbackCurrentTime = 0;
        let playbackPaused = false;  // true if paused (vs stopped/finished)
        let indicatorDragging = false;  // true while dragging the playback indicator

        function updatePlaybackIndicator() {
            const indicator = document.getElementById('playback-indicator');
            if (playbackCurrentTime <= rangeStartTime || playbackCurrentTime >= rangeEndTime) {
                indicator.style.display = 'none';
                return;
            }
            // Calculate position as percentage of slider range
            const pct = ((playbackCurrentTime - sliderMinTime) / (sliderMaxTime - sliderMinTime)) * 100;
            // Account for thumb width like the slider-range positioning
            indicator.style.left = `calc(10px + ${pct}% - ${pct * 0.2}px)`;
            indicator.style.display = 'block';
        }

        function resetPlaybackPosition() {
            playbackCurrentTime = rangeStartTime;
            playbackPaused = false;
            const indicator = document.getElementById('playback-indicator');
            indicator.style.display = 'none';
            indicator.classList.remove('draggable', 'dragging');
            if (playbackInterval) {
                clearInterval(playbackInterval);
                playbackInterval = null;
                document.getElementById('play-btn').textContent = '‚ñ∂ Play';
            }
        }

        document.getElementById('play-btn').addEventListener('click', function() {
            const indicator = document.getElementById('playback-indicator');
            if (playbackInterval) {
                // Currently playing - pause
                clearInterval(playbackInterval);
                playbackInterval = null;
                playbackPaused = true;
                indicator.classList.add('draggable');  // Enable dragging when paused
                this.textContent = '‚ñ∂ Play';
                // Keep showing current position, don't reset
            } else {
                if (selectedUsers.size === 0) {
                    alert('Select at least one user to play back');
                    return;
                }

                this.textContent = '‚è∏ Pause';

                // Resume from paused position, or start from beginning
                if (!playbackPaused || playbackCurrentTime >= rangeEndTime || playbackCurrentTime < rangeStartTime) {
                    playbackCurrentTime = rangeStartTime;
                }
                playbackPaused = false;
                indicator.classList.remove('draggable', 'dragging');  // Disable dragging when playing

                // Draw initial state
                drawTracksUpTo(playbackCurrentTime);
                updatePlaybackIndicator();

                playbackInterval = setInterval(() => {
                    // Advance time (playbackSpeed seconds per 100ms tick)
                    playbackCurrentTime += playbackSpeed;

                    if (playbackCurrentTime >= rangeEndTime) {
                        playbackCurrentTime = rangeEndTime;
                        clearInterval(playbackInterval);
                        playbackInterval = null;
                        playbackPaused = false;
                        document.getElementById('play-btn').textContent = '‚ñ∂ Play';
                        // Show full tracks when finished
                        drawTracks();
                        indicator.style.display = 'none';
                        indicator.classList.remove('draggable');
                        return;
                    }

                    // Draw tracks up to current playback time
                    drawTracksUpTo(playbackCurrentTime);
                    updatePlaybackIndicator();
                }, 100);
            }
        });

        // Playback indicator drag handling - allows scrubbing when paused
        (function setupIndicatorDrag() {
            const indicator = document.getElementById('playback-indicator');
            const container = document.querySelector('.time-slider-container');

            indicator.addEventListener('mousedown', (e) => {
                if (!playbackPaused) return;
                indicatorDragging = true;
                indicator.classList.add('dragging');
                e.preventDefault();
            });

            document.addEventListener('mousemove', (e) => {
                if (!indicatorDragging) return;

                const rect = container.getBoundingClientRect();
                const x = e.clientX - rect.left;
                // Account for thumb width adjustment (same formula as updateSliderRange)
                const pct = Math.max(0, Math.min(100, ((x - 10) / (rect.width - 20)) * 100));
                const time = sliderMinTime + (sliderMaxTime - sliderMinTime) * (pct / 100);

                // Clamp to selected range
                playbackCurrentTime = Math.max(rangeStartTime, Math.min(rangeEndTime, time));

                // Update display
                updatePlaybackIndicator();
                drawTracksUpTo(playbackCurrentTime);
            });

            document.addEventListener('mouseup', () => {
                if (indicatorDragging) {
                    indicatorDragging = false;
                    indicator.classList.remove('dragging');
                }
            });
        })();

        // Draw tracks up to a specific time (for playback animation)
        const PLAYBACK_TAIL_SECONDS = 30;  // Show last 30 seconds of track by default

        function drawTracksUpTo(upToTime) {
            // Clear existing layers
            for (const layer of Object.values(trackLayers)) {
                map.removeLayer(layer);
            }
            for (const layer of Object.values(markerLayers)) {
                map.removeLayer(layer);
            }
            for (const layer of Object.values(pointLayers)) {
                map.removeLayer(layer);
            }
            for (const layer of Object.values(outlierLayers)) {
                map.removeLayer(layer);
            }
            trackLayers = {};
            markerLayers = {};
            pointLayers = {};
            outlierLayers = {};

            const useSpeedColor = document.getElementById('speed-color').checked;
            const showMarkers = document.getElementById('show-markers').checked;
            const doFilterOutliers = document.getElementById('filter-outliers').checked;
            const showFullTrack = document.getElementById('playback-full-track').checked;

            // Calculate start time for track display
            // If "Full track" is unchecked, only show the last PLAYBACK_TAIL_SECONDS
            const trackStartTime = showFullTrack ? rangeStartTime : Math.max(rangeStartTime, upToTime - PLAYBACK_TAIL_SECONDS);

            let colorIdx = 0;
            for (const [userId, entries] of Object.entries(userData)) {
                if (!selectedUsers.has(userId)) {
                    colorIdx++;
                    continue;
                }

                const userColor = userColors[colorIdx % userColors.length];
                colorIdx++;

                // Filter: start from trackStartTime (or rangeStartTime if full track), end at upToTime
                let timeFiltered = entries.filter(e => e.ts >= trackStartTime && e.ts <= upToTime);
                if (timeFiltered.length < 2) continue;

                // Apply outlier filtering if enabled
                let filtered = timeFiltered;
                if (doFilterOutliers) {
                    const result = filterOutliers(timeFiltered);
                    filtered = result.filtered;
                    // Fall back to unfiltered data if outlier filtering removed too many points
                    if (filtered.length < 2 && timeFiltered.length >= 2) {
                        filtered = timeFiltered;
                    }
                }

                if (filtered.length < 2) continue;

                if (useSpeedColor) {
                    const layerGroup = L.layerGroup();
                    for (let i = 1; i < filtered.length; i++) {
                        const prev = filtered[i-1];
                        const curr = filtered[i];
                        const color = speedToColor(curr.spd || 0);
                        const line = L.polyline(
                            [[prev.lat, prev.lon], [curr.lat, curr.lon]],
                            { color: color, weight: 3, opacity: 0.8 }
                        );
                        layerGroup.addLayer(line);
                    }
                    layerGroup.addTo(map);
                    trackLayers[userId] = layerGroup;
                } else {
                    const coords = filtered.map(e => [e.lat, e.lon]);
                    const polyline = L.polyline(coords, {
                        color: userColor,
                        weight: 3,
                        opacity: 0.8
                    }).addTo(map);
                    trackLayers[userId] = polyline;
                }

                // Add current position marker
                if (showMarkers && filtered.length > 0) {
                    const last = filtered[filtered.length - 1];
                    const marker = L.circleMarker([last.lat, last.lon], {
                        radius: 8,
                        fillColor: userColor,
                        color: '#fff',
                        weight: 2,
                        fillOpacity: 1
                    }).addTo(map);
                    markerLayers[userId] = marker;
                }
            }

            // Update time display during playback
            document.getElementById('time-display').innerHTML =
                `<span style="color:#2ecc71">Start: ${formatTimeInTz(rangeStartTime)}</span> &nbsp;|&nbsp;` +
                `<span style="color:#f39c12">Playing: ${formatTimeInTz(upToTime)}</span> &nbsp;|&nbsp;` +
                `<span style="color:#e74c3c">End: ${formatTimeInTz(rangeEndTime)}</span>`;
        }

        document.getElementById('speed-1x').addEventListener('click', () => playbackSpeed = 1);
        document.getElementById('speed-5x').addEventListener('click', () => playbackSpeed = 5);
        document.getElementById('speed-20x').addEventListener('click', () => playbackSpeed = 20);

        document.getElementById('show-all-btn').addEventListener('click', () => {
            selectedUsers = new Set(Object.keys(userData));
            document.querySelectorAll('.user-item').forEach(el => el.classList.add('selected'));
            resetPlaybackToSelection();
            fitMapToData();
        });

        document.getElementById('hide-all-btn').addEventListener('click', () => {
            selectedUsers.clear();
            document.querySelectorAll('.user-item').forEach(el => el.classList.remove('selected'));
            resetPlaybackToSelection();
        });

        // ===== Export Functions =====
        // Uses: generateGPX, generateCSV, generateGeoJSON, generateFIT, downloadFile from export.js

        function getExportFilename(extension) {
            const date = document.getElementById('date-picker').value || 'tracks';
            const users = Array.from(selectedUsers).slice(0, 3).join('-') || 'all';
            const suffix = selectedUsers.size > 3 ? `-and${selectedUsers.size - 3}more` : '';
            return `${date}_${users}${suffix}.${extension}`;
        }

        function getFilteredExportData() {
            // Get data for selected users within current time range
            const exportData = [];
            for (const userId of selectedUsers) {
                if (!userData[userId]) continue;
                const filtered = userData[userId].filter(
                    e => e.ts >= rangeStartTime && e.ts <= rangeEndTime
                );
                if (filtered.length > 0) {
                    exportData.push({ userId, name: getDisplayName(userId), entries: filtered });
                }
            }
            return exportData;
        }

        function exportToGPX() {
            const data = getFilteredExportData();
            if (data.length === 0) {
                alert('No data to export. Please select at least one user.');
                return;
            }
            const gpx = generateGPX(data);
            downloadFile(gpx, getExportFilename('gpx'), 'application/gpx+xml');
            document.getElementById('export-dropdown-content').classList.remove('show');
        }

        function exportToCSV() {
            const data = getFilteredExportData();
            if (data.length === 0) {
                alert('No data to export. Please select at least one user.');
                return;
            }
            const csv = generateCSV(data);
            downloadFile(csv, getExportFilename('csv'), 'text/csv');
            document.getElementById('export-dropdown-content').classList.remove('show');
        }

        function exportToGeoJSON() {
            const data = getFilteredExportData();
            if (data.length === 0) {
                alert('No data to export. Please select at least one user.');
                return;
            }
            const geojson = generateGeoJSON(data);
            downloadFile(JSON.stringify(geojson, null, 2), getExportFilename('geojson'), 'application/geo+json');
            document.getElementById('export-dropdown-content').classList.remove('show');
        }

        function exportToFIT() {
            const data = getFilteredExportData();
            if (data.length === 0) {
                alert('No data to export. Please select at least one user.');
                return;
            }
            // FIT files are per-user, export first selected
            if (data.length > 1) {
                alert('FIT format exports one user at a time. Exporting: ' + data[0].name);
            }
            const { name, entries } = data[0];
            if (entries.length === 0) return;

            const fitData = generateFIT(entries);
            const filename = getExportFilename('fit').replace(/[^-_.]+/, name.replace(/\s+/g, '_'));
            downloadFile(fitData, filename, 'application/octet-stream');
            document.getElementById('export-dropdown-content').classList.remove('show');
        }

        // Export button handlers
        document.getElementById('export-fit').addEventListener('click', exportToFIT);
        document.getElementById('export-gpx').addEventListener('click', exportToGPX);
        document.getElementById('export-csv').addEventListener('click', exportToCSV);
        document.getElementById('export-geojson').addEventListener('click', exportToGeoJSON);

        // Update live tracking link to include event ID
        const liveLink = document.getElementById('live-link');
        if (liveLink) {
            liveLink.href = `event.html?eid=${EVENT_ID}`;
        }

        // Restore state from URL (map position, options, graphs)
        restoreStateFromUrl();

        // Load summary (will auto-select log if URL has log param)
        loadSummary();
    </script>
</body>
</html>
