<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Windsurfer Tracker</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet.gridlayer.googlemutant@0.14.1/dist/Leaflet.GoogleMutant.js"></script>
    <script>
        // Try to load config.js for Google Maps API key
        var GMAPS_API_KEY = null;
    </script>
    <script src="config.js" onerror=""></script>
    <script>
        // Load Google Maps API if key is available
        if (GMAPS_API_KEY && GMAPS_API_KEY !== 'YOUR_API_KEY_HERE') {
            var script = document.createElement('script');
            script.src = 'https://maps.googleapis.com/maps/api/js?key=' + GMAPS_API_KEY;
            script.async = true;
            document.head.appendChild(script);
        }
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        
        #map {
            width: 100%;
            height: 100vh;
        }
        
        .info-panel {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 9999;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            max-width: 320px;
            max-height: 70vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        
        .panel-header {
            padding: 10px 12px;
            background: #f5f5f5;
            border-bottom: 1px solid #ddd;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
        }
        
        .panel-header h3 {
            margin: 0;
            font-size: 14px;
            color: #333;
        }
        
        .panel-toggle {
            font-size: 12px;
            color: #666;
        }
        
        .panel-content {
            overflow-y: auto;
            flex-grow: 1;
        }
        
        .panel-content.collapsed {
            display: none;
        }
        
        .assist-alerts {
            background: #fee;
            border-bottom: 1px solid #fcc;
            padding: 8px 12px;
        }
        
        .assist-alert-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 4px 0;
            cursor: pointer;
            font-weight: bold;
            color: #c00;
            animation: pulse-text 1s infinite;
        }
        
        @keyframes pulse-text {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }
        
        .category-section {
            border-bottom: 1px solid #eee;
        }
        
        .category-header {
            padding: 8px 12px;
            background: #fafafa;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 12px;
            font-weight: bold;
            color: #666;
        }
        
        .category-header:hover {
            background: #f0f0f0;
        }
        
        .category-content {
            padding: 0 12px;
        }
        
        .category-content.collapsed {
            display: none;
        }
        
        .sailor-list {
            font-size: 12px;
        }
        
        .sailor-item {
            padding: 6px 0;
            border-bottom: 1px solid #eee;
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            border-radius: 4px;
            margin: 2px -4px;
            padding-left: 4px;
            padding-right: 4px;
        }
        
        .sailor-item:hover {
            background: #f0f0f0;
        }
        
        .sailor-item:last-child {
            border-bottom: none;
        }
        
        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            flex-shrink: 0;
        }
        
        .status-green { background: #22c55e; }
        .status-orange { background: #f97316; }
        .status-red { 
            background: #ef4444; 
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.3); }
        }
        
        .sailor-info {
            flex-grow: 1;
        }
        
        .sailor-id {
            font-weight: bold;
        }
        
        .sailor-details {
            color: #666;
            font-size: 11px;
        }
        
        .assist-badge {
            background: #ef4444;
            color: white;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: bold;
            animation: pulse 1s infinite;
        }
        
        .last-update {
            font-size: 11px;
            color: #999;
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid #eee;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            margin: 4px 0;
        }
        
        .popup-checkbox {
            margin: 8px 0;
            padding: 8px 0;
            border-top: 1px solid #eee;
        }
        
        .popup-checkbox label {
            display: flex;
            align-items: center;
            gap: 6px;
            cursor: pointer;
            font-size: 13px;
        }
        
        .popup-checkbox input[type="checkbox"] {
            width: 16px;
            height: 16px;
        }
        
        .track-loading {
            font-size: 11px;
            color: #666;
            font-style: italic;
        }
        
        .connection-status {
            position: fixed;
            top: 10px;
            left: 50px;
            z-index: 9999;
            background: white;
            padding: 8px 12px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            font-size: 12px;
        }
        
        .connection-ok { border-left: 4px solid #22c55e; }
        .connection-error { border-left: 4px solid #ef4444; }
        
        /* Scale control styling */
        .custom-scale {
            position: fixed;
            bottom: 15px;
            left: 10px;
            z-index: 9999;
            background: white;
            padding: 6px 12px;
            border-radius: 6px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            font-size: 14px;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 10px;
            max-width: calc(100vw - 20px);
        }
        
        .scale-bar {
            height: 10px;
            background: repeating-linear-gradient(
                90deg,
                #333 0px,
                #333 25%,
                #fff 25%,
                #fff 50%
            );
            border: 2px solid #333;
            min-width: 80px;
            max-width: 200px;
        }
        
        .scale-text {
            white-space: nowrap;
        }
        
        /* Legend above scale */
        .legend {
            position: fixed;
            bottom: 60px;
            left: 10px;
            z-index: 9999;
            background: white;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            font-size: 12px;
        }
        
        /* Hamburger menu button and panel */
        .menu-btn {
            position: fixed;
            bottom: 15px;
            right: 15px;
            z-index: 9999;
            background: #444;
            color: white;
            border: none;
            width: 44px;
            height: 44px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 22px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .menu-btn:hover {
            background: #555;
        }

        .menu-panel {
            position: fixed;
            bottom: 70px;
            right: 15px;
            z-index: 10001;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            min-width: 200px;
            display: none;
            overflow: hidden;
        }

        .menu-panel.visible {
            display: block;
        }

        .menu-item {
            padding: 12px 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 14px;
            border-bottom: 1px solid #eee;
        }

        .menu-item:last-child {
            border-bottom: none;
        }

        .menu-item:hover {
            background: #f5f5f5;
        }

        .menu-item.active {
            background: #e8f5e9;
            color: #2e7d32;
        }

        .menu-item a {
            color: inherit;
            text-decoration: none;
            display: flex;
            align-items: center;
            gap: 10px;
            width: 100%;
        }

        .menu-submenu {
            display: none;
            background: #f9f9f9;
            border-top: 1px solid #eee;
        }

        .menu-submenu.visible {
            display: block;
        }

        .menu-submenu-item {
            padding: 10px 16px 10px 42px;
            cursor: pointer;
            font-size: 13px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .menu-submenu-item:hover {
            background: #f0f0f0;
        }

        .menu-submenu-item.selected {
            background: #e3f2fd;
            color: #1976d2;
        }

        .menu-submenu-item.selected::before {
            content: '‚úì';
            margin-right: 4px;
        }

        /* Admin button (now inside admin panel) */
        .admin-btn {
            display: none;
        }

        .admin-btn.active {
            background: #dc2626;
        }

        /* Marker labels */
        .marker-label {
            position: absolute;
            left: 50%;
            top: 100%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.75);
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 11px;
            white-space: nowrap;
            pointer-events: none;
            margin-top: 2px;
        }
        
        .admin-panel {
            position: fixed;
            bottom: 60px;
            right: 15px;
            z-index: 9999;
            background: white;
            padding: 16px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            width: 280px;
            display: none;
        }
        
        .admin-panel.visible {
            display: block;
        }
        
        .admin-panel h3 {
            margin: 0 0 12px 0;
            padding-bottom: 8px;
            border-bottom: 1px solid #eee;
            font-size: 14px;
            color: #333;
        }
        
        .admin-section {
            margin-bottom: 16px;
        }
        
        .admin-section h4 {
            margin: 0 0 8px 0;
            font-size: 12px;
            color: #666;
            text-transform: uppercase;
        }
        
        .admin-btn-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .admin-action-btn {
            padding: 10px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            text-align: left;
        }
        
        .admin-action-btn.danger {
            background: #fee;
            color: #c00;
        }
        
        .admin-action-btn.danger:hover {
            background: #fcc;
        }
        
        .admin-action-btn.primary {
            background: #e0f0ff;
            color: #0066cc;
        }
        
        .admin-action-btn.primary:hover {
            background: #cce5ff;
        }
        
        .admin-action-btn.success {
            background: #e0ffe0;
            color: #060;
        }
        
        .admin-action-btn.success:hover {
            background: #ccffcc;
        }
        
        .admin-action-btn:disabled {
            background: #eee;
            color: #999;
            cursor: not-allowed;
        }

        .about-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 10000;
            justify-content: center;
            align-items: center;
        }

        .about-modal.show {
            display: flex;
        }

        .about-content {
            background: white;
            padding: 30px;
            border-radius: 8px;
            max-width: 400px;
            text-align: center;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }

        .about-content h2 {
            margin: 0 0 20px 0;
            color: #2c3e50;
        }

        .about-content p {
            margin: 15px 0;
            color: #555;
        }

        .about-content a {
            color: #3498db;
            text-decoration: none;
        }

        .about-content a:hover {
            text-decoration: underline;
        }

        .about-content button {
            margin-top: 20px;
            padding: 10px 30px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }

        .about-content button:hover {
            background: #2980b9;
        }

        .drawing-mode-indicator {
            position: fixed;
            top: 50px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 9999;
            background: #0066cc;
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 14px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            display: none;
        }
        
        .drawing-mode-indicator.visible {
            display: block;
        }
        
        .course-info {
            font-size: 12px;
            color: #666;
            margin-top: 8px;
            padding: 8px;
            background: #f5f5f5;
            border-radius: 4px;
        }

        /* User edit dialog */
        .edit-user-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            z-index: 10000;
            display: none;
            align-items: center;
            justify-content: center;
        }

        .edit-user-overlay.visible {
            display: flex;
        }

        .edit-user-dialog {
            background: white;
            border-radius: 12px;
            padding: 20px;
            width: 300px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }

        .edit-user-dialog h3 {
            margin: 0 0 16px 0;
            font-size: 16px;
        }

        .edit-user-dialog label {
            display: block;
            font-size: 12px;
            color: #666;
            margin-bottom: 4px;
        }

        .edit-user-dialog input,
        .edit-user-dialog select {
            width: 100%;
            padding: 8px 10px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            margin-bottom: 12px;
        }

        .edit-user-dialog .btn-row {
            display: flex;
            gap: 8px;
            margin-top: 16px;
        }

        .edit-user-dialog button {
            flex: 1;
            padding: 10px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
        }

        .edit-user-dialog .btn-cancel {
            background: #eee;
            color: #333;
        }

        .edit-user-dialog .btn-save {
            background: #0066cc;
            color: white;
        }

        .edit-user-dialog .btn-remove {
            background: #fee;
            color: #c00;
            margin-top: 8px;
        }

        .popup-edit-btn {
            display: inline-block;
            margin-left: 8px;
            padding: 2px 8px;
            font-size: 11px;
            background: #0066cc;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        .popup-edit-btn:hover {
            background: #0055aa;
        }
    </style>
</head>
<body>
    <div id="map"></div>
    
    <div class="connection-status connection-ok" id="connectionStatus">
        Connected
    </div>
    
    <div class="info-panel">
        <div class="panel-header" onclick="togglePanel()">
            <h3 id="panelTitle">Tracking (0)</h3>
            <span class="panel-toggle" id="panelToggle">‚ñº</span>
        </div>
        <div class="assist-alerts" id="assistAlerts" style="display:none"></div>
        <div class="panel-content" id="panelContent">
            <div class="category-section" id="sailorSection">
                <div class="category-header" onclick="toggleCategory('sailor')">
                    <span>‚õµ Sailors (<span id="sailorCount">0</span>)</span>
                    <span id="sailorToggle">‚ñº</span>
                </div>
                <div class="category-content" id="sailorList"></div>
            </div>
            <div class="category-section" id="supportSection">
                <div class="category-header" onclick="toggleCategory('support')">
                    <span>üö§ Support (<span id="supportCount">0</span>)</span>
                    <span id="supportToggle">‚ñº</span>
                </div>
                <div class="category-content" id="supportList"></div>
            </div>
            <div class="category-section" id="spectatorSection">
                <div class="category-header" onclick="toggleCategory('spectator')">
                    <span>üî≠ Spectators (<span id="spectatorCount">0</span>)</span>
                    <span id="spectatorToggle">‚ñº</span>
                </div>
                <div class="category-content" id="spectatorList"></div>
            </div>
            <div class="last-update" id="lastUpdate" style="padding:8px 12px;"></div>
        </div>
    </div>
    
    <div class="legend">
        <div class="legend-item">
            <div class="status-dot status-green"></div>
            <span>Updated &lt; 2 min (solid)</span>
        </div>
        <div class="legend-item">
            <div class="status-dot status-orange"></div>
            <span>Updated &gt; 2 min (faded)</span>
        </div>
        <div class="legend-item">
            <div class="status-dot status-red"></div>
            <span>Assistance requested</span>
        </div>
        <div class="legend-item" style="margin-top:8px;font-size:11px;color:#666;">
            <span>Click sailor to center map</span>
        </div>
        <div class="legend-item" style="margin-top:8px;border-top:1px solid #eee;padding-top:8px;">
            <span id="courseLengthDisplay">Course: No course</span>
        </div>
    </div>
    
    <div class="custom-scale" id="customScale">
        <div class="scale-bar" id="scaleBar"></div>
        <span class="scale-text" id="scaleText">100m</span>
    </div>
    
    <!-- Hamburger menu -->
    <button class="menu-btn" id="menuBtn" onclick="toggleMenu()">‚ò∞</button>

    <div class="menu-panel" id="menuPanel">
        <div class="menu-item" id="menuLabels" onclick="toggleLabels()">
            <span>üè∑</span>
            <span>Show Labels</span>
        </div>
        <div class="menu-item" id="menuMapType" onclick="toggleMapSubmenu()" style="display:none">
            <span>üó∫Ô∏è</span>
            <span>Map Type ‚ñº</span>
        </div>
        <div class="menu-submenu" id="mapSubmenu">
            <div class="menu-submenu-item selected" data-maptype="osm" onclick="setMapType('osm')">OpenStreetMap</div>
            <div class="menu-submenu-item" data-maptype="roads" onclick="setMapType('roads')">Google Roads</div>
            <div class="menu-submenu-item" data-maptype="satellite" onclick="setMapType('satellite')">Google Satellite</div>
            <div class="menu-submenu-item" data-maptype="hybrid" onclick="setMapType('hybrid')">Google Hybrid</div>
        </div>
        <div class="menu-item">
            <a href="review.html">
                <span>üìä</span>
                <span>Track Review</span>
            </a>
        </div>
        <div class="menu-item" id="menuAdmin" onclick="toggleAdminMode()">
            <span>‚öôÔ∏è</span>
            <span>Admin</span>
        </div>
        <div class="menu-item" onclick="showAbout()">
            <span>‚ÑπÔ∏è</span>
            <span>About</span>
        </div>
    </div>

    <!-- About modal -->
    <div id="about-modal" class="about-modal">
        <div class="about-content">
            <h2>Windsurfer Tracker</h2>
            <p>GPS tracking system for windsurfing races</p>
            <p><a href="https://track.tridgell.net/install" target="_blank">Install App (Android/iPhone)</a></p>
            <p><a href="https://github.com/tridge/windsurfer-tracker" target="_blank">Source Code on GitHub</a></p>
            <button onclick="hideAbout()">Close</button>
        </div>
    </div>

    <!-- Admin panel (hidden until admin mode enabled) -->
    <button class="admin-btn" id="adminBtn" style="display:none">‚öô Admin</button>

    <div class="admin-panel" id="adminPanel">
        <h3>üîß Admin Controls</h3>

        <div class="admin-section">
            <h4>Visibility</h4>
            <div style="margin-bottom:8px;">
                <label style="display:flex;align-items:center;gap:8px;cursor:pointer;font-size:13px;">
                    <input type="checkbox" id="showHiddenToggle" onchange="toggleShowHidden()" style="width:16px;height:16px;">
                    <span>Show hidden trackers (<span id="hiddenCount">0</span>)</span>
                </label>
            </div>
            <div style="margin-bottom:8px;">
                <label style="display:flex;align-items:center;gap:8px;cursor:pointer;font-size:13px;">
                    <input type="checkbox" id="showOutliersToggle" onchange="toggleShowOutliers()" style="width:16px;height:16px;">
                    <span>Show track outliers (red)</span>
                </label>
            </div>
        </div>

        <div class="admin-section">
            <h4>Track Data</h4>
            <div class="admin-btn-group">
                <button class="admin-action-btn danger" onclick="clearTracks()">
                    üóë Clear Today's Tracks
                </button>
            </div>
        </div>
        
        <div class="admin-section">
            <h4>Course</h4>
            <div class="admin-btn-group">
                <button class="admin-action-btn primary" id="btnDrawCourse" onclick="startDrawingCourse()">
                    ‚úèÔ∏è Draw Course
                </button>
                <button class="admin-action-btn success" id="btnSaveCourse" onclick="saveCourse()" disabled>
                    üíæ Save Course
                </button>
                <button class="admin-action-btn danger" id="btnDeleteCourse" onclick="deleteCourse()">
                    üóë Delete Course
                </button>
            </div>
            <div class="course-info" id="courseInfo">
                No course set
            </div>
        </div>
    </div>
    
    <div class="drawing-mode-indicator" id="drawingIndicator">
        üéØ Click map: Start ‚Üí Marks ‚Üí Finish (double-click to save)
    </div>

    <!-- User edit dialog -->
    <div class="edit-user-overlay" id="editUserOverlay" onclick="if(event.target===this)closeEditUser()">
        <div class="edit-user-dialog">
            <h3>Edit User: <span id="editUserId"></span></h3>
            <label for="editUserName">Display Name</label>
            <input type="text" id="editUserName" placeholder="Leave blank for default">
            <label for="editUserRole">Role</label>
            <select id="editUserRole">
                <option value="">Default</option>
                <option value="sailor">Sailor</option>
                <option value="support">Support Boat</option>
                <option value="spectator">Spectator</option>
            </select>
            <div style="margin: 12px 0;">
                <label style="display:flex;align-items:center;gap:8px;cursor:pointer;">
                    <input type="checkbox" id="editUserHidden" style="width:18px;height:18px;">
                    <span>Hidden (not shown on map)</span>
                </label>
            </div>
            <div class="btn-row">
                <button class="btn-cancel" onclick="closeEditUser()">Cancel</button>
                <button class="btn-save" onclick="saveEditUser()">Save</button>
            </div>
            <button class="btn-remove" id="btnRemoveOverride" onclick="removeUserOverride()" style="display:none">
                Remove Override
            </button>
        </div>
    </div>

    <script>
        // Initialize map centered on Auckland
        const map = L.map('map').setView([-36.8485, 174.7633], 13);

        // Map layers
        const osmLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '¬© OpenStreetMap contributors',
            maxZoom: 19,
            maxNativeZoom: 19
        });

        let googleLayers = {};
        let currentMapType = localStorage.getItem('mapType') || 'osm';
        let currentLayer = null;

        // Initialize with saved preference
        function initMapLayers() {
            // Show map type menu item if Google Maps is available
            if (GMAPS_API_KEY && GMAPS_API_KEY !== 'YOUR_API_KEY_HERE' && typeof google !== 'undefined') {
                document.getElementById('menuMapType').style.display = '';

                // Create Google layers for each type
                googleLayers.roads = L.gridLayer.googleMutant({ type: 'roadmap', maxZoom: 21 });
                googleLayers.satellite = L.gridLayer.googleMutant({ type: 'satellite', maxZoom: 21 });
                googleLayers.hybrid = L.gridLayer.googleMutant({ type: 'hybrid', maxZoom: 21 });

                // Apply saved map type
                setMapType(currentMapType, true);
            } else {
                osmLayer.addTo(map);
                currentLayer = osmLayer;
                currentMapType = 'osm';
            }
        }

        function toggleMapSubmenu() {
            const submenu = document.getElementById('mapSubmenu');
            submenu.classList.toggle('visible');
        }

        function setMapType(mapType, isInit) {
            // Remove current layer
            if (currentLayer) {
                map.removeLayer(currentLayer);
            }

            // Add new layer
            if (mapType === 'osm') {
                currentLayer = osmLayer;
            } else if (googleLayers[mapType]) {
                currentLayer = googleLayers[mapType];
            } else {
                // Fallback to OSM
                currentLayer = osmLayer;
                mapType = 'osm';
            }
            currentLayer.addTo(map);
            currentMapType = mapType;
            localStorage.setItem('mapType', mapType);

            // Update menu selection
            document.querySelectorAll('#mapSubmenu .menu-submenu-item').forEach(item => {
                item.classList.toggle('selected', item.dataset.maptype === mapType);
            });

            // Close submenu unless initializing
            if (!isInit) {
                document.getElementById('mapSubmenu').classList.remove('visible');
            }
        }

        // Initialize map layers after Google Maps API loads (or immediately if not using it)
        if (GMAPS_API_KEY && GMAPS_API_KEY !== 'YOUR_API_KEY_HERE') {
            // Wait for Google Maps API to load
            window.addEventListener('load', function() {
                setTimeout(initMapLayers, 500);
            });
        } else {
            initMapLayers();
        }

        // Allow extra zoom beyond tile native resolution
        map.setMaxZoom(21);
        
        // Custom scale control
        function updateScale() {
            const center = map.getCenter();
            const zoom = map.getZoom();
            
            // Calculate meters per pixel at current zoom and latitude
            // At zoom 0, the world is 256 pixels wide = 40075km at equator
            const metersPerPixel = 40075016.686 * Math.cos(center.lat * Math.PI / 180) / Math.pow(2, zoom + 8);
            
            // Find a nice round distance that fits in ~80-200 pixels
            const distances = [10, 20, 50, 100, 200, 500, 1000, 2000, 5000, 10000, 20000, 50000];
            let bestDist = distances[0];
            let bestWidth = bestDist / metersPerPixel;
            
            for (const dist of distances) {
                const width = dist / metersPerPixel;
                if (width >= 80 && width <= 200) {
                    bestDist = dist;
                    bestWidth = width;
                    break;
                }
                if (width < 200) {
                    bestDist = dist;
                    bestWidth = width;
                }
            }
            
            // Update the scale bar
            document.getElementById('scaleBar').style.width = bestWidth + 'px';
            
            // Format the distance text
            let text;
            if (bestDist >= 1000) {
                text = (bestDist / 1000) + ' km';
            } else {
                text = bestDist + ' m';
            }
            document.getElementById('scaleText').textContent = text;
        }
        
        // Update scale on zoom/move
        map.on('zoomend', updateScale);
        map.on('moveend', updateScale);
        updateScale();  // Initial update
        
        // Store markers and state
        const sailorMarkers = {};
        const sailorTracks = {};      // Polylines for each sailor
        const sailorTrackData = {};   // Track points for each sailor
        const sailorOutliers = {};    // Outlier markers for each sailor
        const showTrack = {};         // Whether to show track for each sailor
        let showOutliers = false;     // Admin toggle to show outlier points
        let deviceMarker = null;
        let deviceHeadingMarker = null;
        let currentPositions = null;
        let currentLogDate = null;    // Currently loaded log date
        let trackDataLoaded = false;
        let panelCollapsed = false;
        const categoryCollapsed = { sailor: false, support: false, spectator: true };
        
        // Audio alert system for assist requests
        let audioContext = null;
        let hasActiveAssist = false;
        let audioEnabled = false;  // Requires user interaction to enable
        
        function initAudio() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            audioEnabled = true;
        }
        
        function playDoubleTone() {
            if (!audioContext || !audioEnabled) return;
            
            // Resume context if suspended (browser autoplay policy)
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
            
            const now = audioContext.currentTime;
            
            // First tone
            const osc1 = audioContext.createOscillator();
            const gain1 = audioContext.createGain();
            osc1.connect(gain1);
            gain1.connect(audioContext.destination);
            osc1.frequency.value = 880;  // A5
            osc1.type = 'sine';
            gain1.gain.setValueAtTime(0.3, now);
            gain1.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
            osc1.start(now);
            osc1.stop(now + 0.15);
            
            // Second tone (higher pitch)
            const osc2 = audioContext.createOscillator();
            const gain2 = audioContext.createGain();
            osc2.connect(gain2);
            gain2.connect(audioContext.destination);
            osc2.frequency.value = 1100;  // ~C#6
            osc2.type = 'sine';
            gain2.gain.setValueAtTime(0.3, now + 0.2);
            gain2.gain.exponentialRampToValueAtTime(0.01, now + 0.35);
            osc2.start(now + 0.2);
            osc2.stop(now + 0.35);
        }
        
        // Check and play alert every 10 seconds
        setInterval(() => {
            if (hasActiveAssist && audioEnabled) {
                playDoubleTone();
            }
        }, 10000);
        
        // Enable audio on first user interaction
        document.addEventListener('click', () => {
            if (!audioEnabled) {
                initAudio();
                console.log('Audio alerts enabled');
            }
        }, { once: false });
        
        // Admin state
        let adminMode = false;
        let adminPassword = localStorage.getItem('adminPassword') || '';
        let showHiddenTrackers = false;

        // Menu state
        let menuOpen = false;
        let showLabels = localStorage.getItem('showLabels') === 'true';

        function showAbout() {
            document.getElementById('about-modal').classList.add('show');
            document.getElementById('menuPanel').classList.remove('visible');
        }

        function hideAbout() {
            document.getElementById('about-modal').classList.remove('show');
        }

        // Close about modal when clicking outside
        document.getElementById('about-modal').addEventListener('click', function(e) {
            if (e.target.id === 'about-modal') {
                hideAbout();
            }
        });

        function toggleMenu() {
            const menuPanel = document.getElementById('menuPanel');
            const adminPanel = document.getElementById('adminPanel');
            const anyVisible = menuPanel.classList.contains('visible') || adminPanel.classList.contains('visible');

            if (anyVisible) {
                // Hide everything
                menuPanel.classList.remove('visible');
                adminPanel.classList.remove('visible');
                menuOpen = false;
            } else {
                // Show menu
                menuPanel.classList.add('visible');
                menuOpen = true;
            }
        }

        function toggleLabels() {
            showLabels = !showLabels;
            localStorage.setItem('showLabels', showLabels);
            document.getElementById('menuLabels').classList.toggle('active', showLabels);
            // Refresh markers to show/hide labels
            if (currentPositions?.sailors) {
                updateMarkers(currentPositions.sailors);
            }
        }

        // Initialize label menu item state
        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('menuLabels').classList.toggle('active', showLabels);
        });

        // Close menu/admin when clicking outside
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.menu-btn') && !e.target.closest('.menu-panel') && !e.target.closest('.admin-panel')) {
                menuOpen = false;
                document.getElementById('menuPanel').classList.remove('visible');
                document.getElementById('adminPanel').classList.remove('visible');
            }
        });

        // API base URL - can be set via ?api=http://host:port URL parameter
        // Default: same origin (works with nginx proxy) or same host with tracker port
        const urlParams = new URLSearchParams(window.location.search);
        const API_BASE = urlParams.get('api') || window.location.origin;
        
        // Course state
        let courseData = null;
        let courseMarkers = [];       // Leaflet markers for course
        let courseLines = [];         // Leaflet polylines for course
        let drawingMode = false;
        let drawingPoints = [];       // Points being drawn
        let drawingMarkers = [];      // Temporary markers while drawing
        let drawingLine = null;       // Temporary line while drawing
        
        // Admin functions
        async function checkAdminAuth() {
            try {
                const response = await fetch(`${API_BASE}/api/auth/check`, {
                    headers: { 'X-Admin-Password': adminPassword }
                });
                const data = await response.json();
                return data.authenticated;
            } catch (e) {
                console.error('Auth check failed:', e);
                return false;
            }
        }
        
        async function toggleAdminMode() {
            // Close menu first
            menuOpen = false;
            document.getElementById('menuPanel').classList.remove('visible');

            if (adminMode) {
                // Exit admin mode
                adminMode = false;
                document.getElementById('adminBtn').classList.remove('active');
                document.getElementById('adminPanel').classList.remove('visible');
                document.getElementById('menuAdmin').classList.remove('active');
                cancelDrawing();
            } else {
                // Try to enter admin mode
                if (!adminPassword) {
                    adminPassword = prompt('Enter admin password:');
                    if (!adminPassword) return;
                }

                const authenticated = await checkAdminAuth();
                if (authenticated) {
                    adminMode = true;
                    localStorage.setItem('adminPassword', adminPassword);
                    document.getElementById('adminBtn').classList.add('active');
                    document.getElementById('adminPanel').classList.add('visible');
                    document.getElementById('menuAdmin').classList.add('active');
                    updateCourseInfo();
                    await loadUserOverrides();
                    // Refresh markers to show edit buttons
                    if (currentPositions?.sailors) {
                        updateMarkers(currentPositions.sailors);
                    }
                } else {
                    adminPassword = '';
                    localStorage.removeItem('adminPassword');
                    alert('Invalid password');
                }
            }
        }
        
        async function clearTracks() {
            if (!confirm('Clear all track data? Old tracks are available via review page.')) return;
            
            try {
                const response = await fetch(`${API_BASE}/api/admin/clear-tracks`, {
                    method: 'POST',
                    headers: { 'X-Admin-Password': adminPassword }
                });
                const data = await response.json();
                if (data.success) {
                    // Clear local track data
                    for (const id of Object.keys(sailorTrackData)) {
                        sailorTrackData[id] = [];
                        if (sailorTracks[id]) {
                            sailorTracks[id].setLatLngs([]);
                        }
                    }
                    trackLogLastModified = null;
                    alert('Tracks cleared');
                } else {
                    alert('Error: ' + (data.error || 'Unknown error'));
                }
            } catch (e) {
                alert('Error clearing tracks: ' + e.message);
            }
        }
        
        function startDrawingCourse() {
            if (drawingMode) {
                cancelDrawing();
                return;
            }
            
            drawingMode = true;
            drawingPoints = [];
            drawingMarkers = [];
            document.getElementById('btnDrawCourse').textContent = '‚ùå Cancel Drawing';
            document.getElementById('btnSaveCourse').disabled = true;
            document.getElementById('drawingIndicator').classList.add('visible');
            
            map.on('click', onDrawingClick);
            map.on('dblclick', onDrawingComplete);
            map.getContainer().style.cursor = 'crosshair';
        }
        
        function cancelDrawing() {
            drawingMode = false;
            drawingPoints = [];
            document.getElementById('btnDrawCourse').textContent = '‚úèÔ∏è Draw Course';
            document.getElementById('drawingIndicator').classList.remove('visible');
            
            // Remove temporary markers and line
            drawingMarkers.forEach(m => map.removeLayer(m));
            drawingMarkers = [];
            if (drawingLine) {
                map.removeLayer(drawingLine);
                drawingLine = null;
            }
            
            map.off('click', onDrawingClick);
            map.off('dblclick', onDrawingComplete);
            map.getContainer().style.cursor = '';
        }
        
        function onDrawingClick(e) {
            const point = { lat: e.latlng.lat, lon: e.latlng.lng };
            drawingPoints.push(point);
            
            // Determine marker type
            let icon;
            if (drawingPoints.length === 1) {
                icon = createStartIcon();
            } else {
                icon = createMarkIcon(drawingPoints.length - 1);
            }
            
            const marker = L.marker([point.lat, point.lon], { icon, draggable: true }).addTo(map);
            marker.on('drag', () => updateDrawingLine());
            marker.on('dragend', () => {
                const idx = drawingMarkers.indexOf(marker);
                if (idx >= 0) {
                    const pos = marker.getLatLng();
                    drawingPoints[idx] = { lat: pos.lat, lon: pos.lng };
                }
            });
            drawingMarkers.push(marker);
            
            updateDrawingLine();
            
            // Enable save after at least 2 points
            document.getElementById('btnSaveCourse').disabled = drawingPoints.length < 2;
        }
        
        function onDrawingComplete(e) {
            e.originalEvent.preventDefault();
            if (drawingPoints.length < 2) {
                alert('Need at least a start and finish point');
                return;
            }

            // Replace last marker with finish icon
            const lastMarker = drawingMarkers[drawingMarkers.length - 1];
            lastMarker.setIcon(createFinishIcon());

            // Done drawing
            drawingMode = false;
            document.getElementById('btnDrawCourse').textContent = '‚úèÔ∏è Draw Course';
            document.getElementById('drawingIndicator').classList.remove('visible');

            map.off('click', onDrawingClick);
            map.off('dblclick', onDrawingComplete);
            map.getContainer().style.cursor = '';

            updateCourseInfo();

            // Auto-save the course
            saveCourse();
        }
        
        function updateDrawingLine() {
            const latlngs = drawingMarkers.map(m => m.getLatLng());
            
            if (drawingLine) {
                drawingLine.setLatLngs(latlngs);
            } else if (latlngs.length >= 2) {
                drawingLine = L.polyline(latlngs, {
                    color: '#ff6600',
                    weight: 3,
                    dashArray: '10, 10'
                }).addTo(map);
            }
        }
        
        async function saveCourse() {
            if (drawingPoints.length < 2) return;
            
            const course = {
                start: drawingPoints[0],
                marks: drawingPoints.slice(1, -1),
                finish: drawingPoints[drawingPoints.length - 1]
            };
            
            try {
                const response = await fetch(`${API_BASE}/api/admin/course`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-Admin-Password': adminPassword
                    },
                    body: JSON.stringify(course)
                });
                const data = await response.json();
                if (data.success) {
                    // Clear drawing state - remove markers from map first
                    drawingMarkers.forEach(m => map.removeLayer(m));
                    drawingMarkers = [];
                    if (drawingLine) {
                        map.removeLayer(drawingLine);
                        drawingLine = null;
                    }
                    drawingPoints = [];
                    document.getElementById('btnSaveCourse').disabled = true;
                    
                    // Reload course
                    await loadCourse();
                    alert('Course saved');
                } else {
                    alert('Error: ' + (data.error || 'Unknown error'));
                }
            } catch (e) {
                alert('Error saving course: ' + e.message);
            }
        }
        
        async function deleteCourse() {
            if (!confirm('Delete the course?')) return;
            
            try {
                const response = await fetch(`${API_BASE}/api/admin/course`, {
                    method: 'DELETE',
                    headers: { 'X-Admin-Password': adminPassword }
                });
                const data = await response.json();
                if (data.success) {
                    clearCourseDisplay();
                    courseData = null;
                    updateCourseInfo();
                    updateCourseLengthDisplay();
                    alert('Course deleted');
                }
            } catch (e) {
                alert('Error deleting course: ' + e.message);
            }
        }
        
        function updateCourseInfo() {
            const info = document.getElementById('courseInfo');
            if (drawingPoints.length > 0) {
                info.textContent = `Drawing: ${drawingPoints.length} points (double-click to save)`;
            } else if (courseData && courseData.start) {
                const markCount = courseData.marks ? courseData.marks.length : 0;
                info.textContent = `Course set: Start + ${markCount} marks + Finish`;
            } else {
                info.textContent = 'No course set';
            }
        }

        // Calculate distance between two points using Haversine formula (returns km)
        function haversineDistance(lat1, lon1, lat2, lon2) {
            const R = 6371; // Earth's radius in km
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                      Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                      Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }

        // Filter outliers from track positions using physics-based detection
        // Returns { filtered: [...], outliers: [...] }
        function filterOutliers(positions) {
            const SPEED_MARGIN_KNOTS = 20;
            const filtered = [];
            const outliers = [];

            for (let i = 0; i < positions.length; i++) {
                const pos = positions[i];

                if (i === 0) {
                    filtered.push(pos);
                    continue;
                }

                const prev = positions[i - 1];
                const timeDelta = pos.ts - prev.ts;

                if (timeDelta > 0) {
                    const distanceKm = haversineDistance(prev.lat, prev.lon, pos.lat, pos.lon);
                    const distanceM = distanceKm * 1000;
                    const impliedSpeedMs = distanceM / timeDelta;
                    const impliedSpeedKnots = impliedSpeedMs * 1.94384;
                    const maxAllowed = Math.max(prev.spd || 0, pos.spd || 0) + SPEED_MARGIN_KNOTS;

                    if (impliedSpeedKnots > maxAllowed) {
                        outliers.push(pos);
                        continue;
                    }
                }

                filtered.push(pos);
            }

            return { filtered, outliers };
        }

        // Calculate average sampling interval from recent track points
        function calculateSamplingInterval(positions, count = 5) {
            if (!positions || positions.length < 2) return null;

            const recent = positions.slice(-Math.min(count + 1, positions.length));
            if (recent.length < 2) return null;

            let totalInterval = 0;
            let intervals = 0;

            for (let i = 1; i < recent.length; i++) {
                const delta = recent[i].ts - recent[i-1].ts;
                if (delta > 0 && delta < 300) {  // Ignore gaps > 5 min
                    totalInterval += delta;
                    intervals++;
                }
            }

            return intervals > 0 ? totalInterval / intervals : null;
        }

        // Calculate total course length in km
        function calculateCourseLength(course) {
            if (!course || !course.start || !course.finish) return 0;

            const points = [course.start];
            if (course.marks) {
                points.push(...course.marks);
            }
            points.push(course.finish);

            let totalDistance = 0;
            for (let i = 0; i < points.length - 1; i++) {
                totalDistance += haversineDistance(
                    points[i].lat, points[i].lon,
                    points[i+1].lat, points[i+1].lon
                );
            }
            return totalDistance;
        }

        // Update the course length display in the legend
        function updateCourseLengthDisplay() {
            const el = document.getElementById('courseLengthDisplay');
            if (courseData && courseData.start) {
                const length = calculateCourseLength(courseData);
                el.textContent = `Course: ${length.toFixed(1)} km`;
            } else {
                el.textContent = 'Course: No course';
            }
        }

        async function loadCourse() {
            try {
                const response = await fetch(`${API_BASE}/api/course`);
                const data = await response.json();
                
                if (data.start) {
                    courseData = data;
                    displayCourse(data);
                } else {
                    courseData = null;
                    clearCourseDisplay();
                }
                updateCourseInfo();
                updateCourseLengthDisplay();
            } catch (e) {
                console.error('Error loading course:', e);
            }
        }
        
        function clearCourseDisplay() {
            courseMarkers.forEach(m => map.removeLayer(m));
            courseMarkers = [];
            courseLines.forEach(l => map.removeLayer(l));
            courseLines = [];
        }
        
        function displayCourse(course) {
            clearCourseDisplay();
            
            const points = [];
            
            // Start marker
            if (course.start) {
                const marker = L.marker([course.start.lat, course.start.lon], {
                    icon: createStartIcon()
                }).addTo(map);
                marker.bindPopup('<strong>Start</strong>');
                courseMarkers.push(marker);
                points.push([course.start.lat, course.start.lon]);
            }
            
            // Mark markers
            if (course.marks) {
                course.marks.forEach((mark, idx) => {
                    const marker = L.marker([mark.lat, mark.lon], {
                        icon: createMarkIcon(idx + 1)
                    }).addTo(map);
                    marker.bindPopup(`<strong>Mark ${idx + 1}</strong>${mark.name ? '<br>' + mark.name : ''}`);
                    courseMarkers.push(marker);
                    points.push([mark.lat, mark.lon]);
                });
            }
            
            // Finish marker
            if (course.finish) {
                const marker = L.marker([course.finish.lat, course.finish.lon], {
                    icon: createFinishIcon()
                }).addTo(map);
                marker.bindPopup('<strong>Finish</strong>');
                courseMarkers.push(marker);
                points.push([course.finish.lat, course.finish.lon]);
            }
            
            // Course line
            if (points.length >= 2) {
                const line = L.polyline(points, {
                    color: '#ff6600',
                    weight: 3,
                    opacity: 0.7,
                    dashArray: '10, 5'
                }).addTo(map);
                courseLines.push(line);
            }
        }
        
        // Course marker icons
        function createStartIcon() {
            const svg = `
                <svg width="32" height="32" viewBox="-16 -16 32 32" xmlns="http://www.w3.org/2000/svg">
                    <circle cx="0" cy="0" r="12" fill="#22c55e" stroke="#166534" stroke-width="2"/>
                    <text x="0" y="5" text-anchor="middle" fill="white" font-size="12" font-weight="bold">S</text>
                </svg>
            `;
            return L.divIcon({
                html: svg,
                className: 'course-marker',
                iconSize: [32, 32],
                iconAnchor: [16, 16]
            });
        }
        
        function createMarkIcon(number) {
            const svg = `
                <svg width="32" height="32" viewBox="-16 -16 32 32" xmlns="http://www.w3.org/2000/svg">
                    <circle cx="0" cy="0" r="12" fill="#f97316" stroke="#c2410c" stroke-width="2"/>
                    <text x="0" y="5" text-anchor="middle" fill="white" font-size="11" font-weight="bold">${number}</text>
                </svg>
            `;
            return L.divIcon({
                html: svg,
                className: 'course-marker',
                iconSize: [32, 32],
                iconAnchor: [16, 16]
            });
        }
        
        function createFinishIcon() {
            const svg = `
                <svg width="32" height="32" viewBox="-16 -16 32 32" xmlns="http://www.w3.org/2000/svg">
                    <!-- Checkered flag pattern -->
                    <rect x="-12" y="-12" width="24" height="24" fill="white" stroke="#333" stroke-width="2" rx="3"/>
                    <rect x="-12" y="-12" width="6" height="6" fill="#333"/>
                    <rect x="0" y="-12" width="6" height="6" fill="#333"/>
                    <rect x="-6" y="-6" width="6" height="6" fill="#333"/>
                    <rect x="6" y="-6" width="6" height="6" fill="#333"/>
                    <rect x="-12" y="0" width="6" height="6" fill="#333"/>
                    <rect x="0" y="0" width="6" height="6" fill="#333"/>
                    <rect x="-6" y="6" width="6" height="6" fill="#333"/>
                    <rect x="6" y="6" width="6" height="6" fill="#333"/>
                </svg>
            `;
            return L.divIcon({
                html: svg,
                className: 'course-marker',
                iconSize: [32, 32],
                iconAnchor: [16, 16]
            });
        }
        
        // User edit state
        let userOverrides = {};
        let editingUserId = null;

        // Load user overrides from server
        async function loadUserOverrides() {
            if (!adminMode) return;
            try {
                const response = await fetch(`${API_BASE}/api/users`, {
                    headers: { 'X-Admin-Password': adminPassword }
                });
                if (response.ok) {
                    const data = await response.json();
                    userOverrides = data.users || {};
                }
            } catch (e) {
                console.error('Error loading user overrides:', e);
            }
        }

        // Show edit dialog for a user
        function showEditUser(userId) {
            editingUserId = userId;
            document.getElementById('editUserId').textContent = userId;

            // Pre-fill with current override if exists
            const override = userOverrides[userId] || {};
            document.getElementById('editUserName').value = override.name || '';
            document.getElementById('editUserRole').value = override.role || '';
            document.getElementById('editUserHidden').checked = override.hidden || false;

            // Show remove button if override exists
            document.getElementById('btnRemoveOverride').style.display =
                Object.keys(override).length > 0 ? 'block' : 'none';

            document.getElementById('editUserOverlay').classList.add('visible');
        }

        function closeEditUser() {
            editingUserId = null;
            document.getElementById('editUserOverlay').classList.remove('visible');
        }

        async function saveEditUser() {
            if (!editingUserId) return;

            const name = document.getElementById('editUserName').value.trim();
            const role = document.getElementById('editUserRole').value;
            const hidden = document.getElementById('editUserHidden').checked;

            const data = {};
            if (name) data.name = name;
            if (role) data.role = role;
            data.hidden = hidden;  // Always include hidden state

            if (Object.keys(data).length === 1 && !data.hidden) {
                // Only hidden=false with no other data - treat as remove
                await removeUserOverride();
                return;
            }

            try {
                const response = await fetch(`${API_BASE}/api/admin/user/${encodeURIComponent(editingUserId)}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-Admin-Password': adminPassword
                    },
                    body: JSON.stringify(data)
                });
                const result = await response.json();
                if (result.success) {
                    userOverrides[editingUserId] = data;
                    closeEditUser();
                    // Refresh positions to show updated data
                    await fetchPositions();
                } else {
                    alert('Error: ' + (result.error || 'Unknown error'));
                }
            } catch (e) {
                alert('Error saving user: ' + e.message);
            }
        }

        async function removeUserOverride() {
            if (!editingUserId) return;

            try {
                const response = await fetch(`${API_BASE}/api/admin/user/${encodeURIComponent(editingUserId)}`, {
                    method: 'DELETE',
                    headers: { 'X-Admin-Password': adminPassword }
                });
                const result = await response.json();
                if (result.success) {
                    delete userOverrides[editingUserId];
                    closeEditUser();
                    // Refresh positions to show updated data
                    await fetchPositions();
                }
            } catch (e) {
                alert('Error removing override: ' + e.message);
            }
        }

        // Toggle showing hidden trackers
        function toggleShowHidden() {
            showHiddenTrackers = document.getElementById('showHiddenToggle').checked;
            // Refresh display with current positions
            if (currentPositions?.sailors) {
                updateMarkers(currentPositions.sailors);
                updateSailorList(currentPositions.sailors);
            }
        }

        function toggleShowOutliers() {
            showOutliers = document.getElementById('showOutliersToggle').checked;
            // Refresh all visible tracks
            for (const id in showTrack) {
                if (showTrack[id]) {
                    updateTrackDisplay(id);
                }
            }
        }

        // Panel toggle functions
        function togglePanel() {
            panelCollapsed = !panelCollapsed;
            document.getElementById('panelContent').classList.toggle('collapsed', panelCollapsed);
            document.getElementById('panelToggle').textContent = panelCollapsed ? '‚ñ∂' : '‚ñº';
        }
        
        function toggleCategory(category) {
            categoryCollapsed[category] = !categoryCollapsed[category];
            document.getElementById(category + 'List').classList.toggle('collapsed', categoryCollapsed[category]);
            document.getElementById(category + 'Toggle').textContent = categoryCollapsed[category] ? '‚ñ∂' : '‚ñº';
        }
        
        // Create icon based on role (with optional label)
        function createRoleIcon(role, heading, isRecent, needsAssist, label) {
            let iconData;
            switch(role) {
                case 'support':
                    iconData = { size: 48, anchor: 24, svg: createSupportBoatSvg(heading, isRecent, needsAssist) };
                    break;
                case 'spectator':
                    iconData = { size: 40, anchor: 20, svg: createSpectatorSvg(heading, isRecent, needsAssist) };
                    break;
                default:
                    iconData = { size: 44, anchor: 22, svg: createSurfboardSvg(heading, isRecent, needsAssist) };
            }

            // Add label if provided
            const labelHtml = label ? `<div class="marker-label">${label}</div>` : '';

            return L.divIcon({
                html: `<div style="position:relative">${iconData.svg}${labelHtml}</div>`,
                className: 'marker-icon',
                iconSize: [iconData.size, iconData.size + (label ? 20 : 0)],
                iconAnchor: [iconData.anchor, iconData.anchor]
            });
        }

        // SVG generators (split from icon creators for label support)
        function createSurfboardSvg(heading, isRecent, needsAssist) {
            const opacity = isRecent ? 1.0 : 0.6;
            const assistRing = needsAssist ? `<circle cx="0" cy="0" r="18" fill="none" stroke="#ef4444" stroke-width="3" stroke-dasharray="4,2"/>` : '';

            return `
                <svg width="44" height="44" viewBox="-22 -22 44 44" xmlns="http://www.w3.org/2000/svg">
                    <g transform="rotate(${heading})" opacity="${opacity}">
                        ${assistRing}
                        <defs>
                            <clipPath id="boardClip${heading}">
                                <ellipse cx="0" cy="0" rx="6" ry="17"/>
                            </clipPath>
                        </defs>
                        <ellipse cx="0" cy="0" rx="6" ry="17" fill="#3b82f6" stroke="#1e40af" stroke-width="1"/>
                        <ellipse cx="0" cy="-8" rx="6" ry="10" fill="white" clip-path="url(#boardClip${heading})"/>
                        <g clip-path="url(#boardClip${heading})">
                            <line x1="-8" y1="-8" x2="0" y2="-16" stroke="#f97316" stroke-width="2"/>
                            <line x1="-8" y1="-5" x2="2" y2="-15" stroke="#3b82f6" stroke-width="1.5"/>
                            <line x1="-8" y1="-3" x2="4" y2="-15" stroke="#06b6d4" stroke-width="1.5"/>
                        </g>
                        <rect x="-0.75" y="-4" width="1.5" height="10" fill="#1e293b" rx="0.5"/>
                        <ellipse cx="0" cy="2" rx="2" ry="1.2" fill="#dc2626"/>
                        <circle cx="0" cy="14" r="1.5" fill="white" stroke="#cbd5e1" stroke-width="0.5"/>
                        <ellipse cx="0" cy="0" rx="6" ry="17" fill="none" stroke="white" stroke-width="0.5" opacity="0.5"/>
                    </g>
                </svg>
            `;
        }

        function createSupportBoatSvg(heading, isRecent, needsAssist) {
            const opacity = isRecent ? 1.0 : 0.6;
            const assistRing = needsAssist ? `<circle cx="0" cy="0" r="20" fill="none" stroke="#ef4444" stroke-width="3" stroke-dasharray="4,2"/>` : '';

            return `
                <svg width="48" height="48" viewBox="-24 -24 48 48" xmlns="http://www.w3.org/2000/svg">
                    <g transform="rotate(${heading})" opacity="${opacity}">
                        ${assistRing}
                        <path d="M-6,-16 Q-8,-12 -8,0 Q-8,12 -6,16 L6,16 Q8,12 8,0 Q8,-12 6,-16 Z"
                              fill="#ff6600" stroke="#cc4400" stroke-width="1.5"/>
                        <path d="M-6,-16 Q0,-20 6,-16" fill="#ff6600" stroke="#cc4400" stroke-width="1.5"/>
                        <rect x="-4" y="-6" width="8" height="8" rx="1" fill="#ffffff" stroke="#666" stroke-width="1"/>
                        <rect x="-3" y="-5" width="6" height="3" fill="#87CEEB" stroke="#666" stroke-width="0.5"/>
                        <rect x="-5" y="10" width="10" height="4" rx="1" fill="#333" stroke="#000" stroke-width="0.5"/>
                        <path d="M-4,16 Q0,20 4,16" fill="none" stroke="#fff" stroke-width="1" opacity="0.6"/>
                    </g>
                </svg>
            `;
        }

        function createSpectatorSvg(heading, isRecent, needsAssist) {
            const opacity = isRecent ? 1.0 : 0.6;
            const assistRing = needsAssist ? `<circle cx="0" cy="0" r="18" fill="none" stroke="#ef4444" stroke-width="3" stroke-dasharray="4,2"/>` : '';

            return `
                <svg width="40" height="40" viewBox="-20 -20 40 40" xmlns="http://www.w3.org/2000/svg">
                    <g transform="rotate(${heading})" opacity="${opacity}">
                        ${assistRing}
                        <ellipse cx="-6" cy="-2" rx="5" ry="8" fill="#444" stroke="#222" stroke-width="1"/>
                        <ellipse cx="-6" cy="-8" rx="4" ry="3" fill="#666" stroke="#222" stroke-width="0.5"/>
                        <ellipse cx="-6" cy="-8" rx="3" ry="2" fill="#88ccff" opacity="0.6"/>
                        <ellipse cx="6" cy="-2" rx="5" ry="8" fill="#444" stroke="#222" stroke-width="1"/>
                        <ellipse cx="6" cy="-8" rx="4" ry="3" fill="#666" stroke="#222" stroke-width="0.5"/>
                        <ellipse cx="6" cy="-8" rx="3" ry="2" fill="#88ccff" opacity="0.6"/>
                        <rect x="-4" y="-2" width="8" height="6" rx="2" fill="#555" stroke="#222" stroke-width="1"/>
                        <polygon points="0,-14 -3,-10 3,-10" fill="#888" stroke="#444" stroke-width="0.5"/>
                    </g>
                </svg>
            `;
        }
        
        // Get today's date in YYYY_MM_DD format
        function getTodayLogDate() {
            const d = new Date();
            return `${d.getFullYear()}_${String(d.getMonth() + 1).padStart(2, '0')}_${String(d.getDate()).padStart(2, '0')}`;
        }
        
        // Track last modified time for conditional requests
        let trackLogLastModified = null;
        
        // Load track data from log file (uses If-Modified-Since and deduplication)
        async function loadTrackData() {
            const logDate = getTodayLogDate();
            
            // If date changed, reset everything
            if (currentLogDate !== logDate) {
                currentLogDate = logDate;
                trackLogLastModified = null;
                trackDataLoaded = false;

                // Clear existing track data
                for (const id in sailorTrackData) {
                    sailorTrackData[id] = [];
                }
            }
            
            try {
                const url = `logs/${logDate}.jsonl`;

                // Use conditional request - only download if file changed
                const headers = {};
                if (trackLogLastModified) {
                    headers['If-Modified-Since'] = trackLogLastModified;
                }

                const response = await fetch(url, { headers });

                if (response.status === 404) {
                    // No log file yet today
                    return;
                }

                if (response.status === 304) {
                    // Not modified - no new data
                    return;
                }

                // Save Last-Modified for next request
                const lastMod = response.headers.get('Last-Modified');
                if (lastMod) {
                    trackLogLastModified = lastMod;
                }
                
                const text = await response.text();
                if (!text.trim()) {
                    return;
                }
                
                const lines = text.trim().split('\n').filter(l => l);
                let newPoints = 0;
                
                // Parse each line and append to track data (with deduplication)
                for (const line of lines) {
                    try {
                        const entry = JSON.parse(line);
                        const id = entry.id;

                        if (!sailorTrackData[id]) {
                            sailorTrackData[id] = [];
                        }

                        // Skip if we already have this timestamp for this user
                        const existing = sailorTrackData[id];
                        if (existing.length > 0 && existing[existing.length - 1].ts >= entry.ts) {
                            continue;
                        }

                        existing.push({
                            lat: entry.lat,
                            lon: entry.lon,
                            ts: entry.ts,
                            spd: entry.spd,
                            hdg: entry.hdg
                        });
                        newPoints++;
                    } catch (e) {
                        // Skip malformed lines
                    }
                }

                trackDataLoaded = true;

                // Update any visible tracks if we got new data
                if (newPoints > 0) {
                    for (const id in showTrack) {
                        if (showTrack[id]) {
                            updateTrackDisplay(id);
                        }
                    }
                }
                
            } catch (error) {
                console.log('Error loading track data:', error);
            }
        }
        
        // Update track polyline for a sailor
        function updateTrackDisplay(sailorId) {
            // Remove existing track if any
            if (sailorTracks[sailorId]) {
                map.removeLayer(sailorTracks[sailorId]);
                delete sailorTracks[sailorId];
            }

            // Remove existing outlier markers if any
            if (sailorOutliers[sailorId]) {
                sailorOutliers[sailorId].forEach(m => map.removeLayer(m));
                delete sailorOutliers[sailorId];
            }

            // If track should be hidden, we're done
            if (!showTrack[sailorId]) {
                return;
            }

            // Get track data
            const points = sailorTrackData[sailorId];
            if (!points || points.length < 2) {
                return;
            }

            // Sort by timestamp to ensure correct order
            points.sort((a, b) => a.ts - b.ts);

            // Deduplicate points with same timestamp
            const uniquePoints = [];
            let lastTs = -1;
            for (const p of points) {
                if (p.ts !== lastTs) {
                    uniquePoints.push(p);
                    lastTs = p.ts;
                }
            }

            // Filter outliers
            const { filtered, outliers } = filterOutliers(uniquePoints);

            // Create polyline from filtered points
            const latlngs = filtered.map(p => [p.lat, p.lon]);

            // Color based on sailor ID (generate consistent color)
            const hue = (sailorId.split('').reduce((a, c) => a + c.charCodeAt(0), 0) * 37) % 360;
            const color = `hsl(${hue}, 70%, 50%)`;

            sailorTracks[sailorId] = L.polyline(latlngs, {
                color: color,
                weight: 3,
                opacity: 0.8,
                lineJoin: 'round'
            }).addTo(map);

            // Show outliers as red markers if admin toggle is enabled
            if (showOutliers && outliers.length > 0) {
                sailorOutliers[sailorId] = outliers.map(p => {
                    const marker = L.circleMarker([p.lat, p.lon], {
                        radius: 6,
                        color: '#ff0000',
                        fillColor: '#ff0000',
                        fillOpacity: 0.7,
                        weight: 2
                    }).addTo(map);

                    // Add tooltip with outlier info
                    const time = new Date(p.ts * 1000).toLocaleTimeString();
                    marker.bindTooltip(`Outlier: ${time}<br>Speed: ${(p.spd || 0).toFixed(1)} kn`, {
                        permanent: false
                    });

                    return marker;
                });
            }
            
            // Add direction arrows every ~10 points
            const arrowInterval = Math.max(1, Math.floor(points.length / 20));
            for (let i = arrowInterval; i < points.length; i += arrowInterval) {
                const p = points[i];
                // Could add arrow markers here if desired
            }
        }
        
        // Toggle track display for a sailor
        function toggleTrack(sailorId, show) {
            showTrack[sailorId] = show;
            
            if (show && !trackDataLoaded) {
                loadTrackData().then(() => updateTrackDisplay(sailorId));
            } else {
                updateTrackDisplay(sailorId);
            }
        }
        
        // Get track point count for a sailor
        function getTrackPointCount(sailorId) {
            return sailorTrackData[sailorId]?.length || 0;
        }
        
        // SVG for device position (blue dot with heading arrow)
        function createDeviceIcon(heading) {
            const hasHeading = heading !== null && !isNaN(heading);
            const svg = `
                <svg width="44" height="44" viewBox="-22 -22 44 44" xmlns="http://www.w3.org/2000/svg">
                    <!-- Accuracy circle -->
                    <circle cx="0" cy="0" r="18" fill="rgba(66, 133, 244, 0.15)" stroke="none"/>
                    <!-- Heading arrow -->
                    ${hasHeading ? `
                        <g transform="rotate(${heading})">
                            <polygon points="0,-20 -6,-8 6,-8" fill="rgba(66, 133, 244, 0.6)"/>
                        </g>
                    ` : ''}
                    <!-- Blue dot -->
                    <circle cx="0" cy="0" r="8" fill="#4285F4" stroke="white" stroke-width="3"/>
                </svg>
            `;
            
            return L.divIcon({
                html: svg,
                className: 'device-icon',
                iconSize: [44, 44],
                iconAnchor: [22, 22]
            });
        }
        
        // Format time ago
        function timeAgo(timestamp) {
            const seconds = Math.floor(Date.now() / 1000 - timestamp);
            if (seconds < 60) return `${seconds}s ago`;
            if (seconds < 3600) return `${Math.floor(seconds / 60)}m ago`;
            return `${Math.floor(seconds / 3600)}h ago`;
        }
        
        // Update sailor list panel
        function updateSailorList(sailors) {
            if (!sailors || Object.keys(sailors).length === 0) {
                document.getElementById('panelTitle').textContent = 'Tracking (0)';
                document.getElementById('sailorList').innerHTML = '';
                document.getElementById('supportList').innerHTML = '';
                document.getElementById('spectatorList').innerHTML = '';
                document.getElementById('assistAlerts').style.display = 'none';
                document.getElementById('sailorCount').textContent = '0';
                document.getElementById('supportCount').textContent = '0';
                document.getElementById('spectatorCount').textContent = '0';
                document.getElementById('hiddenCount').textContent = '0';
                return;
            }

            const now = Date.now() / 1000;
            const allRaw = Object.values(sailors);

            // Count and filter hidden users
            const hiddenUsers = allRaw.filter(s => s.hidden);
            document.getElementById('hiddenCount').textContent = hiddenUsers.length;

            // Filter out hidden users unless admin toggle is on
            const all = showHiddenTrackers ? allRaw : allRaw.filter(s => !s.hidden);

            // Separate by role
            const sailorList = all.filter(s => (s.role || 'sailor') === 'sailor');
            const supportList = all.filter(s => s.role === 'support');
            const spectatorList = all.filter(s => s.role === 'spectator');
            
            // Find assist requests
            const assistList = all.filter(s => s.ast);
            const hadAssist = hasActiveAssist;
            hasActiveAssist = assistList.length > 0;
            
            // Play immediate alert when assist first appears
            if (hasActiveAssist && !hadAssist && audioEnabled) {
                playDoubleTone();
            }
            
            // Update panel title
            document.getElementById('panelTitle').textContent = `Tracking (${all.length})`;
            
            // Update counts
            document.getElementById('sailorCount').textContent = sailorList.length;
            document.getElementById('supportCount').textContent = supportList.length;
            document.getElementById('spectatorCount').textContent = spectatorList.length;
            
            // Show/hide sections
            document.getElementById('sailorSection').style.display = sailorList.length ? 'block' : 'none';
            document.getElementById('supportSection').style.display = supportList.length ? 'block' : 'none';
            document.getElementById('spectatorSection').style.display = spectatorList.length ? 'block' : 'none';
            
            // Render assist alerts (always visible)
            const alertsDiv = document.getElementById('assistAlerts');
            if (assistList.length > 0) {
                alertsDiv.style.display = 'block';
                alertsDiv.innerHTML = assistList.map(s => `
                    <div class="assist-alert-item" onclick="centerOnSailor('${s.id}')">
                        ‚ö† ${s.id} NEEDS ASSISTANCE
                    </div>
                `).join('');
            } else {
                alertsDiv.style.display = 'none';
            }
            
            // Render function for each list
            const renderList = (items) => {
                return items.sort((a, b) => {
                    if (a.ast && !b.ast) return -1;
                    if (!a.ast && b.ast) return 1;
                    // Sort by display name if available, otherwise ID
                    const nameA = a.name || a.id;
                    const nameB = b.name || b.id;
                    return nameA.localeCompare(nameB);
                }).map(sailor => {
                    const age = now - sailor.last_seen;
                    const isRecent = age < 120;
                    const statusClass = sailor.ast ? 'status-red' : (isRecent ? 'status-green' : 'status-orange');

                    const batStr = sailor.bat >= 0 ? `${sailor.bat}%` : '?';
                    const sigStr = sailor.sig >= 0 ? `${'‚ñÇ‚ñÑ‚ñÜ‚ñà'.slice(0, sailor.sig + 1)}` : '?';
                    const batColor = sailor.bat < 20 ? 'color:#CC0000;font-weight:bold' : '';

                    // Check battery saver flags
                    const flg = sailor.flg || {};
                    const hasPowerSave = flg.ps === true;
                    const hasBatOptIgnored = flg.bo === true;
                    const hasWarning = hasPowerSave || (flg.bo === false);  // Warn if power save ON or bat opt NOT ignored
                    const warningBadge = hasWarning ? '<span style="background:#f97316;color:white;padding:1px 4px;border-radius:3px;font-size:9px;margin-left:4px;" title="' + (hasPowerSave ? 'Power saver ON' : 'Battery optimization enabled') + '">‚ö°</span>' : '';

                    // Show display name with ID in parentheses if different
                    const displayName = sailor.name || sailor.id;
                    const idSuffix = sailor.name ? ` <span style="color:#999;font-size:10px">[${sailor.id}]</span>` : '';
                    const hiddenBadge = sailor.hidden ? '<span style="background:#888;color:white;padding:1px 4px;border-radius:3px;font-size:9px;margin-left:4px;">HIDDEN</span>' : '';
                    const rowStyle = sailor.hidden ? 'opacity:0.6;' : '';

                    return `
                        <div class="sailor-item" style="${rowStyle}" onclick="centerOnSailor('${sailor.id}')">
                            <div class="status-dot ${statusClass}"></div>
                            <div class="sailor-info">
                                <span class="sailor-id">${displayName}</span>${idSuffix}${hiddenBadge}${warningBadge}
                                ${sailor.ast ? '<span class="assist-badge">ASSIST</span>' : ''}
                                <div class="sailor-details">
                                    ${sailor.spd.toFixed(1)} kn ¬∑ <span style="${batColor}">${batStr}</span> ¬∑ ${sigStr} ¬∑ ${timeAgo(sailor.last_seen)}
                                </div>
                            </div>
                        </div>
                    `;
                }).join('');
            };
            
            // Render each category
            document.getElementById('sailorList').innerHTML = renderList(sailorList);
            document.getElementById('supportList').innerHTML = renderList(supportList);
            document.getElementById('spectatorList').innerHTML = renderList(spectatorList);
        }
        
        // Center map on a specific sailor
        function centerOnSailor(sailorId) {
            if (currentPositions && currentPositions.sailors && currentPositions.sailors[sailorId]) {
                const sailor = currentPositions.sailors[sailorId];
                map.setView([sailor.lat, sailor.lon], 16);
                map._userPanned = true;  // Prevent auto-fit from overriding
                
                // Open the popup for this sailor
                if (sailorMarkers[sailorId]) {
                    sailorMarkers[sailorId].openPopup();
                }
            }
        }
        
        // Update markers on map
        function updateMarkers(sailors) {
            if (!sailors) return;

            const now = Date.now() / 1000;

            // Filter out hidden users unless admin toggle is on
            const visibleSailors = {};
            for (const [id, sailor] of Object.entries(sailors)) {
                if (!sailor.hidden || showHiddenTrackers) {
                    visibleSailors[id] = sailor;
                }
            }

            const activeSailorIds = new Set(Object.keys(visibleSailors));

            // Remove markers for sailors no longer visible (hidden or removed)
            for (const id of Object.keys(sailorMarkers)) {
                if (!activeSailorIds.has(id)) {
                    map.removeLayer(sailorMarkers[id]);
                    delete sailorMarkers[id];
                }
            }

            // Update or create markers
            for (const [id, sailor] of Object.entries(visibleSailors)) {
                const age = now - sailor.last_seen;
                const isRecent = age < 120;
                const role = sailor.role || 'sailor';
                const displayName = sailor.name || sailor.id;
                const label = showLabels ? displayName : null;
                const icon = createRoleIcon(role, sailor.hdg, isRecent, sailor.ast, label);
                const pos = [sailor.lat, sailor.lon];
                
                if (sailorMarkers[id]) {
                    sailorMarkers[id].setLatLng(pos);
                    sailorMarkers[id].setIcon(icon);
                } else {
                    sailorMarkers[id] = L.marker(pos, { icon }).addTo(map);
                }
                
                // Update popup
                const trackChecked = showTrack[id] ? 'checked' : '';
                const trackCount = getTrackPointCount(id);
                const trackInfo = trackCount > 0 ? ` (${trackCount} points)` : '';
                
                // Format battery and signal for popup
                const batStr = sailor.bat >= 0 ? `${sailor.bat}%` : 'Unknown';
                const sigBars = sailor.sig >= 0 ? sailor.sig : 0;
                const sigStr = sailor.sig >= 0 ? `${sailor.sig}/4` : 'Unknown';
                const batStyle = sailor.bat >= 0 && sailor.bat < 20 ? 'color:red;font-weight:bold' : '';
                const roleLabel = role.charAt(0).toUpperCase() + role.slice(1);

                // Check battery saver flags for popup
                const flg = sailor.flg || {};
                const powerSaveWarning = flg.ps ? '<br><span style="color:#f97316;font-weight:bold">‚ö° Power Saver ON</span>' : '';
                const batOptWarning = flg.bo === false ? '<br><span style="color:#f97316;font-weight:bold">‚ö° Battery Optimization Enabled</span>' : '';

                // Display name (use override if set, otherwise ID) - displayName already defined above
                const nameExtra = sailor.name ? ` <span style="color:#999;font-size:10px">[${sailor.id}]</span>` : '';
                const editBtn = adminMode ? `<button class="popup-edit-btn" onclick="showEditUser('${id}')">Edit</button>` : '';

                const versionStr = sailor.ver || 'Unknown';
                const osStr = sailor.os || '';
                const osLine = (adminMode && osStr) ? `<br>OS: <span style="color:#666;font-size:11px">${osStr}</span>` : '';
                const heartRateLine = (sailor.hr && sailor.hr > 0) ? `<br>Heart Rate: <span style="color:#e91e63">${sailor.hr} bpm</span>` : '';

                // Calculate sampling rate from track data
                const trackPoints = sailorTrackData[id] || [];
                const samplingInterval = calculateSamplingInterval(trackPoints);
                let samplingStr = '';
                if (samplingInterval !== null) {
                    const rateHz = (1 / samplingInterval).toFixed(2);
                    samplingStr = `<br>Sampling: ${samplingInterval.toFixed(1)}s (${rateHz} Hz)`;
                }

                // Calculate battery drain rate display
                let drainStr = '';
                if (sailor.chg === true) {
                    // Explicit charging state from device
                    drainStr = ` <span style="color:#666;font-size:11px">(charging)</span>`;
                } else if (sailor.bdr !== undefined && sailor.bdr !== null && sailor.bat >= 0) {
                    const drainRate = sailor.bdr;
                    if (drainRate > 0) {
                        const hoursRemaining = sailor.bat / drainRate;
                        drainStr = ` <span style="color:#666;font-size:11px">(${drainRate.toFixed(1)}%/hr, ~${hoursRemaining.toFixed(1)}h left)</span>`;
                    }
                    // Don't show anything if drainRate <= 0 and not explicitly charging
                }

                sailorMarkers[id].bindPopup(`
                    <strong>${displayName}</strong>${nameExtra} <span style="color:#666;font-size:11px">(${roleLabel})</span>${editBtn}${sailor.ast ? ' <span style="color:red;font-weight:bold">‚ö† ASSIST</span>' : ''}<br>
                    Speed: ${sailor.spd.toFixed(1)} kn<br>
                    Heading: ${sailor.hdg}¬∞<br>
                    Position: ${sailor.lat.toFixed(5)}, ${sailor.lon.toFixed(5)}<br>
                    Battery: <span style="${batStyle}">${batStr}</span>${drainStr}<br>
                    Signal: ${sigStr}${heartRateLine}<br>
                    Updated: ${timeAgo(sailor.last_seen)}<br>
                    Version: <span style="color:#666;font-size:11px">${versionStr}</span>${osLine}${samplingStr}${powerSaveWarning}${batOptWarning}
                    <div class="popup-checkbox">
                        <label>
                            <input type="checkbox" ${trackChecked} onchange="toggleTrack('${id}', this.checked)">
                            Display Track${trackInfo}
                        </label>
                    </div>
                `);
            }
            
            // Auto-fit bounds if we have sailors (only before user interaction)
            if (Object.keys(sailors).length > 0 && !map._userPanned) {
                const bounds = Object.values(sailors).map(s => [s.lat, s.lon]);
                if (deviceMarker) {
                    bounds.push(deviceMarker.getLatLng());
                }
                if (bounds.length > 0) {
                    map._fitting = true;
                    map.fitBounds(bounds, { padding: [50, 50], maxZoom: 15 });
                    // Clear fitting flag after animation completes
                    setTimeout(() => { map._fitting = false; }, 300);
                }
            }
        }
        
        // Track if user has manually panned or zoomed the map
        map.on('dragstart', () => { map._userPanned = true; });
        map.on('zoomstart', (e) => {
            // Only set flag if zoom was user-initiated (not from fitBounds)
            if (!map._fitting) {
                map._userPanned = true;
            }
        });
        
        // Fetch positions from server
        async function fetchPositions() {
            try {
                const response = await fetch('current_positions.json?' + Date.now());
                if (!response.ok) throw new Error('Failed to fetch');
                
                currentPositions = await response.json();
                
                updateMarkers(currentPositions.sailors);
                updateSailorList(currentPositions.sailors);
                
                document.getElementById('lastUpdate').textContent = 
                    `Last update: ${new Date(currentPositions.updated * 1000).toLocaleTimeString()}`;
                
                document.getElementById('connectionStatus').textContent = 'Connected';
                document.getElementById('connectionStatus').className = 'connection-status connection-ok';
                
            } catch (error) {
                console.error('Error fetching positions:', error);
                document.getElementById('connectionStatus').textContent = 'Connection error';
                document.getElementById('connectionStatus').className = 'connection-status connection-error';
            }
        }
        
        // Device position tracking
        let deviceHeading = null;
        
        function updateDevicePosition(position) {
            const pos = [position.coords.latitude, position.coords.longitude];
            const icon = createDeviceIcon(deviceHeading);
            
            if (deviceMarker) {
                deviceMarker.setLatLng(pos);
                deviceMarker.setIcon(icon);
            } else {
                deviceMarker = L.marker(pos, { icon, zIndexOffset: 1000 }).addTo(map);
                deviceMarker.bindPopup('<strong>Your Position</strong>');
            }
        }
        
        function handleDeviceOrientation(event) {
            // Get compass heading
            if (event.webkitCompassHeading !== undefined) {
                // iOS
                deviceHeading = event.webkitCompassHeading;
            } else if (event.alpha !== null) {
                // Android - alpha is degrees from north
                deviceHeading = 360 - event.alpha;
            }
            
            // Update device marker with new heading
            if (deviceMarker) {
                const icon = createDeviceIcon(deviceHeading);
                deviceMarker.setIcon(icon);
            }
        }
        
        // Start tracking device position
        if ('geolocation' in navigator) {
            navigator.geolocation.watchPosition(
                updateDevicePosition,
                (error) => console.log('Geolocation error:', error),
                { enableHighAccuracy: true, maximumAge: 5000 }
            );
        }
        
        // Start tracking device orientation
        if (window.DeviceOrientationEvent) {
            // Check if we need to request permission (iOS 13+)
            if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                // Add a button to request permission
                const btn = document.createElement('button');
                btn.textContent = 'Enable Compass';
                btn.style.cssText = 'position:absolute;top:10px;left:200px;z-index:1000;padding:8px 12px;border-radius:8px;border:none;background:#4285F4;color:white;cursor:pointer;';
                document.body.appendChild(btn);
                btn.addEventListener('click', async () => {
                    try {
                        const permission = await DeviceOrientationEvent.requestPermission();
                        if (permission === 'granted') {
                            window.addEventListener('deviceorientation', handleDeviceOrientation);
                            btn.remove();
                        }
                    } catch (e) {
                        console.error('Orientation permission error:', e);
                    }
                });
            } else {
                window.addEventListener('deviceorientation', handleDeviceOrientation);
            }
        }
        
        // Initial fetch and start polling
        fetchPositions();
        loadTrackData();  // Initial track load
        loadCourse();     // Load course
        setInterval(fetchPositions, 3000);   // Poll positions every 3 seconds
        setInterval(loadTrackData, 10000);   // Incremental track update every 10 seconds (uses Range requests)
        setInterval(loadCourse, 30000);      // Check for course updates every 30 seconds
    </script>
</body>
</html>
